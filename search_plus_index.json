{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"phase01.html":{"url":"phase01.html","title":"Phase I","keywords":"","body":"HTML CSS 响应式 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"01html.html":{"url":"01html.html","title":"HTML","keywords":"","body":" 一、前端介绍 二、浏览器介绍 三、 HTML介绍 四、HTML 标签的定义 五、HTML元素的解释 六、网页的基础配置 ** 元素定义一个大标题 ```html 七、HTML 注释 八、常用标签 九、标签类型 十、类型转换 笔记 一、前端介绍 前端是什么？ 1）前端指的是网站前台部分，是运行在PC端，移动端等浏览器上展示给用户浏览的网页。 前端开发能干什么？ 制作网页(https://www.bilibili.com/) 移动端软件 PC端软件 游戏（大部分50%游戏都是前端开发去实现的） 前端开发需要掌握什么技术？ 核心技术：（HTML、CSS、 Javascript) 前端开发的就业前景 1）普遍比其他的行业薪资高。 2）初级 中级 高级 全栈 前端开发需要用什么软件？ vsCode（专业级） webstrom、hbuilder（企业级） Dreamweaver（小白入门级） 二、浏览器介绍 Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。 浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户 三、 HTML介绍 超文本标记语言（HyperText Markup Language），简称就是HTML, 是一种用于创建网页的标准标记语言. HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本内容 HTML文档也叫做 web 页面 四、HTML 标签的定义 HTML 标记标签通常被称为 HTML 标签 HTML 标签是由尖括号包围的关键词，比如 ** - HTML 标签通常是成对出现的，比如 和 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签内容 五、HTML元素的解释 “HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思. 但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例: 这是一个段落。 六、网页的基础配置 1. **** 告诉浏览器，声明的文档类型 2. * ** 元素是 HTML 页面的根元素 3. * ** 元素包含了文档的元（meta）数据，如 ** ** 定义网页编码格式为 **utf-8** 4. * 5. * ** 元素包含了可见的页面内容 6. * ** 元素定义一个大标题 元素定义一个段落 网页标题 这是一个大标题 这是一个段落 注意：只有 里的内容才会在浏览器中显示。 七、HTML 注释 可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。 注释写法如下: 八、常用标签 1、文本标签 a、h1～h6、p、br、b、i、u、s、sub、sup 2、列表标签 ul、li、ol 3、图片标签 img 4、模块标签 div、span 5、表格标签 table 属性：border=\"1\" 边框为1。cellspacing=\"0\" 表格单元格空隙0。cellpadding=\"5\" 表格单元格内边距为5（内容离边框的距离） tr td 属性：colspan横向合并单元格、rowspan纵向合并单元格 thead tfoot 6、表单标签 账号 密码 性别 男 女 爱好 打游戏 旅游 打篮球 城市 广州 深圳 佛山 数字 留言 普通按钮 提交按钮 重置按钮 7、媒体标签 audio 音频播放 video 视屏播放 src=\"\"资源地址 controls 控制器 8、嵌套标签 标签标签（h1~h6） 网页标题 这是标题 1 这是标题 2 这是标题 3 这是标题 4 这是标题 5 这是标题 6 段落标签（p）这是一个段落。 超链接（a） 1）在href属性中指定链接的地址 这是一个链接 图片（img） 1）src属性中指定图片路径 2）通过width和height属性可以设置图片尺寸 水平线(hr) hr 元素可用于分隔内容。 这是段落。 这是段落。 文本加粗（b） 加粗文本 文本斜体（i） 加粗文本 文本的上标和下标(sup、sub) 我是 上标我是 下标 9.div 块状标签 没有任何含义，仅用于划分区域 块状标签 10.span 行内标签 没有任何含义，仅用于划分区域 行内标签 九、标签类型 块级标签，特点：独占一行，排斥其他标签。设置宽高、边距都生效。 例如：div 、p 、h1~h6、hr、ul-li 行内标签，特点：可以多个标签存在一行，不能直接设置行内标签的高度、宽度、行高以及顶和底边距，完全靠内容撑开宽高！ 例如：span、i、a、br、sub、sup 行内块标签，特点：结合的行内和块级的有点，不仅可以对宽高属性值生效，还可以多个标签存在一行显示。 例如：img、input、textarea 总结：各个标签之间的区别 1） 块标签：独自占领一行、可以进行宽高的数值的设定； ​ 2 ）行标签：在一行内显示、不可以进行宽高的数值设定； ​ 3） 行内块标签：能和其他元素待在一行，能设置宽高； 十、类型转换 三种类型之间的转换 display:inline; //转成行内元素 display:block; //转成块级元素 display:inline-block;//转成行内块级元素 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"02css.html":{"url":"02css.html","title":"CSS","keywords":"","body":" css能做什么 css如何使用 css优先级（权重） css选择器 浏览器内核 css样式 1、字体的样式 2、文本样式 3、装饰样式 4、排版布局样式 1)盒子模型 2)浮动 3)定位 4)弹性布局 5)网格布局 CSS CSS 指层叠样式表 (Cascading Style Sheets) CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一个 css能做什么 1、装饰页面。2、排版布局。 css如何使用 1、内嵌样式 内容 2、内联样式 3、外联样式 css优先级（权重） css优先级（权重） 作用范围越小，权重越高。 同样的作用范围，后面的样式覆盖前面的样式。 css选择器 //必记：id、class、元素、后代nth-child、兄弟选择、伪类、通配符 1、id选择器 例如：#a。id就像人的身份证一样，每个人都只有一个 2、class选择器 例如：.a。 class就像类别，每个人可以有多个类别 3、元素选择器 例如：div。可以选择所有的元素。 4、后代选择器 例如：.a .b。.a>.b。 可以选择.a里面的.b 指定选择第一个子元素 例如：ul li:first-child 指定选择最后一个子元素 例如：ul li:last-child 指定选择某个指定的子元素 例如：ul li:nth-child(2) 指定选择某个制定的子元素（兼容ie678） 例如：ul li:first-child+li 指定选择偶数的子元素 例如：ul li:nth-child(even).ul li:nth-child(2n+2) 指定选择奇数的子元素 例如：ul li:nth-child(odd).ul li:nth-child(2n+1) 5、兄弟选择器（相邻选择器）例如：div,p 6、伪类选择器 例如：div:hover。鼠标悬停上去div触发的效果 7、伪元素 例如ul::after 在ul的最后一个子项位置添加元素 8、通配符选择 例如：*。选中所有的元素 浏览器内核 浏览器内核 谷歌的chrome浏览器：旧 webkit 新 blink 苹果的safari浏览器：webkit 火狐的firefox浏览器：moz 欧朋浏览器： o 微软的ie浏览器： ms 微软的edge浏览器 Chromium css样式 1、字体的样式 color: red; //设置字体颜色 font-size: 60px; //字体大小 font-weight: bold; //字体加粗 font-style: italic; //字体倾斜 font-family:\"\"; //字体 //字体设置 @font-face { font-family: \"abc\"; src: url(\"abc.TTF\"); } div{ font-size: 60px; font-family:'abc';//使用字体 } 2、文本样式 text-decoration: underline; //下滑线 text-decoration: line-through; //删除线 text-align: center; //文本的水平居中 line-height:100px; //行高 display: table-cell;//转成表格元素 vertical-align: middle;//垂直居中 letter-spacing: 20px; //字间距 text-indent: 2em; //首行缩进2个字节 word-break: break-all; //所有的英文不管是否是一个单词都会换行 word-wrap: break-word; //识别到一个单词就会自动换行 overflow: hidden;//超出的部分隐藏 text-overflow: ellipsis;//超出的文本设置为省略号 //垂直居中 内容1 内容2 div{ width: 300px; height: 300px; border: 1px solid; display: table-cell; vertical-align:middle; } 3、装饰样式 width //宽度 height //高度 border: 1px solid #; //边框 （边框粗细 边框类型 边框颜色） background //背景 no-repeat 不重复 center 居中 linear-gradient(to right, red , yellow) //css3 线性渐变 (方向，初始颜色，结束颜色) background-size: 100% 100%; //背景尺寸 border-radius: 20px; //css3 圆角边框 opacity: 0.5; //css3 透明度 0～1 box-shadow: 5px 5px 5px 5px #000; //css3（x轴、y轴、阴影偏移度、阴影大小、阴影颜色） text-shadow: 2px 2px 2px #000; //css3（x轴、y轴、阴影偏移度、阴影颜色） transform //css3 变形 scale(0.5,1) //缩放（x轴，y轴） rotate(30deg) //旋转（角度） skew(30deg,30deg)//倾斜角度 translate(200px,200px) //平移 4、排版布局样式 1)盒子模型 margin 外边距 padding 内边距 边距塌陷：块级元素的上下外边距会出现边距塌陷。 解决方法：在父级元素添加 overflow:hidden; 2)浮动 浮动：浮动元素可以理解为浮起来的木板，非浮动元素可以立即为水流 浮动元素属于非正常文档流 浮动元素拥有把所有 元素变成了行内块级的特性 浮动塌陷:当一个元素里面只有浮动的元素，那么就会出现浮动塌陷 清除浮动 兼容所有浏览器的清除浮动写法 .clearFix::after{ content: \"\";/*内容为空*/ visibility: hidden;/*隐藏*/ height: 0;/*高度为0*/ display: block;/*转位块级元素*/ clear: both;/*清除浮动*/ } 3)定位 相对定位 position: relative; 相对于自己定位。 绝对定位 position: absolute; 相对于有相对定位的父级元素进行定位，没有的时候就相对于body。 固定定位 position: fixed; 相对于浏览器定位。 4)弹性布局 css3样式 //父级元素样式 display: flex; //弹性布局 flex-direction //设置主轴的方向 row //主轴为水平方向，起点在左端。 row-reverse //主轴为水平方向，起点在右端。 column //主轴为垂直方向，起点在上沿。 column-reverse //主轴为垂直方向，起点在下沿。 flex-wrap //设置是否换行 wrap //换行 justify-content //主轴的对齐方式 center //居中 space-between //两端对齐 space-around //每个元素两侧的间隔相等 space-evenly //每个间隔都相等 align-items //交叉轴对齐方式 center //居中 align-content //多行对齐方式 center //居中 //子级元素样式 order //属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow //属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 //如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。 flex-shrink //属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 //如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 //负值对该属性无效。 flex-basis //属性定义了在分配多余空间之前，项目占据的主轴空间 //效果跟宽度一样 flex //flex-grow, flex-shrink 和 flex-basis的简写 //1 1 auto,0 0 auto //建议用这个 align-self //单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 5)网格布局 //父元素 display:grid; grid-template-columns:repeat(3,1fr);//定义每一列的列宽 1fr代表1个片段，总宽占的比例 repeat是重复 grid-template-rows: repeat(3,1fr);//定义每一行的行宽 //子元素 grid-column-start: 1;//控制单元格的从哪里开始 grid-column-end: 3;//控制单元格的从哪里结束 grid-row-start: 1; grid-row-end: 3; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:27:52 "},"03响应式.html":{"url":"03响应式.html","title":"响应式","keywords":"","body":" 一、响应式布局介绍 二、常见手机屏幕尺寸 三、响应式框架 四、bootstrap介绍 响应式 一、响应式布局介绍 响应式布局是什么？ 实现不同屏幕分辨率的终端上浏览网页的不同展示方式。 常见布局方式 1）流式布局（响应式布局） 1.1）pc和移动端共用一套页面； 1.2）优点：只需要写一套代码，就能在多端运行 1.3）缺点：维护困难 1.4）适合创业或者建站公司 2）rem布局（自适应布局） 2.1）H5页面（比如：微信页面）、移动端 2.2）优点：维护容易 2.3）缺点：需要额外写其他端的代码 2.4）适合开发自己公司的网站 响应式布局怎么实现？ 1）设置meta标签 viewport 视图width=device-width 可视区域的宽度为设备的宽度， 如果不设置的话，默认视口宽度为980pxinital-scale=1 页面首次被显示的可视区域的缩放级别，取值1.0则页面按实际尺寸显示， 无任何缩放maximum-scale=1 用户可将页面放大的程序。 1.0将禁止用户放大到实际尺寸之上user-scalable=no 禁止用户缩放操作 2）媒体查询 2.1）概念：根据条件告诉浏览器如何为指定视图宽度渲染页面 2.2）设置单个视图宽度 @media screen and (max-width: 980px) { div { 样式属性 }} 2.3）设置多个视图宽度 /** iPad **/ @media only screen and (min-width: 768px) and (max-width: 1024px) {} @media only screen and (min-width: 320px) and (max-width: 767px) {} 2.4) 设置link标签 注意事项 3.1）宽度需要使用百分比 #head { width: 100% }#content { width: 50%; } 3.2）其余的样式，如字体，高度，margin，padding等都按照设计稿标注尺寸的一半来设置 3.3）物理像素和设计稿像素比例是1：2 3.4）对于有些屏幕尺寸下，我们设置的固定值看起来不是特别好看的话，使用@media进行微调 3.5）处理图片缩放，给图片指定的最大宽度为百分比。假如图片超过了，则自动缩小调整。假如图片小了，则原尺寸输出 img { width: auto; max-width: 100%; } 二、常见手机屏幕尺寸 苹果手机（ios） 1）5s以下都是320px宽度、6是375px宽度、6plus是414px宽度 安卓手机（android） 1）320、360、480、540、640、720 设计稿 1）640×1136 、640*×960 、750×1334 三、响应式框架 bootstrap iview 1）一套微信小程序的ui组件库 elements lay-ui 四、bootstrap介绍 bootstrap是什么？ 1）bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。 主要用于做响应式开发、移动端开发 安装 1）下载压缩包 2）通过cdn下载css、js、jq（https://blog.csdn.net/qq_35077107/article/details/105588524） 2.1) CDN就是内容传递网络，Content Delivery Network的缩写就是 CDN，简单的说就是Bootstrap把自己的css、Js等文件托管到某一个网络服务器上使用时调用。如果与Internet不通则无法使用CDN加速，可将文件下载到本地引用 如何使用？ 1）引入基本样式、js、jq 1.1）bootstrap的所有js效果都依赖jq，所以必须要加载jq 2）在标题上添加meta标签 或者 布局容器 1）.container : 用于固定宽度并支持响应式布局的容器 .container-fluid : 用于100%宽度，占据全部视口（viewport）的容器 3）bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。 注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。 栅格系统 1）随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列 1 2 3 4 5 6 7 8 9 10 11 12 类前缀 1）.col-xs- 1.1) 超小屏幕、手机、 2）.col-sm- 2.1) 小屏幕 、平板、≥768px 3）.col-md- 3.1) 中等屏幕、桌面显示器、≥992px 4）.col-lg- 4.1) 大屏幕、大桌面显示器、≥1200px 全局css样式 概念：直接添加标签或者class即可生效使用 2）辅助类 2.1）快速浮动 pull-left(左浮动)pull-right(右浮动) 注意：不能用于导航条组件中 导航条应该用.navbar-left 或 .navbar-right 2.2) 让内容块居中 .center-block(居中) 2.3）清除浮动 .clearfix(加在父元素上可清除浮动) 2.4）显示或隐藏内容 ```css .show(显示内容).hidden(隐藏内容) ``` 组件 1）字体图标 1.1）添加一个空的span标签，并加上class，不要与其他class混用 2）导航栏(.nav) 2.1）外层必须为nav标签 tokyoHot 首页 新闻中心 详情页 3）data-toggle 3.1）用于告诉 JavaScript 需要对按钮做什么 4）data-target 4.1）指示要切换到哪一个元素 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"phase02.html":{"url":"phase02.html","title":"Phase II","keywords":"","body":" npm webpack typescript git scss JavaScript npm webpack typescript git scss Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"JavaScriptES5.html":{"url":"JavaScriptES5.html","title":"JavaScriptES5","keywords":"","body":"JavaScriptES5 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"01变量.html":{"url":"01变量.html","title":"01变量","keywords":"","body":" 一、创建变量 二、var声明变量带来的问题 1、变量提升 2、给window添加属性 3、可以重复声明 变量 一、创建变量 es5 var a = 1 console.log(a);//1 es6 let a = 1 console.log(a);//1 二、var声明变量带来的问题 1、变量提升 使用var声明变量，会让该变量提升到当前作用域的最顶部，等价于以下代码 console.log(a)//undefined var a = 1 var a console.log(a)//undefined var a = 1 2、给window添加属性 声明全局变量的时候相当于给window对象也添加了一个属性 es5 var a = 1 console.log(a)//1 console.log(window.a)//1 es6 let a = 1 console.log(a)//1 console.log(window.a)//undefined 3、可以重复声明 连续声明变量不会报错，而是重新赋值 es5 var a = 1 var a = 2 console.log(a)//2 es6 【es6这种就报错了】 let a = 1 let a = 2 console.log(a);//报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"02常量.html":{"url":"02常量.html","title":"02常量","keywords":"","body":"常量 不能再进行更改的量，一般用于做一些不再更改的量，比如 baseUrl 等 const a = 1 const a = 2//报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:27:37 "},"03js数据类型.html":{"url":"03js数据类型.html","title":"03js数据类型","keywords":"","body":"一、检测数据类型 type of 变量 二、js数据类型 数字 number 字符串 string 布尔值 boolean 空值 null 未定义 undefined 对象 object 唯一值 symbol Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:28:31 "},"05数字类型.html":{"url":"05数字类型.html","title":"05数字类型","keywords":"","body":" 1、定义数字类型 2、隐式运算 3、非数字类型 数字类型 1、定义数字类型 在js中没有浮点型和整型之分,通通都是数字类型 var num = 1 console.log(typeof num); //number 2、隐式运算 var a = 1 var b = 2 console.log(a + b);//3 字符串 +号在有字符串 的时候会实现字符串拼接功能 var a = \"1\" var b = 2 console.log(a + b);//12 数字 -号会把字符串类型 转为数字类型 var a = \"1\" var b = 2 console.log(a - b);//-1 数字类型（非数字）强转但是转不了数字 所以变为非数字类型 var a = \"中\" var b = 2 console.log(a - b);//NaN 3、非数字类型 属于数字类型的一种特殊存在 非数字类型 属于数字类型 var a = \"中\" var b = 2 var c = a + b console.log(typeof c);//string var a = \"中\" var b = 2 var c = a - b console.log(typeof c);//number 检测非数字类型 使用isNaN可以检测 出这个值是否属于非数字 var a = \"中\" var b = 2 var c = a + b console.log(isNaN(c));//true Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"06字符串.html":{"url":"06字符串.html","title":"06字符串","keywords":"","body":" 1、声明字符串 2、字符串拼接 3、字符串长度属性 4、字符串操作 1. 字符串截取 2. 字符串转数字 3. 字符串转数组 4. 字符串替换 5. 查找字符串位置 6. 字符串拼接 7. 字符串转大小写 字符串 1、声明字符串 在js中单双引号 没有区别,以下没有区别 var a = \"hello world\" var b = 'hello world' 2、字符串拼接 es5 var a = \"娜美\" var b = \"有宙斯\" console.log(a + b); //娜美有宙斯 es6 除了字符串拼接还可以实现换行 let a = \"娜美\" let b = \"有宙斯\" console.log(`${a}${b}`); //娜美有宙斯 3、字符串长度属性 // 1 2 3 4 5 6 7 8 9 10 var a = \"娜美,妮可罗宾,大和\" console.log(a.length);//10 4、字符串操作 1) 字符串截取 slice()、substring()、substr() slice(start,end) start是必填参数，代表第一个字符串所在的位置， ​ end可选，代表最后一个字符串之前， end可以是负数 //截取妮可罗宾 var a = \"娜美，妮可罗宾，大和\" console.log(a.slice(3, 7));//妮可罗宾 //截取妮可罗宾,大和 var a = \"娜美，妮可罗宾，大和\" console.log(a.slice(3, a.length));//妮可罗宾，大和 substring(start,end) 用法跟slice一样，唯一不同是end不能使用负数 var str = '娜美，妮可罗宾，大和'; console.log(str.substring(3)); //妮可罗宾，大和 //第3位后面的数字全都显示 substr(start,length) 第二个参数为截取长度，不能为负数 var str = '娜美，妮可罗宾，大和'; console.log(str.substr(3, 4)); //妮可罗宾 //3是从，后面开始就不要了 4是从，3的前面开始的第四位都要。 2) 字符串转数字 Number 或 -0 var a = \"5\" console.log(Number(a));//5 var b = \"5\" console.log(b - 0);//5 var c = \"娜美\" console.log(c - 0);//NaN 文字或英文字母就返回NaN 3) 字符串转数组 split() console.log(a.split(\"\"));//[\"h\", \"e\", \"l\", \"l\", \"o\"] var b = \"hello,world\" console.log(b.split(\",\"));//[\"hello\", \"world\"] var c = \"hello world\" console.log(c.split(\" \"));//[\"hello\", \"world\"] 4) 字符串替换 replace() var a = \"娜美，妮可罗宾，大和\" console.log(a.replace(\"娜美\", \"波雅汉考克\"));//波雅汉考克，妮可罗宾，大和 也可以使用正则进行替换 g:所有，i:单个 var a = \"波雅汉考克，妮可罗宾，大和\" console.log(a.replace(/波雅汉考克/g, \"女帝\"));//女帝，妮可罗宾，大和 5) 查找字符串位置 前：indexOf() 后：lastIndexOf() // 0 1 2 3 4 5 6 7 8 9 10 var a = \"这是哪里，在这里，哪里\" console.log(a.indexOf(\"里\"));//3 console.log(a.lastIndexOf(\"里\"));//10 lastIndexOf这个直接到后了 案例：打印所有【里】的位置 var a = \"这是哪里，在这里，哪里\" var arr = a.split(\"\") arr.forEach(function (item, dd) { if (item === \"里\") { console.log(dd);//3, 7, 10 } }) 6) 字符串拼接 es5💖 var a = \"娜美\" var b = \"有宙斯\" console.log(a + b); //娜美有宙斯 es6，反引号 var a = \"娜美\" var b = \"有宙斯\" console.log(a.concat(b));//娜美有宙斯 7) 字符串转大小写 转大写 var a = \"hello\" console.log(a.toUpperCase());//HELLO 转小写 var b = \"WORLD\" console.log(b.toLowerCase());//world Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"07布尔值.html":{"url":"07布尔值.html","title":"07布尔值","keywords":"","body":" 在js里面1可以代表true，0 代表false //第一种 let a = true if(a == 1){ console.log(\"a是true\")//true }else{ console.log(\"a是false\") } //第二种 let a = true if(a == 2){ console.log(\"a是true\") }else{ console.log(\"a是false\")//false } //第三种 let a = false if(a == 1){ console.log(\"a是true\") }else{ console.log(\"a是false\")//false } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:29:39 "},"08空值.html":{"url":"08空值.html","title":"08空值","keywords":"","body":" let a = null; console.log(a);//null let a = null; console.log(typeof a);//打印出来object，因为js的历史原因，没有修复 //可以使用!来判断空值 let a = null; if(!a){ console.log(\"a是空值\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:30:09 "},"09未定义.html":{"url":"09未定义.html","title":"09未定义","keywords":"","body":" //没有赋值 let a; console.log(a)//undefined ////可以使用!来判断未定义 let a; if(!a){ console.log(\"a是未定义\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:30:40 "},"10唯一值.html":{"url":"10唯一值.html","title":"10唯一值","keywords":"","body":" symbol可以用来做对象的key值 但是正常情况下无法获取symbol 需要特殊方法才可以 使用symbol.for来存储数据 //每次创造出来的symbol都是唯一的，所以称为唯一值 let syb1 = Symbol(\"描述1\") let syb2 = Symbol(\"描述2\") console.log(syb1) console.log(syb2) console.log(syb1 === syb2)//false symbol可以用来做对象的key值 let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; 但是正常情况下无法获取symbol let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; for(key in obj){ console.log(key)//没有symbol } 需要特殊方法才可以 let mySymbol = Symbol(); let obj = { [mySymbol]: \"小明\", age:18 }; console.log(Object.getOwnPropertySymbols(obj))//打印出当前对象的所有symbol属性 console.log(Reflect.ownKeys(obj))//打印当前对象所有的属性，包括symbol 使用symbol.for来存储数据 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:31:02 "},"11对象.html":{"url":"11对象.html","title":"11对象","keywords":"","body":" 1、创建对象 获取值（value） 2、迭代对象的key和value es5写法 es6写法✨ 3、对象的增删改查操作 4、在对象里面的this关键字 1、方法 2、方法 5、对象的分类 对象 1、创建对象 字面量创建法 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } 获取值（value） var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } console.log(obj.name); //娜美✨✨ // console.log(obj[\"name\"]);//娜美 //也可以这样的写法 对象的value值可以写任意的值，而key只能写字符串 注意，对象没有length属性 2、迭代对象的key和value es5写法 只能迭代对象的value值 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } for (key in obj) { console.log(obj[key]) //娜美，18 console.log(key);//name、age } 案例：对象转【数组】 var obj = { name: \"娜美\", age: 18, sex: \"女\" }; var arr = [] for (key in obj) { arr.push(obj[key]) //arr.unshift()这种是反着来了 } console.log(arr);//[\"娜美\", 18, \"女\"] es6写法✨ 转【数组】 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } console.log(Object.keys(obj)) //key [\"name\", \"age\"] console.log(Object.values(obj))//value [\"娜美\", 18] 3、对象的增删改查操作 增 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } obj.sex = \"女\" // obj[\"sex\"] = \"男\" //也这可以这样的写法 console.log(obj);//{name: \"娜美\", age: 18, sex: \"女\"} 删 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sex: \"女\" } delete obj.sex console.log(obj);//{name: \"娜美\", age: 18} 改 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18 } // obj[\"name\"] = \"大和\" //也这可以这样的写法 obj.name = \"妮可罗宾\" console.log(obj); //{name: \"妮可罗宾\", age: 18} 查 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sex: \"女\" } // console.log(obj[\"name\"]); //也这可以这样的写法 console.log(obj.name); //娜美 console.log(Object.keys(obj));//[\"name\", \"age\", \"sex\"] console.log(Object.values(obj));//[\"娜美\", 18, \"女\"] 4、在对象里面的this关键字 关键字\"this\"指向了当前所在的上下文对象 var obj = { name: \"娜美\", //name是键（key），娜美是值（value） age: 18, sayHello: function () { console.log(this);//obj对象 {name: \"娜美\", age: 18, sayHello: ƒ} console.log(this.name);//娜美 } } obj.sayHello() this 是对象的指针，指的当前上下文手指的对象 隔壁老王的儿子，不是他儿子 隔壁刘王的儿子，不是他儿子 1、方法 var obj = { name: \"阿丽塔\", age: 18, sex: \"女\", say: function () { console.log(this);//{name: \"阿丽塔\", age: 18, sex: \"女\", say: ƒ} }, }; obj.say(); 这种是特殊了 console.log(this);//window 2、方法 var obj = { name: \"娜美\", obj2: { name: \"妮可罗宾\", say: function () { console.log(this); //{name: \"妮可罗宾\", say: ƒ} } } } obj.obj2.say() // obj[\"obj2\"].say() //也可以这样子写 5、对象的分类 //宿主对象（根据js所处的环境的对象） dom(document object model 文档对象模型) bom(browser objcet model 浏览器对象模型) //本地对象（需要实例化的，js自带的对象） new Object() new Function() new Array() new String() new Boolean() new Number() new Date() new RegExp() new Error() //内置对象(不需要实例化的对象) Global Math Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:31:27 "},"12内置全局对象.html":{"url":"12内置全局对象.html","title":"12内置全局对象","keywords":"","body":" 1、数学对象 圆周率 四舍五入 绝对值 向上取整 向下取整 幂 平方根 正弦 余弦 最小值 最大值 随机数 案例 2、全局对象 内置对象、全局对象 1、数学对象 圆周率 Math.PI 四舍五入 Math.round() console.log(Math.round(189.09));//189 console.log(Math.round(189.0001));//189 console.log(Math.round(175.0001));//175 console.log(Math.round(173.642));//174 绝对值 Math.abs() console.log(Math.abs(189.09));//189.09 console.log(Math.abs(189.0001));//189.0001 console.log(Math.abs(175.0001));//175.0001 console.log(Math.abs(173.642));//173.642 向上取整 Math.ceil() console.log(Math.ceil(189.09));//190 console.log(Math.ceil(189.0001));//190 console.log(Math.ceil(175.0001));//176 console.log(Math.ceil(173.542));//174 向下取整 Math.floor() console.log(Math.floor(189.09));//189 console.log(Math.floor(189.0001));//189 console.log(Math.floor(175.0001));//175 console.log(Math.floor(173.642));//173 幂 Math.pow() 平方根 Math.sqrt() 正弦 Math.sin() 余弦 Math.cos() 最小值 Math.min() console.log(Math.min(1, 2, 3));//1 console.log(Math.min(-1, -2, -3));//-3 var arr = [1, 2, 3] console.log(Math.min(...arr));//1 最大值 Math.max() console.log(Math.max(1, 2, 3));//3 console.log(Math.max(-1, -2, -3));//-1 var arr = [1, 2, 3] console.log(Math.max(...arr));//3 随机数 Math.random() console.log(Math.random());//0.5701630074981394 console.log(Math.round(Math.random()));// 0 , 1 console.log(Math.ceil(Math.random()));// 1 console.log(Math.floor(Math.random()));// 0 console.log(Math.abs(Math.random()));// 0.5701630074981394 案例 公式：Math.random() * （max - min）+ min // 2、请显示1-6之间的随机数 console.log(Math.ceil(Math.random() * 6)); // 案例：生成一个n到m之间的随机整数 function getRandom(n, m) { var choise = m - n + 1 //随机整数的个数 return Math.floor(Math.random() * choise + n) } var random1 = getRandom(2, 6) console.log(random1); 2、全局对象 encodeURI()//把字符串编码为 URI统一资源标识符 decodeURI()//解码某个编码的 URI isNaN()//检查某个值是否是数字 Number()//把对象的值转换为数字 parseFloat()//解析一个字符串并返回一个浮点数 parseInt()//解析一个字符串并返回一个整数 String()//把对象的值转换为字符串 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:23 "},"13数组.html":{"url":"13数组.html","title":"13数组","keywords":"","body":" 1、创建数组 2、数组属性 3、数组的增删改查 4、判断是否为数组 5、遍历数组 1. 遍历简洁数组 for for in✨ forEach✨ map✨ 2. 遍历复杂数组 6、数组的方法 1. 数组的变异方法 最后一个pop、push✨ 第一个unshift、shift✨ 万能✨💖 反转数组 数组排序 2. 数组的非变异方法 1数组每个元素相乘 2用forEach数组每个元素相乘 3数组之间的合并 4数组元素中所在的位置 5数组转字符串 6挑选数组元素并转新数组 7选择元素其余过滤掉 7、数组的操作✨💖 1、数组去重☃🏃‍♀️ 方法1 方法2 方法3(es6)✨ 2、数组的交并补差 合并 交集 并集 补集 差集 数组 1、创建数组 //第一种 ✨ 0 1 2 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\"] //第二种 var arr2 = new Array(\"娜美\", \"妮可罗宾\", \"大和\") console.log(arr2);//[\"娜美\", \"妮可罗宾\", \"大和\"] 2、数组属性 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr.length);//3 获取第一个成员 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr[0]);//娜美 获取最后一个成员 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(arr[arr.length - 1]);//大和 3、数组的增删改查 增 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr[3] = \"波雅汉考克\" console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 删 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] delete arr[0] console.log(arr);//[empty, \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 改 var arr = [\"empty\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr[0] = \"娜美\" console.log(arr);//[\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 查 // 0 1 2 3 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] console.log(arr[2]);//大和 4、判断是否为数组 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] console.log(Array.isArray(arr));//true ✨✨ console.log(arr instanceof Array);//true console.log(Object.prototype.toString.call(arr));//[object Array] 5、遍历数组 1) 遍历简洁数组 for var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] for (var i = 0; i for in✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] for (i in arr) { console.log(arr[i]);//娜美，妮可罗宾，大和 } forEach✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.forEach(function (item) { console.log(item);//娜美，妮可罗宾，大和 }) // // 也可以这样写 // arr.forEach((item) => { // console.log(item); // }) map✨ var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.map(function (item) { console.log(item);//娜美，妮可罗宾，大和 }) 2) 遍历复杂数组 var arr = [ { countryName: \"中国\", cites: [ { cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"汕尾\" }, ], }, { countryName: \"美国\", cites: [ { cityName: \"华盛顿\" }, { cityName: \"纽约\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cites: [ { cityName: \"东京\" }, { cityName: \"北海道\" }, { cityName: \"大阪\" }, ], }, ]; arr.map(function (item) { item.cites.map(function (items) { console.log(items.cityName) }) }) 6、数组的方法 1) 数组的变异方法 最后一个pop、push✨ 删除最后一个成员【pop】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.pop() console.log(arr);//[\"娜美\", \"妮可罗宾\"] 添加最后一个成员【push】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\"] arr.push(\"波雅汉考克\") console.log(arr);// [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 第一个unshift、shift✨ 删除第一个成员【shift】 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.shift() console.log(arr);//[\"妮可罗宾\", \"大和\", \"波雅汉考克\"] 添加第一个成员【unshift】 var arr = [\"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.unshift(\"娜美\") console.log(arr);// [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 万能✨💖 splice var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.splice(0, 0, \"new\") //01:位置，02:删除几个，03:增加 console.log(arr);//[\"new\", \"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] 反转数组 就是最后的数字就被排到前面来 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] arr.reverse() console.log(arr);//[\"波雅汉考克\", \"大和\", \"妮可罗宾\", \"娜美\"] 数组排序 就是一些扰乱的数字就可以排成整整齐齐 var arr = [3, 1, 0, 2] arr.sort() console.log(arr);//[0, 1, 2, 3] 2) 数组的非变异方法 1数组每个元素相乘 通过指定函数处理数组的每个元素，并返回处理后的数组 var arr = [1, 2, 3, 4] var arr2 = arr.map(function (item) { return item * 2 }) console.log(arr2);//[2, 4, 6, 8] 2用forEach数组每个元素相乘 forEach 为每个数组元素调用一次函数 只能迭代数组不能修改数组的成员 var arr = [1, 2, 3, 4] var arr2 = [] arr.forEach(function (item) { arr2.push(item * 2) }) console.log(arr2);// [2, 4, 6, 8] 3数组之间的合并 连接两个或更多的数组合并，并返回结果 var arr = [1, 2, 3] var arr2 = [4, 5, 6] var arr3 = arr.concat(arr2) console.log(arr3);// [1, 2, 3, 4, 5, 6] 4数组元素中所在的位置 搜索数组中的元素，并返回它所在的位置 // 0 1 2 var arr = [1, 2, 3] console.log(arr.indexOf(1));//0 console.log(arr.indexOf(4));//-1 没有出现在arr元素中就返回-1 5数组转字符串 把数组的所有元素放入一个字符串 var arr = [\"波雅汉考克\", \"大和\", \"妮可罗宾\", \"娜美\"] console.log(arr.join());//波雅汉考克,大和,妮可罗宾,娜美 6挑选数组元素并转新数组 选取数组的的一部分，并返回一个新数组 var arr = [\"娜美\", \"妮可罗宾\", \"大和\", \"波雅汉考克\"] var arr2 = arr.slice(0, 2) console.log(arr2);//[\"娜美\", \"妮可罗宾\"] 7选择元素其余过滤掉 过滤 数组，返回过滤后的数组 var arr = [1, 2, 3] var newArr = arr.filter(function (item) { return item % 2 === 0 }) console.log(newArr);//[2] 判断数组里面所有值 都符合条件，才返回true var arr = [1, 2, 3, -1, 3, 6] var bool = arr.every(function (item) { return item > 0 }) console.log(bool);//false 判断数组里面其中一个值 符合条件，就返回true var arr = [1, 2, 3, -1, 3, 6] var bool = arr.some(function (item) { return item > 0 }) console.log(bool);//true 7、数组的操作✨💖 1、数组去重☃🏃‍♀️ 方法1 var arr = [2, 2, 1, 6, 5]; var arr2 = []; arr.forEach(function (item) { if (arr2.indexOf(item) === -1) { arr2.push(item); } }); console.log(arr2);//[2, 1, 6, 5] 方法2 var arr = [2, 2, 1, 6, 5]; var arr2 = []; for (var i = 0; i 方法3(es6)✨ var arr = [2, 2, 1, 6, 5]; console.log([...new Set(arr)]);//[2, 1, 6, 5] 2、数组的交并补差 合并 合-两组合并，全有数都要 var arr = [1, 2, 3]; var arr2 = [4, 5, 6]; console.log(arr.concat(arr2)); //[1, 2, 3, 4, 5, 6] 交集 交集-两组合并相同就保留 数组交集(两个数组都有的值) var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 4, 6]; var arr3 = []; arr.forEach(function (item) { arr2.forEach(function (item2) { if (item === item2) { arr3.push(item); } }); }); console.log(arr3);//[2, 4] 并集 并集-两组合并有相同就保留一个数 数组并集(两个数组合并在一起不重复的值) var arr = [2, 4, 6, 8, 10]; var arr2 = [1, 2, 3, 4, 5]; var arr3 = arr.concat(arr2); console.log([...new Set(arr3)]);// [2, 4, 6, 8, 10, 1, 3, 5] grol 补集 补-两组合并有相同就舍掉 数组补集(两个数组不重复的值合并一起) var arr = [1, 2, 3, 4]; var arr2 = [1, 3, 5]; var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }); var newArr2 = arr2.filter(function (item) { return arr.indexOf(item) === -1; }); console.log(newArr.concat(newArr2)); //[2, 4, 5] 差集 差-两组对比最终要第一组 有跟第二组相同舍掉 数组差集(a数组有 b数组没有的) var arr = [1, 2, 3, 4, 5] var arr2 = [2, 4, 6, 8] var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }) console.log(newArr);//[1, 3, 5] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:32:00 "},"14函数.html":{"url":"14函数.html","title":"14函数","keywords":"","body":" 函数 函数的创建方式 1、一个叫fn的函数 2、一个函数然后赋值给fn 3、一个匿名函数 4、一个匿名函数 函数的属性 属性 属性转数组 关键字 函数复用性 作用域 1、没有声明就是上面的a 2、声明之后跟上面的a没有关系 闭包特性 加强记忆、 函数 函数的创建方式 长方形的面积 = 长 * 宽 //形式参数 50 = 10 * 5 //实际参数 function fn(形参){执行的内容} 1、一个叫fn的函数 function fn(a, b) { console.log(a * b); } fn(10, 5) //50=10*5 2、一个函数然后赋值给fn var fn = function (a, b) { console.log(a * b); } fn(10, 5) //50=10*5 3、一个匿名函数 (function (a, b) { console.log(a * b); })(10, 5) //50=10*5 4、一个匿名函数 !function (a, b) { console.log(a * b); }(10, 5) //50=10*5 函数的属性 属性 function fn() { console.log(arguments); } fn(1, 2, 3, 4, 5)//[1, 2, 3, 4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] 属性转数组 function fn() { console.log([...arguments]); } fn(1, 2, 3, 4, 5)//[1, 2, 3, 4, 5] 关键字 function fn(a, b) { console.log(this)//当前所在的作用域对象window return//返回值 } fn(1, 2) // {window: Window, self: Window, document: document, name: \"\", location: Location, …} function fn(a, b) { return a * b } console.log(fn(10, 5)); //50=10*5 函数复用性 function fn(a, b) { return a * b } fn(10, 5) fn(20, 10) 作用域 局部作用域可以访问全局作用域 但是全局作用域正常情况下访问不了局部作用域 例如：你在外面想看别人家洗澡是看不到了。哪里面的人就可以看的了外咯 var a = 1//在函数外声明的变量称为全局作用域 function fn(){ var a = 2//在函数里面声明的变量称为局部作用域 } var a = 1//全局变量 function fn() { console.log(a);//可以打印 } fn() function fn() { var a = 1//局部变量 } fn() console.log(a);//不可以打印 // 总结：函数里面可以访问函数外面，但是反过来不行 1、没有声明就是上面的a var a = 1 function fn1() { a = 2 //没有声明就是上面的a } fn1() console.log(a);//2 2、声明之后跟上面的a没有关系 var a = 1 function fn1() { var a = 2//声明之后跟上面的a没有关系 } fn1() console.log(a);//1 var a = 1 function fn1() { console.log(a);//undefined var a = 2 console.log(a);//2 } fn1() console.log(a);//1 闭包特性 函数闭包 闭包可以访问其他函数的作用域的数据，这个函数就被称为闭包 闭包实际上并没有让变量累加，累加靠的是垃圾回收机机制没有回收变量数据 闭包有什么用 1、获取局部变量的值 2、避免全局变量污染 3、用来做类的私有属性 function fn() { var a = 1; return function fn2() { //这个是闭包 console.log(++a); }; } var afn = fn(); afn(); //2 afn(); //3 加强记忆、 function fn() { var a = 1 return function fn2() {//这个是闭包 var b = 1 return function fn3() {//这个是闭包 console.log(++b); } } } var afn = fn()() //实际这里就多加的括号 afn()//2 afn()//3 //闭包 //闭包在使用的时候，能暂时性的存储数据到内存里面，如果是低版本浏览器（ie5-ie7） //就会出现内存泄漏问题，导致越来越卡，而新版本的浏览器比如chrome就不会有这种问题 function fn(){ let a = 1 function fn2(){ return ++a } return fn2 } let f = fn() console.log(f())//2 console.log(f())//3 console.log(f())//4 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:32:36 "},"15日期对象.html":{"url":"15日期对象.html","title":"15日期对象","keywords":"","body":" 获取日期对象 获取年月日星期时分秒 更改时间 格式化日期 字串转原型 获取时间戳 定时器 计时器 获取B站的所有标签符 日期对象 获取日期对象 new Date() 获取年月日星期时分秒 var week = [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"]//日期数组 var time = new Date()//获取日期对象 var year = time.getFullYear()//获取年 var month = time.getMonth() + 1//获取月 var date = time.getDate()//获取日 var day = time.getDay()//获取星期 var hours = time.getHours()//获取时 var minutes = time.getMinutes()//获取分 var seconds = time.getSeconds()//获取秒 console.log(year + \"年\" + month + \"月\" + date + \"日\" + \"星期\" + week[day] + hours + \"时\" + minutes + \"分\" + seconds + \"秒\"); //2021年12月15日星期三14时53分53秒 更改时间 var time = new Date(1999, 0, 1); console.log(time); 格式化日期 var time = new Date(2021, 0, 1) function formDate(formObject, sign = \"-\") { var year = formObject.getFullYear() var month = formObject.getMonth() + 1 var date = formObject.getDate() function formTime(number) { var str = String(number)//转成字符串 return str.length >= 2 ? str : \"0\" + str //三元运算符，如果字符串长度大于等于2，就返回str变量，如果不是就返回拼接的字符 } console.log(year + sign + formTime(month) + sign + formTime(date));//2021-01-01 } formDate(time) 字串转原型 var str = \"2021-12-15\"; function formDate(str, sign = \"-\") { var arr = str.split(sign); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year, month, date)); } formDate(str); //Wed Dec 15 2021 00:00:00 GMT+0800 (中国标准时间) 获取时间戳 var t = new Date() console.log(t.getTime());//时间戳是1970年1月1日0时0分0秒到现在的毫秒 定时器 var time1 = new Date(); var t1 = time1.getTime(); var time2 = new Date(2022, 0, 1); var t2 = time2.getTime(); var t = Math.floor(Math.abs(t1 - t2) / 1000); //现在距离2020还有多少秒 var date = Math.floor(t / (60 * 60 * 24)); //日 var modul = t % (60 * 60 * 24); //求余(用距离2020剩下的秒来求余天，剩下的就是时) var h = Math.floor(modul / (60 * 60)); //时 modul = t % (60 * 60); var m = Math.floor(modul / 60); //分 modul = t % 60; var s = Math.floor(modul); //秒 console.log(date + \"日\" + h + \"时\" + m + \"分\" + s + \"秒\"); 计时器 setInterval(function () { var time1 = new Date(); var t1 = time1.getTime(); var time2 = new Date(2021, 12, 12); var t2 = time2.getTime(); var t = Math.floor(Math.abs(t1 - t2) / 1000); //现在距离2020还有多少秒 var date = Math.floor(t / (60 * 60 * 24)); //日 var modul = t % (60 * 60 * 24); //求余(用距离2020剩下的秒来求余天，剩下的就是时) var h = Math.floor(modul / (60 * 60)); //时 modul = t % (60 * 60); var m = Math.floor(modul / 60); //分 modul = t % 60; var s = Math.floor(modul); //秒 var body = document.querySelector(\"body\"); body.innerHTML = date + \"日\" + h + \"时\" + m + \"分\" + s + \"秒\"; }, 1000); 获取B站的所有标签符 //第一种 console.log( [ ...new Set( [...document.querySelectorAll(\"*\")].map((item) => item.nodeName) ), ].length ); //第二种 console.log(new Set($$(\"*\").map(e => e.tagName))); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:32:44 "},"16正则表达式.html":{"url":"16正则表达式.html","title":"16正则表达式","keywords":"","body":" 一、正则表达式字符匹配 创建正则表达式 正则表达式方法 1)test （正则方法）🏳‍🌈 在hello外面new一个数 在hello里面new一个数 2. search （字符串方法） 3. match(字符串方法) 4. exec(正则方法) 🏳‍🌈 5. replace（字符串方法） 案例 修饰符 1. 加的【i】 2 )加的【g】🐱‍👤 3. 加的【m】 纵向模糊匹配🚓 1、字符组 1. 范围表示 2. 排除字符组 3. 字符组简写 大法中🐱‍👤💨 横向模糊匹配 1、量词 案例 2、贪婪匹配和惰性匹配 多选分支 案例 二、正则表达式位置匹配 位置 位置匹配 1、锚字符，匹配位置的字符。 2、^和$ 3、\\b和\\B 4、先行断言和后行断言 案例 1、不匹配任何东西 2、数字的千位分隔符表示法 3、替换法 4、验证密码 三、正则表达式括号作用 分组和分支结构 一、分组和分支结构 二、引用分组 三、反向引用 1、括号嵌套的时候，以左括号为准 2、\\10表示什么呢 3、引用不存在的分组 四、非捕获分组 正则表达式 一、正则表达式字符匹配 创建正则表达式 var reg = /hello/ //字面量创建 console.log(reg); var reg = new RegExp(hello)//构造函数创建 正则表达式方法 1)test （正则方法）🏳‍🌈 正则 在前面 字符串 在后面 检测出该字符串是否符合正则表达式 var str = \"hello\" //原生 var reg = /hello/ console.log(reg.test(str)); //true 在hello外面new一个数 var str = \"hello我是在外面new一个\" //在外面就可以 var reg = /hello/ console.log(reg.test(str)); //true 在hello里面new一个数 var str = \"hell我是在里new一个o\" //在里面就不可以了 var reg = /hello/ console.log(reg.test(str)); //false 2) search （字符串方法） 字符串 在前面正则 在后面 检索 出字符串符合正则的字符的索引值 var str = \"hello world\" var reg = /world/ console.log(str.search(reg));//6 3) match(字符串方法) 字符串 在前面正则 在后面 在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null var str = \"hello world\" var reg = /l/ console.log(str.match(reg)); //[\"l\", index: 2, input: \"hello world\", groups: undefined] var str = \"hello world\" var reg = /p/ //p不在字符串中就会返回null console.log(str.match(reg));//null 4) exec(正则方法) 🏳‍🌈 正则 在前面 字符串 在后面 在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null var str = \"hello world\" var reg = /l/ console.log(reg.exec(str)); //[\"l\", index: 2, input: \"hello world\", groups: undefined] 5) replace（字符串方法） 字符串 在前面正则 在后面 查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容 var str = \"hello world\" var reg = /o/ console.log(str.replace(reg, \"a\")); //hella world 加个g就可以替换后面的o咯 var str = \"hello world\" var reg = /o/g //这里加个g就可以替换后面的o咯 console.log(str.replace(reg, \"a\")); //hella warld 案例 打印出hello world里面每一个l的索引值 var str = \"hello world\" var reg = \"l\" var arr = str.split(\"\")//转换数组 // console.log([...new Set(arr)]);//这里是可以去重 //[\"h\", \"e\", \"l\", \"o\", \" \", \"w\", \"r\", \"d\"] arr.forEach(function (item, idx) { if (item === reg) { console.log(idx); //2,3,9 } }) 修饰符 1) 加的【i】 var str = \"hello world\" var reg = /HELLO/ console.log(reg.test(str));//false i可以让正则对大小写不敏感 var str = \"hello world\" var reg = /HELLO/i console.log(reg.test(str));//true 2 )加的【g】🐱‍👤 g可以让正则匹配 所有 的字符串 var str = \"hello wold\" var reg = /l/g console.log(str.match(reg));//(3) [\"l\", \"l\", \"l\"] 3) 加的【m】 m可以匹配换行注意： 只有当目标字符串 含有\\n 【\\n是换行哦】 而且正则表达式 中含有^或$的时候，/m修饰符才有作用 var str = \"a0b\\na1b\\na2b\\na3b\\na4b\" var reg = /^a[1-3]b$/m console.log(reg.test(str));//true 纵向模糊匹配🚓 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。 let str = \"a1b a2b a3b a4b a5b\" let reg = /a[12345]b/g console.log(str.match(reg))//[\"a1b\", \"a2b\", \"a3b\"] 1、字符组 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。 1) 范围表示 如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。 //匹配a20 a30 a40 let str = \"a10 a20 a30 a40 a50\" let reg = /a[2-4]0/g console.log(str.match(reg)) //匹配b c d let str = \"a b c d e\" let reg = /[b-d]/g console.log(str.match(reg)) //匹配所有的数字 let str = \"1 2 3 4 5\" let reg = /[0-9]/g console.log(str.match(reg)) //匹配所有的大小写英文字母 let str = \"a b c d e A B C D\" let reg = /[A-Za-z]/g console.log(str.match(reg)) //匹配 a - z let str = \"a - z\" let reg = /[a\\\\-z]/g 或 /[az-]/g 或 /[-az]/g console.log(str.match(reg)) 练习中💨 数字匹配 var str = \"5.5\" var reg = /[1-9]/ console.log(reg.test(str));//true var str = \"1000\" var reg = /[1-9]/ console.log(reg.test(str));//true var str = \"55000\" var reg = /[1-9]/ console.log(reg.test(str));//true 英文匹配 var str = \"d\" var reg = /[a-z]/ console.log(reg.test(str));//true // 英文大小写 var str = \"A\" var reg = /[A-Ca-c]/ console.log(reg.test(str));//true var str = \"D\" var reg = /[A-Ca-c]/ console.log(reg.test(str));//false 2) 排除字符组 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是\"a\"、\"b\"、\"c\"。 //匹配除了abc以外的英文字母 let str = \"d e f g h i j k\" let reg = /[^abc]/g console.log(str.match(reg)) 练习中💨 取反 var str = \"d\" var reg = /[^abc]/ console.log(reg.test(str));//true var str = \"a\" var reg = /[^abc]/ console.log(reg.test(str));//false var str = \"c\" var reg = /[^abc]/ console.log(reg.test(str));//true 3) 字符组简写 \\\\d就是[0-9]。表示是一位数字。 \\\\D就是[^0-9]。表示除数字外的任意字符。 \\\\w就是[0-9a-zA-Z_]。表示数字、大小写字母和下划线。 \\\\W是[^0-9a-zA-Z_]。非单词字符。 \\\\s是[\\\\t\\\\v\\\\n\\\\r\\\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 \\\\S是[^\\\\t\\\\v\\\\n\\\\r\\\\f]。 非空白符。 .就是[^\\\\n\\\\r\\\\u2028\\\\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。 //匹配所有的数字 let str = \"1 2 3\" let reg = /\\\\d/g console.log(str.match(reg)) //匹配所有的英文字母和下划线 let str = \"a b c _\" let reg = /\\\\w/g console.log(str.match(reg)) //匹配所有特殊符号(表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符) let str = \"a b c _\" let reg = /\\\\s/g console.log(str.match(reg)) //通配符（表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外） let str = \"a b c _\" let reg = /./g console.log(str.match(reg)) 大法中🐱‍👤💨 // 数字匹配简写 // 取反 // \\d就是[0 - 9]。表示是一位数字。💖 // \\D就是[^ 0 - 9]。表示除数字外的任意字符。 var str = \"s\" var reg = /\\D/ console.log(reg.test(str));//true var str = \"g\" var reg = /\\D/ console.log(reg.test(str));//true var str = \"H\" var reg = /\\a/ console.log(reg.test(str));//false var str = \"j\" var reg = /\\a/ console.log(reg.test(str));//false // 表示数字、大小写字母和下划线。\\w就是[0-9a-zA-Z_]💖 var str = \"-\" var reg = /\\w/ console.log(reg.test(str));//false var str = \"-j\" var reg = /\\w/ console.log(reg.test(str));//true var str = \"1\" var reg = /\\w/ console.log(reg.test(str));//true var str = \"_\" var reg = /\\w/ console.log(reg.test(str));//true //\\s是[\\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 // 大写S就取反 var str = \"\\n\" var reg = /\\s/ console.log(reg.test(str));//true var str = \"$\" var reg = /\\s/ console.log(reg.test(str));//false var str = \"$\" var reg = /\\S/ console.log(reg.test(str));//true // 通用 var str = \"j\" var reg = /./ console.log(reg.test(str));//true //无敌什么都能匹配 var str = \"\\n\" var reg = /[\\w\\w]/ console.log(reg.test(str));//false var str = \"^%\" var reg = /[\\w\\D]/ console.log(reg.test(str));//true // 这种什么都匹配不了 var str = \"$\" var reg = /[^\\d\\D]/ console.log(reg.test(str));//false // 特殊用法💨 var str = \"1\" var reg = /[\\w\\w]/ //匹配所有字符 console.log(reg.test(str));//true var reg = /[^\\w\\w]/ //不匹配任何字符 console.log(reg.test(str));//false //匹配a20 a30 a40 var str = \"a10 a20 a30 a40 a50\" var reg = /a[2-4]0/g console.log(reg.test(reg))//false console.log(str.match(reg))//[\"a20\", \"a30\", \"a40\"] //匹配b c d var str = \"a b c d e\" var reg = /[b-d]/g console.log(reg.test(reg))//true console.log(str.match(reg))// [\"b\", \"c\", \"d\"] //匹配所有的数字 var str = \"1 2 3 4 5\" var reg = /[0-9]/g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"1\", \"2\", \"3\", \"4\", \"5\"] //匹配所有的大小写英文字母 var str = \"a b c d e A B C D\" var reg = /[A-Za-z]/g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"a\", \"b\", \"c\", \"d\", \"e\", \"A\", \"B\", \"C\", \"D\"] //匹配 a - z var str = \"a - z\" var reg = /[a\\\\-z]/g //或 /[az-]/g 或 / [-az] / g console.log(reg.test(reg))//true console.log(str.match(reg))//[\"a\", \"z\"] 横向模糊匹配 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。 //匹配abbc abbbc let str = \"abc abbc abbbc\" let reg = /ab{2,3}c/g console.log(str.match(reg)) 1、量词 量词也称重复。 {m,} 表示至少出现m次。 {m} 等价于{m,m}，表示出现m次。 ? 等价于{0,1}，表示出现或者不出现。 + 等价于{1,}，表示出现至少一次。 * 等价于{0,}，表示出现任意次，有可能不出现。 //匹配出现0次或1次 let str = \"ac abc abbc abbbc\" let reg = /ab{0,1}c/g let reg= /ab?c/g console.log(str.match(reg)) //[\"ac\", \"abc\"] //匹配出现至少一次 let str = \"ac abc abbc abbbc\" let reg = /ab{1,}c/g let reg= /ab+c/g console.log(str.match(reg)) //[\"abc\", \"abbc\", \"abbbc\"] //匹配出现任意次数 let str = \"ac abc abbc abbbc\" let reg= /ab*c/g console.log(str.match(reg)) // [\"ac\", \"abc\", \"abbc\", \"abbbc\"] 练习中💨 var str = \"heo helo hello helllo hellllo\" var reg = /hel{1,3}o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\"] var str = \"heo helo hello helllo hellllo\" var reg = /hel{1,}o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\", \"hellllo\"] var str = \"heo helo hello helllo hellllo\" var reg = /hel{2}o/g console.log(str.match(reg));//[\"hello\"] //【?】0次或者1次 var str = \"heo helo hello helllo hellllo\" var reg = /hel?o/g console.log(str.match(reg));//[\"heo\", \"helo\"] //【+】至少出现了1次 var str = \"heo helo hello helllo hellllo\" var reg = /hel+o/g console.log(str.match(reg));//[\"helo\", \"hello\", \"helllo\", \"hellllo\"] //【*】任意次数 var str = \"heo helo hello helllo hellllo\" var reg = /hel*o/g console.log(str.match(reg));//[\"heo\", \"helo\", \"hello\", \"helllo\", \"hellllo\"] 案例 1、匹配我们的手机号码（松散匹配） 1[3-9]后面9位数字 var str = \"15866393005\"; var reg = /^1[3-9]\\d{9}$/ console.log(reg.test(str)); //true 用判断语句 var str = \"15866393005\"; var reg = /^1[3-9]\\d{9}$/ var arr = reg.exec(str) if (arr === null || arr === \"\") { alert(\"没匹配!\") } else { alert(arr[0]) //15866393005 } 2、qq邮箱 var str = \"15866393@qq.com\" var reg = /^[1-9][0-9]{4,10}@qq.com$/ console.log(reg.test(str));//true 3、24小时正则式 // 23:59 // 00:00 // 09 // 19 // 23 var str = \"24:00\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//false var str = \"00:00\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true var str = \"23:59\" var reg = /^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true 2、贪婪匹配和惰性匹配 量词默认都是贪婪匹配的，即有多少个就匹配多少个，越多越好。 let str = \"123 1234 12345 123456\" let reg = /\\\\d{2,5}/g console.log(str.match(reg))//[\"123\", \"1234\", \"12345\", \"12345\"] 而有时候我们可能需要的是惰性匹配，即尽可能少的匹配。 //其中/\\\\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。 let str= \"123 1234 12345 123456\"; let reg= /\\\\d{2,5}?/g; console.log( str.match(reg) )//[\"12\", \"12\", \"34\", \"12\", \"34\", \"12\", \"34\", \"56\"] 通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下 {m,n}? {m,}? ?? +? *? 多选分支 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。 let str = \"hello world\" let reg = /hello|world/g console.log(str.match(reg))//[hello,world] 但是多选分支默认是惰性的 let str = \"good goodbye\" let reg = /good|goodbye/g console.log(str.match(reg))//['good', 'good'] 可以这么写 let str = \"good goodbye\" let reg = /goodbye|good/g//把goodbye放前面就可以准确的获取到goodbye console.log(str.match(reg))//['good', 'goodbye'] let str = \"good goodbye\" let reg = /^good|goodbye$/g//^$是以什么为开头，什么味结束 console.log(str.match(reg))//['good', 'goodbye'] 案例 1、匹配16进制颜色值 #ffbbad #Fc01DF #FFF #ffE var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g; var string = \"#ffbbad #Fc01DF #FFF #ffE\"; console.log( string.match(regex) ); // => [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"] 2、匹配24小时制时间 23:59 02:07 var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/; console.log( regex.test(\"23:59\") ); console.log( regex.test(\"02:07\") ); // => true // => true 3、匹配日期,yyyy-mm-dd格式 var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; console.log( regex.test(\"2017-06-10\") ); // => true 二、正则表达式位置匹配 位置 位置指的是相邻字符之间的位置。 //可以把位置理解成每一个字符左右两边的空字符 let str = \"hello\" let str = \"\"+\"h\"+\"e\"+\"l\"+\"l\"+\"o\"+\"\" 位置匹配 1、锚字符，匹配位置的字符。 ^ //（脱字符）匹配开头，在多行匹配中匹配行开头。 $ //（美元符号）匹配结尾，在多行匹配中匹配行结尾。 \\\\b //\\\\w和\\\\W之间的位置，也包括\\\\w和^之间的位置，也包括\\\\w和$之间的位置。 \\\\B //\\\\w与\\\\w、\\\\W与\\\\W、^与\\\\W，\\\\W与$之间的位置 (?=p) //正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 (?!p) //负向先行断言。(?!p)，就是(?=p)的反面意思 (? 练习中💨 //【^】（脱字符）匹配开头，在多行匹配中匹配行开头。 var str = \"hello heooo llo\" var reg = /^he/g console.log(str.match(reg));//[\"he\"] var str = \"hello heooo llo\" var reg = /he$/g console.log(str.match(reg));//null // 【$】（美元符号）匹配结尾，在多行匹配中匹配行结尾。 var str = \"hello heooo llo\" var reg = /llo$/g console.log(str.match(reg));//[\"llo\"] var str = \"hello heooo llo\" var reg = /^llo/g console.log(str.match(reg));//null // 【\\\\b】 \\\\w和\\\\W之间的位置，也包括\\\\w和^之间的位置，也包括\\\\w和$之间的位置。 var str = \"h e l l o\" var reg = /\\b/g console.log(str.replace(reg, \"#\"));//#h# #e# #l# #l# #o# // 【\\\\B】 \\\\w与\\\\w、\\\\W与\\\\W、^与\\\\W，\\\\W与$之间的位置 var str = \"hello\" var reg = /\\B/g console.log(str.replace(reg, \"#\"));//h#e#l#l#o var str = \"h e l l o\" var reg = /\\B/g console.log(str.replace(reg, \"#\"));//h e l l o 💨🐱‍👤 // 【(?= p)】 正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 var str1 = \"hello\" var reg1 = /(?=l)/g console.log(str1.replace(reg1, \"#\"));//he#l#lo // 【(? !p)】 负向先行断言。(?!p)，就是(?=p)的反面意思 var str2 = \"hello\" var reg2 = /(?!l)/g console.log(str2.replace(reg2, \"#\"));//#h#ell#o# // 【(? 案例 // 12345678 变成 12,345,678 var str = \"12345678\" var reg = /(?!^)(?=(\\d{3})+$)/g console.log(str.replace(reg, \",\"));//12,345,678 相识-半 var str = \"123456789\" var reg = /(? 2、^和$ ^（脱字符）匹配开头，在多行匹配中匹配行开头。 $（美元符号）匹配结尾，在多行匹配中匹配行结尾。 let str = \"hello\" let reg = /^|$/g console.log(str.replace(reg,\"#\"))//#hello# 要注意多行匹配模式时，二者是行的概念 let str = \"i\\\\nlove\\\\njavascript\" let reg = /^|$/g console.log(str.replace(reg,\"#\")) // #i // love // javascript# //需要加修饰符m let str = \"i\\\\nlove\\\\njavascript\"; let reg = /^|$/gm; console.log(str.replace(reg, \"#\")); // #i# // #love# // #javascript# 3、\\b和\\B \\b是单词边界，具体就是\\w和\\W之间的位置，也包括\\w和^之间的位置，也包括\\w和$之间的位置。 let str = \"[JS] Lesson_01.mp4\"; let reg = /\\\\b/g; console.log(str.replace(reg, \"#\"));//[#JS#] #Lesson_01#.#mp4# \\B就是\\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\\b，剩下的都是\\B的。 具体说来就是\\w与\\w、\\W与\\W、^与\\W，\\W与$之间的位置。 let str = \"[JS] Lesson_01.mp4\"; let reg = /\\\\B/g; console.log(str.replace(reg, \"#\"));//#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4 4、先行断言和后行断言 先行断言和后行断言也被称为环视。 正向先行断言。(?=p)，其中p是一个子模式，即p前面的位置。 let str = \"hello\"; let reg = /(?=l)/g; console.log(str.replace(reg, \"#\"));//he#l#lo 负向先行断言。(?!p)，就是(?=p)的反面意思 let str = \"hello\"; let reg = /(?!l)/g; console.log(str.replace(reg, \"#\"));//#h#ell#o# 正向后行断言。(?，即p后面的位置。 let str = \"hello\"; let reg = /(? 负向后行断言。(?，就是(?的反面意思 let str = \"hello\"; let reg = /(? 案例 1、不匹配任何东西 let str = \"hello\"; let reg = /.^/g; console.log(str.match(reg))//null 2、数字的千位分隔符表示法 把\"12345678\"，变成\"12,345,678\"。 let str = \"123456789\"; let reg = /(?!^)(?=(\\\\d{3})+$)/g; console.log(str.replace(reg,\",\"))//123,456,789 3、替换法 把\"12345678 123456789\"替换成\"12,345,678 123,456,789\" let str = \"12345678 123456789\"; let reg = /\\\\B(?=(\\\\d{3})+\\\\b)/g; console.log(str.replace(reg,\",\"))//12,345,678 123,456,789 4、验证密码 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符。 同时包含数字和小写字母 同时包含数字和大写字母 同时包含小写字母和大写字母 同时包含数字、小写字母和大写字母 let str = \"123abcdef112\"; let reg = /((?=.*\\\\d)(?=.*[a-z])|(?=.*\\\\d)(?=.*[A-Z])|(?=.*[A-Z])(?=.*[a-z]))^[0-9A-Za-z]{6,12}$/g; console.log(reg.test(str))//true 另外一种解法 不能是纯数字 不能是纯小写 不能是纯大写 let str = \"AAAAAA\"; let reg = /(?!^\\\\d{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/; console.log(reg.test(str))//false 三、正则表达式括号作用 分组和分支结构 一、分组和分支结构 分组 var regex = /(ab)+/g; var string = \"ababa abbb ababab\"; console.log( string.match(regex) ); // => [\"abab\", \"ab\", \"ababab\"] 分支结构 var regex = /^I love (JavaScript|Regular Expression)$/; console.log( regex.test(\"I love JavaScript\") ); console.log( regex.test(\"I love Regular Expression\") ); // => true // => true 二、引用分组 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。 提取数据 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(reg.test(str))//任意的正则操作,以下都可以 // console.log(reg.exec(str)) // console.log(str.match(reg)) //通过构造函数的全局属性$1至$9来获取 console.log(RegExp.$1)//2021 console.log(RegExp.$2)//2021 console.log(RegExp.$3)//2021 替换数据 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(str.replace(reg,\"$2/$3/$1\"))//10/06/2021 //等价于 let str = \"2021-10-06\"; let reg = /(\\\\d{4})-(\\\\d{2})-(\\\\d{2})/; console.log(str.replace(reg,()=>{ return RegExp.$2 + \"/\" + RegExp.$3 + \"/\" + RegExp.$1 })) 三、反向引用 除了使用相应API来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。 //\\\\1的意思是引用前面的(-|\\\\/|\\\\.)分组 let reg = /\\\\d{4}(-|\\\\/|\\\\.)\\\\d{2}\\\\1\\\\d{2}/; let str1 = \"2021-10-06\"; let str2 = \"2021/10/06\"; let str3 = \"2021.10.06\"; let str4 = \"2021-10/06\"; console.log(reg.test(str1))//true console.log(reg.test(str2))//true console.log(reg.test(str3))//true console.log(reg.test(str4))//false 1、括号嵌套的时候，以左括号为准 let reg = /^((\\\\d)(\\\\d(\\\\d)))\\\\1\\\\2\\\\3\\\\4$/; let str1 = \"1231231233\"; console.log(reg.test(str1))//true console.log(RegExp.$1)//123 console.log(RegExp.$2)//1 console.log(RegExp.$3)//23 console.log(RegExp.$4)//3 2、\\10表示什么呢 \\10是表示第10个分组，不是表示\\1和0 var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \\\\10+/; var string = \"123456789# ######\" console.log( regex.test(string) ); // => true 3、引用不存在的分组 因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。 var regex = /\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9/; console.log( regex.test(\"\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9\") ); console.log( \"\\\\1\\\\2\\\\3\\\\4\\\\5\\\\6\\\\7\\\\8\\\\9\".split(\"\") ); 四、非捕获分组 如果只想要括号最原始的功能，但不会引用它，即，既不在API里引用，也不在正则里反向引用。此时可以使用非捕获分组(?:p)。 var regex = /(?:ab)+/g; var string = \"ababa abbb ababab\"; console.log( string.match(regex) ); // => [\"abab\", \"ab\", \"ababab\"] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:33:03 "},"17异常错误对象.html":{"url":"17异常错误对象.html","title":"17异常错误对象","keywords":"","body":" 1、常见的错误类型 2、错误捕捉语句 3、抛出一个异常 4、最终语句 异常错误对象 1、常见的错误类型 console.log(num); //这种就直接报错红色 //RangeError 已发生超出数字范围的错误 var num = 1; try { num.toPrecision(500); // 数无法拥有 500 个有效数 } catch(err) { } //ReferenceError 已发生非法引用✨ var x; try { x = y + 1; // y 无法被引用（使用） } catch(err) { } //SyntaxError 已发生语法错误✨ try { eval(\"alert('Hello)\"); // 缺少 ' 会产生错误 } catch(err) { } //TypeError 已发生类型错误✨ var num = 1; try { num.toUpperCase(); // 您无法将数字转换为大写 } catch(err) { } //URIError 在 encodeURI() 中已发生的错误 try { decodeURI(\"%%%\"); // 您无法对这些百分号进行 URI 编码 } catch(err) { } 2、错误捕捉语句 //try 语句允许您定义一个代码块，以便在执行时检测错误 //catch 语句允许你定义一个要执行的代码块，如果 try 代码块中发生错误 //e是 Error 错误对象 name 错误的名字 message 错误的信息 try{ }catch(e){ } 3、抛出一个异常 //throw允许您创建自定义错误 throw throw \"Too big\"; // 抛出文本 throw 500; //抛出数字 //案例 var a = 1; try{ console.log(b); }catch(e){ if(e.name === \"ReferenceError\"){ throw \"你是不是没有定义该变量?\" throw new Error(\"是否没有定义变量\") } } 4、最终语句 //finally允许您在 try 和 catch 之后执行代码，无论结果 finally //案例 var a = 1; try{ console.log(b); }catch(e){ console.log(e) } finally{ console.log(\"无论对错，都会执行这里的语句\") } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:33:10 "},"18BOM浏览器对象模型.html":{"url":"18BOM浏览器对象模型.html","title":"18BOM浏览器对象模型","keywords":"","body":" 1、计时器 1)无限计时器 2)一次性计时器 3)清空无限计时器 4)清空一次性计时器 2、页面栈对象和历史对象 3、本地缓存 1)存储和获取 2)删除单个 3)清空所有 案例 BOM 浏览器对象模型 1、计时器 1)无限计时器 let i = 0 setInterval(()=>{ i++ console.log(i) },1000)//这里毫秒为单位 // 无限次计时器【简写】 setInterval(function () { console.log(123);// }, 2000) 2)一次性计时器 let i = 0 function timeHandler() { setTimeout(() => { i++ console.log(i) timeHandler() }, 1000);//这里毫秒为单位 } timeHandler() // 一次性计时器 【简写】 setTimeout(function () { console.log(123); }, 2000)//这里毫秒为单位 案例 // 使用一次性计时器，实现无限次计时器的效果 function fn() { setTimeout(function () { console.log(\"这是一次性计时器哦！\"); fn()//递归 }, 1000) } fn() //自己执行自己 function fn() { fn()//递归 } //回调是把别的函数当成参数执行 function fn(f) { f() } 3)清空无限计时器 let i = 0 let timer = setInterval(()=>{ i++ console.log(i) },1000) clearInterval(timer) 4)清空一次性计时器 let timer = setTimeout(() => { i++; console.log(i); timeHandler(); }, 1000); clearTimeout(timer); 案例 按钮 //3)清空无限计时器 var timeHandler = setInterval(function () { console.log(123); }, 1000) var btn = document.querySelector(\"button\") btn.onclick = function () { clearInterval(timeHandler) } 清空即开始 暂停 开始 var timeHandler var i = 0 function time() { timeHandler = setInterval(function () { console.log(++i); }, 1000) } //开始 var start = document.querySelector(\".start\") start.onclick = function () { clearInterval(timeHandler) time() } //暂停 var stop = document.querySelector(\".stop\") stop.onclick = function () { clearInterval(timeHandler) i = 0 } 2、页面栈对象和历史对象 跳到a页面 let btn = document.querySelector(\"button\") btn.onclick = ()=>{ location.href = \"a.html\"//location是页面栈对象，记录了跳转页面的信息 } 返回首页 let btn = document.querySelector(\"button\") btn.onclick = ()=>{ // history.back() history.go(-1)//history是历史记录对象，记录了每一次跳转的信息 } 3、本地缓存 前端： cookie; localStorage; sessionStorage; 后端： session; session；后端才有使用，跟前端没有关系。 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage;本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage;本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 微信小程序 1、有同步异步 2、不限于只存储字符串，可以直接存对象 1)存储和获取 //默认只能存字符串 localStorage.setItem(\"name\",\"小明\") console.log(localStorage.getItem(\"name\")) //存数组需要先转json字符串 localStorage.setItem(\"obj\",JSON.stringify({name:\"小明\"})) console.log(JSON.parse(localStorage.getItem(\"obj\"))) 2)删除单个 localStorage.removeItem() 3)清空所有 localStorage.clear() 案例 //存 localStorage.setItem(\"name\", \"小明\") //取 console.log(localStorage.getItem(\"name\")); localStorage.setItem(\"bool\", true) console.log(localStorage.getItem(\"bool\")); localStorage.setItem(\"arr\", JSON.stringify([{ name: \"小明\", age: 18 }])) console.log(JSON.parse(localStorage.setItem(\"arr\"))); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:33:35 "},"19DOM文档对象模型.html":{"url":"19DOM文档对象模型.html","title":"19DOM文档对象模型","keywords":"","body":" 1、查找html元素 2、改变html元素 3、添加和删除元素 4、Element 对象 1)元素属性 2)元素位置和尺寸 3)节点导航 4)添加和删除元素 5、Attr 对象 6、Event 对象 1)事件句柄(Event Handlers) 2)鼠标 / 键盘属性 3）事件传播 4)event属性 5）标准Event方法 7、事件监听器 8、事件委托 案例 DOM文档对象模型 1、查找html元素 //通过元素 id 来查找元素 document.getElementById(id) //通过标签名来查找元素 document.getElementsByTagName(name) //通过类名来查找元素 document.getElementsByClassName(name) //根据选择器来查找元素 document.querySelector() //根据选择器来查找元素集合 document.querySelectorAll() 练习中💨 旧版【不建议使用，仅参考】 我是id // id属性 var div = document.getElementById(\"a\") console.log(div); // class属性 var div = document.getElementsByClassName(\"a\") console.log(div); // 标签属性 var div = document.getElementsByTagName(\"div\") console.log(div); 获取子元素的内容【不建议使用，仅参考】 我司a 我是b 我是c var a = document.getElementsByClassName(\"a\")[0] var b = a.getElementsByClassName(\"b\")[0] var c = b.getElementsByClassName(\"c\")[0] console.log(c.innerHTML);//我是c 新版 我是id // class属性 【获取一个】 var div = document.querySelector(\".a .b .c\") console.log(div); // div属性 【获取多个】 var div = document.querySelectorAll(\"div\") console.log(div); // class属性 【多个下层】 var div = document.querySelectorAll(\".a .b,.c\") console.log(div); 2、改变html元素 //改变元素的 inner HTML【包含标签】 element.innerHTML = new html content //获取内容【只更改内容】 innerText //获取HTML 元素的属性值 element.attributes //例 var a = document.querySelector(\"a\") a.attributes.href = \"www.sina.com\" //改变 HTML 元素的属性值 element.setAttribute(attribute, value) //例 var a = document.querySelector(\"a\") a.setAttribute(\"href\",\"www.sina.com\") //改变 HTML 元素的样式 element.style.property = new style 练习中💨 内容 //改变元素的 inner HTML【包含标签】 var div=document.querySelector(\".a\") div.innerHTML=\"innerHTML改变内容和标签\" 内容 //获取HTML 元素的属性值 var div=document.querySelector(\".a\") console.log(div.attributes); 3、添加和删除元素 //创建 HTML 元素 document.createElement(element) //删除 HTML 元素 document.removeChild(element) //删除元素 document.remove() //添加 HTML 元素 document.appendChild(element) //替换 HTML 元素 document.replaceChild(element) //写入 HTML 输出流(会覆盖文档) document.write(text) 练习中💨 var body = document.querySelector(\"body\")//获取body var div = document.createElement(\"div\")//创建div div.innerHTML = \"创建div\"//给div添加内容 body.appendChild(div)//插入到body里面 4、Element 对象 1)元素属性 //返回元素属性的 NamedNodeMap element.attributes //设置或返回元素的 class 属性 element.className //返回元素节点的指定属性值 element.getAttribute() //把指定属性设置或更改为指定值 element.setAttribute() //设置或返回元素的 id element.id //设置或返回元素的内容 element.innerHTML //返回元素的名称 element.nodeName //从元素中移除指定属性 element.removeAttribute() //设置或返回元素的 style 属性 element.style //返回元素的标签名 element.tagName 练习中💨 div //attributes:div属性 //elemen:获取的代码 var div=document.querySelector(\"div\") div //设置或返回元素的 class 属性 var div=document.querySelector(\"div\") console.log(div.className);//a //返回元素的名称 //获取B站的所有标签符 console.log( [ ...new Set( [...document.querySelectorAll(\"*\")].map((item) => item.nodeName) ), ].length ); div //更改颜色 //设置或返回元素的 style 属性 var body = document.querySelector(\"body\")//获取body div.style.color = \"red\" 2)元素位置和尺寸 //返回元素的可见高度【本质上的高】 element.clientHeight //返回元素的可见宽度【本质上的宽】 element.clientWidth //返回元素的高度【实际看到的高】 element.offsetHeight //返回元素的宽度【实际看到的宽】 element.offsetWidth //返回元素的水平偏移位置 element.offsetLeft //返回元素的垂直偏移位置 element.offsetTop 练习中💨 div //返回元素的可见高度【本质上的高】 var div=document.querySelector(\"div\") console.log(div.clientHeight);//100 div //返回元素的可见宽度【本质上的宽】 var div=document.querySelector(\"div\") console.log(div.clientWidth);//100 3)节点导航 //返回元素子节点的 NodeList element.childNodes //返回元素的首个子集 element.firstChild //返回元素的最后一个子元素 element.lastChild //返回元素的父节点 element.parentNode //返回当前节点的下一个节点 element.nextSibling //返回当前节点的上一个节点 element.previousSibling 练习中💨 a a a //返回元素子节点的 NodeList var div=document.querySelector(\".box\") console.log(div.childNodes);//[text, div.a, text, div.a, text, div.a, text] //text是空格 //返回元素的首个子集 var div=document.querySelector(\".box\") console.log(div.firstChild);//[#text] a1 a2 a3 //返回元素的父节点 var a1=document.querySelector(\".a1\") console.log(a1.parentNode);//div.box //返回当前节点的下一个节点 var a1=document.querySelector(\".a1\") console.log(a1.nextSibling); 4)添加和删除元素 //向元素添加新的子节点，作为最后一个子节点 element.appendChild() //在指定的已有的子节点之前插入新节点 element.insertBefore() //克隆元素 element.cloneNode() //从元素中移除子节点 element.removeChild() 练习中💨 a1 a2 a3 //在指定的已有的子节点之前插入新节点 var box = document.querySelector(\".dox\")//获取class box var x = document.createElement(\"div\")//创建div x.innerHTML = \"我是新的x\" //新建添加内容 box.insertBefore(x, box.childNodes[0]) //在box属性前面添加内容 //向元素添加新的子节点，作为最后一个子节点 var box = document.querySelector(\".dox\")//获取class box var x = document.createElement(\"div\")//创建div x.innerHTML = \"我是新的x\" //新建添加内容 box.appendChild(x) //在box属性后面添加内容 a1 a2 a3 //克隆元素【放进box后面去】 var box=document.querySelector(\".box\") //这里是获取box属性 var a1=document.querySelector(\".a1\") //先获取a1属性 var a1Clone=a1.cloneNode() //这里是克隆a1 a1Clone.innerHTML=\"我是克隆a1\"//新建添加内容 box.appendChild(a1Clone) //这里是把a1克隆放进box后面去 5、Attr 对象 //返回属性的名称 attr.name //设置或返回属性的值 attr.value 6、Event 对象 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态 1)事件句柄(Event Handlers) //图像的加载被中断 onabort //元素获得焦点(记) onfocus //元素失去焦点(记) onblur //域的内容被改变(记) onchange //当用户点击某个对象时调用的事件句柄(记) onclick //当用户双击某个对象时调用的事件句柄 ondblclick //在加载文档或图像时发生错误 onerror //某个键盘按键被按下 onkeydown //某个键盘按键被按下并松开 onkeypress //某个键盘按键被松开 onkeyup //一张页面或一幅图像完成加载(记) onload //鼠标按钮被按下 onmousedown //鼠标被移动 onmousemove //鼠标从某元素移开 onmouseout //鼠标移到某元素之上(记) onmouseover //鼠标按键被松开 onmouseup //重置按钮被点击 onreset //窗口或框架被重新调整大小 onresize //文本被选中 onselect //确认按钮被点击(记) onsubmit 练习中💨 内容 //当用户点击某个对象时调用的事件句柄(记) 【点击生产告示我们事件叫什么名字和值】 var a=doc.querySelector(\".a\") //获取a属性 a.onclick=function(event){ //这里是点击产生事件 //event：是形参 ——可任意字母 console.log(event); //打印事件 } //元素获得焦点(记) onfocus 【点击里面就会失去】 var a = document.querySelector(\".a\") //获取a属性 a.onfocus = function () {//获取焦点✨💖 console.log(\"点击里面获取\"); //打印 } //元素失去焦点(记) onblur 【点击外面就会失去】 a.onblur = function () {//失去焦点✨💖 console.log(\"点击外面失去\"); //打印 } 域的内容被改变(记) onchange //域的内容被改变(记) onchange var a=document.querySelector(\".a\") //获取a属性 a.onchange=function(){ console.log(123); //【这里就输入内容就会打印123哦】 } 广州 威武 深圳 //域的内容被改变 onchange var a = document.querySelector(\".city\") a.onchange = function (event) { console.log(event.target.value); //【获取选择的对象】 } //域的内容被改变(记) onchange var a=document.querySelector(\".a\") //获取a属性 a.onchange=function(evwnt){ console.log(event.target.value); //【输入内容就获取】 } //一张页面或一幅图像完成加载(记) // onload window.onload = function () { console.log(window); } 这里就用得最最多了💖✨🚀 账号 提交 //确认按钮被点击(记) // onsubmit var form = document.querySelector(\".form\") form.onsubmit = function () { console.log(123); } 2)鼠标 / 键盘属性 //返回当事件被触发时，鼠标指针的水平坐标 clientX //返回当事件被触发时，鼠标指针的垂直坐标 clientY 3）事件传播 1、事件捕获 【父级元素传播到触发的子级元素上（只有低版本Ie浏览器是捕获事件）】 2、事件派发发阶段 【传递过程】 3、事件冒泡 【触发的元素往父级元素传播】 4)event属性 //返回其事件监听器触发该事件的元素 currentTarget //返回触发此事件的元素（事件的目标节点） target //target和currentTarget的区别（重点必记） currentTarget 绑定该事件的元素 【跟冒泡事件】 target 触发了事件的元素 //返回事件传播的当前阶段 eventPhase 捕获阶段 1 事件派发 2 冒泡阶段 3 //返回事件生成的日期和时间(时间戳) timeStamp //返回当前 Event 对象表示的事件的名称 type 练习中💨💖✨ .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 比如：3 点击这元素就网上传播 比如：2 function eventHandler(e) { console.log(e.eventPhase);//返回事件传播的当前阶段eventPhase } target和currentTarget的区别（重点必记）✨✨✨ .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 比如：3 点击这元素就网上传播 比如：2 //target和currentTarget的区别（重点必记） function eventHandler(e) { console.log(e.currentTarget); //放定该事件的元素 【用这里点击是：2 3】💥 console.log(e.target); //触发了事件的元素 【用这里点击是：2】💥 } 5）标准Event方法 //通知浏览器不要执行与事件关联的默认动作(取消事件的默认行为) preventDefault() //不再派发事件 stopPropagation() 练习中preventDefault()💨 按钮 function sumbit(e) { e.preventDefault() //表单取消事件的默认行为【就是不让他消失永久显示在控制台上】 console.log(123); } 不再派发传播事件stopPropagation()💨 .a { width: 300px; height: 300px; background: #ff0;} .b { width: 100px; height: 100px; background: #0ff;} 我是a 我是b //不再派发事件💥 【】 function eventHandler(e) { e.stopPropagation() console.log(e.currentTarget); //2 } 7、事件监听器 //第一个参数是事件的类型（比如 \"click\" 或 \"mousedown\"） //第二个参数是当事件发生时我们需要调用的函数 //第三个参数是布尔值，指定使用事件冒泡还是事件捕获。此参数是可选的 element.addEventListener(event, function, useCapture) //removeEventListener()删除事件监听 element.removeEventListener(\"mousemove\", myFunction) 练习中💨 内容 var div = document.querySelector(\"div\") div.onclick = function () { console.log(\"我是事件监听器，第一种\"); } 内容 var div = document.querySelector(\"div\") div.addEventListener(\"click\", function () { console.log(\"我是事件监听器，第二种\"); }) 内容 var div = document.querySelector(\"div\") //获取元素 function eventHandler() {//这个函数只是打印123 console.log(123); } div.addEventListener(\"click\", eventHandler) //这里是触发函数【用这个控制台就打印123咯】 div.removeEventListener(\"click\", eventHandler) //这里是清除【用这个控制台上是什么也没有哦】 8、事件委托 目的：减少代码执行优化资源 原理：在目标集合元素的父级元素添加事件，点击目标集合元素时，因为事件冒泡的作用实现事件委托 let ul = document.querySelector(\"ul\") ul.onclick = function(event){ console.log(event.target) } ul.addEventListener(\"click\",function(event){ console.log(event.target) }) 练习中💨 1 2 3 var list = document.querySelectorAll(\"li\") list.forEach(function (item) { item.onclick = function () { console.log(123); //这里是每一个成员添加的点击事件 } }) 1 2 3 var list = document.querySelectorAll(\"li\") list.forEach(function (item) { item.onclick = function () { console.log(item.innerText); //这里是实现每一个成员点击打印相应值出来 } }) 1 2 3 var lu = document.querySelector(\"ul\") ul.onclick = function (event) { //event添加事件对象 console.log(event.target.innerText); //target事件委托 } 案例 使用下拉列表做城市联动效果，选择完国家，出现对应得城市 ==请选择国家== ==请选择城市== var arr = [ { countryName: \"中国\", cities: [ { cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"东莞\" }, ], }, { countryName: \"美国\", cities: [ { cityName: \"纽约\" }, { cityName: \"华盛顿\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cities: [ { cityName: \"大阪\" }, { cityName: \"东京\" }, { cityName: \"札幌\" }, ], }, ]; var country = document.querySelector(\".country\"); //获取country var city = document.querySelector(\".city\"); //获取city //循环迭代国家 arr.forEach(function (item) { var option = document.createElement(\"option\"); //创建一个空白的option标签 option.value = item.countryName; //设置value option.innerText = item.countryName; //设置内容 country.appendChild(option); //把option插入到country里面 }); // 每次国家切换的时候触发事件 country.onchange = function (event) { city.innerHTML = '==请选择城市==' var currentCountry = event.target.value; //获取到选中的国家 arr.forEach(function (item) { if (item.countryName === currentCountry) { //判断当前选中的国家和数据进行比较 item.cities.forEach(function (items) { console.log(items); var option = document.createElement(\"option\"); //创建一个空白的option标签 option.value = items.cityName; //设置value option.innerText = items.cityName; //设置内容 city.appendChild(option); //把option插入到country里面 }); } }); }; 这种自己了【不建议使用】 ==请选择国际== 中国 美国 日本 ==请选择国际== function setSecond(obj) { var val = obj.value; if (val == 'en') { var sec = document.getElementById('second'); sec.options[0] = new Option(\"洛杉矶\", \"one\"); sec.options[1] = new Option(\"纽约\", \"two\"); sec.options[2] = new Option(\"凤凰城\", \"three\"); } else if (val == 'jn') { var sec = document.getElementById('second'); sec.options[0] = new Option(\"东京\", \"one\"); sec.options[1] = new Option(\"北海市\", \"two\"); sec.options[2] = new Option(\"广岛\", \"three\"); } else { var sec = document.getElementById('second'); sec.options[0] = new Option(\"移动\", \"one\"); sec.options[1] = new Option(\"广州\", \"two\"); sec.options[2] = new Option(\"上海\", \"three\");//可设置循环配置，也可一个一个配置 } } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:33:53 "},"20json.html":{"url":"20json.html","title":"20json","keywords":"","body":" 一、创建json 二、json文本和json对象的转换 json JavaScript 对象表示法(JavaScript Object Notation)。轻量级的文本数据交换格式，用来描述数据对象。 json和xml相比的优势：比xml更易读，速度更快。 一、创建json //key值必须要加双引号 //不能出现相同的Key值 //json里不能有函数和undefined //不能注释 {\"key\":\"value\"} 练习中💨 { \"name\": \"小明\", \"obj\": {}, \"arr\": {} } 相互转换 var json = { \"name\": \"小明\", \"obj\": {}, \"arr\": {} } var str = JSON.stringify(json)//把json对象转成json字符串 var obj = JSON.parse(str)//把json字符串转成json对象 console.log(obj); 二、json文本和json对象的转换 //把json文本转换成js对象 eval() eval(\"(\"+text+\")\")//不安全，会解析js代码，并且不会判断数据是否符合json格式 JSON.parse() JSON.parse(text)//推荐 //把js对象转换成json文本 JSON.stringify() Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:34:02 "},"21Ajax.html":{"url":"21Ajax.html","title":"21Ajax","keywords":"","body":" 一、get请求 二、post请求 1. 请求报文和响应报文 2. http请求 三、get和post的区别 1. 状态码 2. 请求文本类型 3. token 四、axios 易用、简洁且高效的http库 axios中文文档 🚀 执行多个并发请求 拦截器 取消请求 Ajax async javascript xml，异步js和xml。Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。 一、get请求 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"GET\", \"\");//建立连接 xhr.send()//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; [!cogs] 获取列表接口 get请求 不用写参数 http://192.168.1.176:8080/getList var xhr if(window.XMLHttpRequest){//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 }else{//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"GET\",\"http://192.168.1.176:8080/getList\")//与服务器地址建立连接 xhr.send()//发送请求 xhr.onreadystatechange = function(){//等待服务器响应 if(xhr.readyState === 4 && xhr.status === 200){//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } 二、post请求 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"POST\", \"\");//建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 let data = { goodsId:\"b1195296679f482aa7d54d95ac2b4a94\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; [!cogs] 获取国家接口 post请求 传国家id http://192.168.1.176:8080/getCountry var xhr if(window.XMLHttpRequest){//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 }else{//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"POST\",\"http://192.168.1.176:8080/getCountry\")//与服务器地址建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 // 发给后端的参数 var data = { \"id\":\"001\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function(){//等待服务器响应 if(xhr.readyState === 4 && xhr.status === 200){//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } [warning]获取城市接口 post请求 传城市id http://192.168.1.176:8080/getCity var xhr if (window.XMLHttpRequest) {//判断浏览器是否支持XMLHttpRequest xhr = new XMLHttpRequest()//实例化xhr对象 } else {//做ie5\\ie6的兼容 xhr = new ActiveXObject(\"Microsoft.XMLHTTP\") } xhr.open(\"POST\", \"http://192.168.1.219:8080/getCity\")//与服务器地址建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 var data = { \"id\": \"001002\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//等待服务器响应 if (xhr.readyState === 4 && xhr.status === 200) {//判断服务器是否接收成功 console.log(JSON.parse(xhr.response))//服务器的响应 } } %accordion% 这是我们发送请求了 %accordion% %/accordion% %accordion% 请求三大块 %accordion% %/accordion% 1) 请求报文和响应报文 //发送的请求是有固定格式的 请求报文 请求行 请求地址、请求类型（请求方法）、状态代码 请求头 请求文本类型（json/form）、token（密钥） 请求体 发送的参数 响应报文 响应行 响应头 响应体 后端返回给前端的数据 请求报文 %accordion% 请求行%accordion% %/accordion% %accordion% 这是后端了 %accordion% %/accordion% %accordion% 请求头 %accordion% %/accordion% %accordion% 请求体【post】 %accordion% %/accordion% 响应报文 %accordion% 响应返回字符串 %accordion% %/accordion% %accordion% 预览返回对象✨ %accordion% %/accordion% 2) http请求 tcp/ip协议 协议 http:// https:// ftp:// 域名 192.168.1.180 ip地址 域名、服务器 端口号 :8080 基本地址 功能地址 /getCountry 三、get和post的区别 1、get请求的参数会在地址栏上显示，而post不会 2、get请求的数据长度有限制（取决于url的长度），而post理论上没有限制 3、get比post更加不安全，数据会直接显示在url上 4、get会发送数据的时候会把请求头、请求数据等一次性发送，而post会先发送请求头然后再发送请求数据 按照restful风格 get一般不发送参数，post发送 请求类型 get 一般用于获取数据，不传参数 在地址栏上面显示 不安全 参数有限制长度✨ post 一般用于获取指定，传参数 在请求体显示 不安全 在发送的时候，会发两次，第一次是发送options，第二次才是真正的post 理论上参数没有限制长度✨ 1) 状态码 状态代码 1xx 正在发送 2xx 发送成功 3xx 重定向 4xx 前端错误 404 地址错误 400 参数错误 5xx 后端错误 2) 请求文本类型 请求文本类型 content-type application/json json类型✨ application/x-www-form-urlencoded 表单类型✨ multipart/form-data 上传类型 %accordion% json数据类型 %accordion% %/accordion% 3) token token密钥 http的请求缺陷，无法判断状态 用途：判断用户是否在登陆 后端生成，发送给前端，前端在每一个请求的请求头都带上这个token，就可以让后端判断该用户是否在登陆状态 token是登陆的时候获取的，其他页面的请求一直带着 let xhr = new XMLHttpRequest();//实例化xhr对象 xhr.open(\"POST\", \"http://vt.ossjk.com/goods/getDetailGoodsInfo\");//建立连接 xhr.setRequestHeader(\"content-type\", \"application/json\");//设置请求头 xhr.setRequestHeader(\"jwtToken\", \"f720d5f720d5e261ee0b63a292e261f720d5e261ee0b0bc71fe437c963a292ee0b0bc71fe437c963a292\");//设置token秘钥 let data = { goodsId: \"001\" } xhr.send(JSON.stringify(data))//发送请求 xhr.onreadystatechange = function () {//响应请求 if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } }; %accordion% token秘钥 %accordion% %/accordion% 四、axios [info] 什么是 axios？ Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 //get请求 axios .get(\"\") .then((res)=>{ console.log(res) }) //post请求 let data = { goodsId:\"b1195296679f482aa7d54d95ac2b4a94\" } axios .post(\"\",data) .then((res)=>{ console.log(res) }) //request请求 axios .request({ url:\"\" }) .then((res)=>{ console.log(res) }) //request请求 let data = { goodsId: \"b1195296679f482aa7d54d95ac2b4a94\", }; axios .request({ url: \"\", method: \"POST\", data, }) .then((res) => { console.log(res); }); //并发请求 function getIndexInfo(){ return axios.get(\"\") } function getCategoryList(){ return axios.get(\"\") } axios .all([getIndexInfo(),getCategoryList()]) .then(axios.spread((res1,res2)=>{ console.log(res1) console.log(res2) })) 易用、简洁且高效的http库 axios中文文档 🚀 %accordion% 安装 %accordion% 安装 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 cdn: %/accordion% [!cogs] GET请求 get是没有参数了 axios .get(\"http://192.168.1.180:8080/getList\") .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); //仅参考 axios .get(\"http://192.168.1.180:8080/getList\",{ params:{ id:\"9527\" } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); [!cogs] post请求 post参数了 axios .post(\"http://192.168.1.180:8080/getCountry\", { id: \"001\" }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 %accordion% 执行多个并发请求 %accordion% function API_getList() { return axios.get(\"http://192.168.1.180:8080/getList\") } function API_getCountry(id) { return axios.post(\"http://192.168.1.180:8080/getCountry\", { id: id }) } axios.all([API_getList(), API_getCountry(\"001\")]) .then(axios.spread(function (res1, res2) { console.log(res1); console.log(res2); })) //执行多个并发请求 axios.request({ url: \"http://192.168.1.180:8080/getList\" }).then(function (res) { console.log(res); }) axios.request({ url: \"http://192.168.1.180:8080/getCountry\", method: \"POST\", data: { id: \"001\" } }).then(function (res) { console.log(res); }) %/accordion% 拦截器 %accordion% 拦截器 %accordion% 添加请求拦截器 // 添加请求拦截器 axios.interceptors.request.use( function (config) { // 在发送请求之前做些什么 config.headers.jwtToken = \"9527\"; return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); } ); // 添加响应拦截器 axios.interceptors.response.use( function (response) { // 对响应数据做点什么 if (response.data.code === 200) { alert(\"操作成功\"); } else { alert(\"操作失败\"); } return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); } ); axios.request({ url: \"http://192.168.1.180:8080/getList\" }).then(function (res) { console.log(res); }) axios.request({ url: \"http://192.168.1.180:8080/getCountry\", method: \"POST\", data: { id: \"001\" } }).then(function (res) { console.log(res); }) %/accordion% 取消请求 %accordion% 取消请求【1】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var source = axios.CancelToken.source(); var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: source.token, }) .then(function (res) { console.log(res); }); stopBtn.onclick = function () { source.cancel(\"取消请求1\"); }; %/accordion% %accordion% 取消请求【2】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var CancelToken = axios.CancelToken; var cancel; var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }), }) .then(function (res) { console.log(res); }); stopBtn.onclick = function () { cancel(\"取消请求2\"); }; %/accordion% %accordion% 取消请求【3】 %accordion% 111 var stopBtn = document.querySelector(\".stop\"); var CancelToken = axios.CancelToken; var http = axios.create({ baseURL: \"http://192.168.1.180:8080\", }); http .request({ url: \"getList\", cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancelFn(c) }), }) .then(function (res) { console.log(res); }); function cancelFn(c) { c(\"取消请求3\") } stopBtn.onclick = cancelFn %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:34:31 "},"22jQuery.html":{"url":"22jQuery.html","title":"22jQuery","keywords":"","body":" 一、引入jq 二、使用jq 三、文档就绪 四、$和jQuery 五、解决jq名称冲突 六、选择器 七、jq和js转换 八、jq效果 1、样式操控 2、隐藏/显示、淡入淡出、滑动 3、动画 九、jq html相关 1、文本操控 2、节点操控 3、尺寸 4、jq遍历 5、jq过滤 十、jq ajax 1、创建jq ajax 2、参数 3、案例 4、表单序列化 十一、练习 1、选项卡动画效果 2、jq插件 jQuery [info] JavaScript 函数库 处理浏览器不兼容性并简化 HTML DOM 操作、事件处理、动画和 Ajax。 一、引入jq //1.8以上的版本不再兼容ie8浏览器 \"> 二、使用jq $(\"选择器\") 三、文档就绪 $(function(){}) $(document).ready(function(){}); 四、$和jQuery $完全相等于jQuery 五、解决jq名称冲突 var jq=jQuery.noConflict() 六、选择器 //id选择器 var myElement = $(\"##id01\"); //class var myElements = $(\".intro\"); //标签名 var myElements = $(\"p\"); //当前元素 $(this) 七、jq和js转换 //使用jq选择器获取的后的元素都称为jq对象。 //jq对象只能使用jq的方法，无法使用js原生方法。 //jq转js console.log($(\"##app\")[0].innerText) //js转jq let app = document.querySelector(\"##app\") console.log($(app).html()) 八、jq效果 1、样式操控 //样式化 HTML 元素 myElement.css(\"font-size\",\"35px\"); //添加class myElement.addClass(\"\"); //删除class myElement.removeClass(\"\"); 2、隐藏/显示、淡入淡出、滑动 //隐藏 HTML 元素 myElement.hide(); //显示 HTML 元素 myElement.show(); //切换显示和隐藏 toggle() //淡入 fadeIn() //淡出 fadeOut() //淡入淡出切换 fadeToggle() //向下滑动 slideDown() //向上滑动 slideUp() //滑动切换 slideToggle() 3、动画 //创建动画 $(selector).animate({params},speed,callback); //停止动画 stop() //链式调用 //jq允许我们在相同的元素上运行多条 jQuery 命令 $(\".box\").css({\"width\":\"100px\"}).addClass(\"box2\") 九、jq html相关 1、文本操控 //获取和修改文本 myElement.text() //获取和修改html（包括标签） myElement.html() //获取和修改value值 myElement.val() //获取和修改属性 myElement.attr() //获取和修改该元素的索引值 .index() 2、节点操控 //添加 append() prepend() after() before() //删除被选元素 remove() //删除被选元素的子元素 empty() 3、尺寸 //设置或返回元素的宽度（不包括内边距、边框或外边距） width() height() //返回元素的宽度（包括内边距） innerWidth() innerHeight() //方法返回元素的宽度（包括内边距和边框） outerWidth() outerHeight() 4、jq遍历 //父元素 parents() //子元素 children() //找到被选元素 find() //被选元素的所有同胞元素 siblings() //下一个同胞元素 next() //被选元素的所有跟随的同胞元素 nextAll() //返回介于两个给定参数之间的所有跟随的同胞元素 nextUntil() //下一个同胞元素 prev() 5、jq过滤 //首个元素 first() //最后一个元素 last() //指定索引号的元素 eq() //匹配的元素会被返回 filter() //返回不匹配标准的所有元素 not() 十、jq ajax 1、创建jq ajax $.ajax({}) 2、参数 //发送请求的地址 url(必填) //发送类型，默认使用get type //请求成功后的回调函数 success //请求失败时调用此函数 error //发送到服务器的数据 data //设置请求超时时间（毫秒）。此设置将覆盖全局设置。 timeout //这个对象用于设置 Ajax 相关回调函数的上下文。(修改this指针) context $.ajax({ url: \"test.html\", context: document.body, success: function(){ $(this).addClass(\"done\"); }}); //发送信息至服务器时内容编码类型(默认值: \"application/x-www-form-urlencoded\") contentType //发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头 beforeSend(XHR) 3、案例 //发送登陆请求 var data = { \"name\":\"小明123\", \"pwd\":\"123456\" } $.ajax({ url:\"\", type:\"POST\", contentType:\"application/json\", data:JSON.stringify(data), success:function(res){ console.log(res) } }) //带token(令牌)的请求 $.ajax({ url: \"\", type: \"POST\", beforeSend: function(xhr) { xhr.setRequestHeader(\"token\", \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJhMjczYTMwM2QxZGI0ODRhODIyZGZjMWE2NzM2MGM3MiIsImlhdCI6MTU2Njg5OTQwNywic3ViIjoi5L2V5ZiJ5L-KMTIzIiwiaWQiOiI1MDk0MmJkMDk4MzI0MzM3YWE4MGJhZjk4MmRjYzI4ZiIsImV4cCI6MTU2Njg5OTc2N30.cuJkCUoHT5oCpyrlRW6JFjQV_q5URiQ2txoM7dqQSJQ\" ) }, success: function(res) { console.log(res) } }) 4、表单序列化 //将表单内容序列化成一个字符串 serialize() //将页面表单序列化成一个JSON结构的对象。注意不是JSON字符串 serializeArray() 十一、练习 1、选项卡动画效果 标题一 标题二 标题三 123 456 789 .tab{ width: 500px; height: 500px; border: 1px solid; } .tab-title{ width: 100%; height: 100px; border-bottom: 1px solid; } .tab-title div{ width: 100px; height: 100px; float: left; border-right: 1px solid; text-align: center; line-height: 100px; } .tab-title .on{ background:pink; } .tab-content div{ display: none; } .tab-content .on{ display: block; } $(\".tab .tab-title div\").click(function(){ $(this).addClass(\"on\").siblings().removeClass(\"on\") let idx = $(this).index() $(\".tab .tab-content div\").eq(idx).addClass(\"on\").siblings().removeClass(\"on\") }) 2、jq插件 //index.html Document .tab{ width: 500px; height: 500px; border: 1px solid; } .tab-title{ width: 100%; height: 100px; border-bottom: 1px solid; } .tab-title div{ width: 100px; height: 100px; float: left; border-right: 1px solid; text-align: center; line-height: 100px; } .tab-title .on{ background:pink; } .tab-content div{ display: none; } .tab-content .on{ display: block; } 标题一 标题二 标题三 123 456 789 \"> $(\".tab\").slides({ \"tab\":\".tab\", \"tabTitle\":\".tab-title\", \"tabContent\":\".tab-content\", \"autoPlay\":true, \"delaytime\":2000 }) //tab.js !function($){ $.fn.extend({ \"slides\":function(options){ let args = $.extend({ \"tab\":\".tab\", \"tabTitle\":\".tab-title\", \"tabContent\":\".tab-content\", \"autoPlay\":false, \"delaytime\":1000 },options) let that = $(`${args.tab}`)//tab let title = $(`${args.tabTitle}`).find(\"div\")//title let content = $(`${args.tabContent}`).find(\"div\")//content let idx = 0 function show(idx){ title.eq(idx).addClass(\"on\").siblings().removeClass(\"on\") content.eq(idx).addClass(\"on\").siblings().removeClass(\"on\") } function autoPlay(){ setInterval(function(){ idx>=title.length-1 ? idx=0 : idx++ show(idx) },args.delaytime) } title.click(function(){ idx = $(this).index() show(idx) }) if(args.autoPlay){ autoPlay() } } }) }(jQuery) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:34:46 "},"23函数进阶.html":{"url":"23函数进阶.html","title":"23函数进阶","keywords":"","body":" 一、变量提升给函数带来的问题 二、修改 this 指针 call、apply、bind 三、高阶函数 四、函数柯里化 1、创建函数柯里化 2、参数递归 五、节流函数和防抖函数 1、节流函数 2、防抖函数 3、优化版的防抖函数 函数进阶 一、变量提升给函数带来的问题 //报错，fn不是一个函数， //原因是var变量提升在全局作用域添加了一个fn为undefined， //所以undefined无法执行 fn(); var fn = function () { console.log(123); }; 二、修改 this 指针 //把函数fn的指针修改为指向对象obj function fn(num) { console.log(this); console.log(num); } let obj = { name: \"小明\", }; fn.call(obj, 123); call、apply、bind [warning]call\\apply\\bind有什么区别？ 面试题 1、call和apply是返回值，bind是返回函数 2、call和bind是选项式参数、apply是数组参数 var obj = { name:\"小明\" } function fn(a,b,c){ console.log(this) console.log(a) console.log(b) console.log(c) } // fn.call(obj,1,2,3) // fn.apply(obj,[1,2,3]) var f = fn.bind(obj,1,2,3) f() //把对象obj里面的fn2函数的指针修改为指向函数fn的this function fn(){ obj.fn2.call(this) } let obj = { fn2:function(){ console.log(this) } } fn() //案例 var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = function(){//虽然函数外层是obj2的作用域，但是因为函数默认指向了window，所以这里指的是window console.log(this.name)//小明 } a() } } } obj.obj2.fn() var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = ()=>{//箭头函数让this绑定在当前作用域下，无法修改this指针 console.log(this.name)//小绿 } a() } } } obj.obj2.fn() [!cogs] %accordion% 模块标题 %accordion% var obj = { name: \"娜美\" } function fn(a, b, c) { console.log(this); console.log(a); console.log(b); console.log(c); } fn.call(obj, 1, 2, 3) //返回值——是选择式参数 // fn.apply(obj,[1,2,3])//返回值——是选择式参数 // var f=fn.bind(obj,1,2,3)//返回函数——是数组参数 // f() %/accordion% %accordion% 模块标题 %accordion% var obj = { name: \"娜美\", fn1: function () { fn2.call(this) //修改他指针 }, } function fn2() { console.log(this); } obj.fn1() %/accordion% %accordion% 练习 %accordion% var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = function () { // console.log(this); console.log(this.name);//娜美 } a() }, }, } obj.obj2.fn() %/accordion% %accordion% 函数tkis %accordion% var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = () => { console.log(this.name); //大和 } a() }, }, } obj.obj2.fn() var name = \"娜美\" var obj = { name: \"妮可罗宾\", obj2: { name: \"大和\", fn: function () { var a = () => { console.log(this.name); //大和 } a.call() //就该这里 }, }, } obj.obj2.fn() %/accordion% 三、高阶函数 [info] 高阶函数 就是使函数抽象化，抽象就是隐藏更具体的实现细节，从更高的层次看待我们要解决的问题 // 给所有的数组添加一个自定义迭代方法 let arr = [1, 2, 3, 4, 5]; // arr.forEach(function(item,i){ // console.log(item) // }) Array.prototype.myForEach = function (f) { let arr = this; for (let i = 0; i [!cogs] %accordion% 高阶函数 %accordion% [warning] 函数myForEach 给所有的数组都添加一个myForEach的方法 Array.prototype.myForEach = function (f) { var arr = this for (var i = 0; i %/accordion% 四、函数柯里化 [info] 柯里化 函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。 目的是复用参数。 1、创建函数柯里化 function fn(a, b) { return a + b; } fn(1, 2); fn(1, 3); //复用参数 function fn(a) { return function (b) { console.log(a + b); }; } let f = fn(1); f(2); f(3); 2、参数递归 //参数固定 function curry(f, args = []) { //柯里化函数 return function () { let arr = [...args, ...arguments]; if (arr.length [!cogs] %accordion% 函数柯里化🚀 %accordion% 复用参数 function fn(a) { return function (b) { return a + b } } var f = fn(1)//固定值 console.log(f(2));//3 console.log(f(3));//4 %/accordion% %accordion% 参数固定 %accordion% function curry(fn,arr=[]){ return function(){ var arg=[...arguments] var len=fn.length var allArr=[...arg,...arr] if(allArr.length %/accordion% %accordion% 参数不固定 %accordion% function curry(fn, arg = []) { return function () { var allArr = [...arg, ...arguments]; if (arguments.length) { return curry(fn, allArr); } else { return fn(...allArr); } }; } var handler = curry(function () { var arr = [...arguments]; return arr.reduce(function (x, y) { return x + y; }); }); console.log(handler(1)(2)(3)(4)); %/accordion% 五、节流函数和防抖函数 1、节流函数 [info] 节流函数 在某段时间内，不管触发了多少次回调，只认第一次触发，无视后面次数产生的触发，并在计时结束时给予响应。 var div = document.querySelector(\"div\"); function throttle(fn, time) { //节流函数 var last = 0; return function () { var now = new Date().getTime(); if (now - last >= time) { last = now; fn.apply(this, arguments); } }; } var clickHandler = throttle(function () { //具体逻辑 console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; [!cogs] %accordion% 节点函数🚀 %accordion% 第一次触发，就执行，如再继续触发下去就等待3秒钟才执行。 按钮 var btn = document.querySelector(\".btn\"); function throttle(fn, delayTime) { var endTime = 0; return function () { var nowTime = +new Date(); if (nowTime - endTime > delayTime) { fn(); endTime = nowTime; } }; } var handler = throttle(function () { console.log(123); }, 3000); btn.addEventListener(\"click\", handler); %/accordion% 2、防抖函数 [info] 防抖函数 在某段时间内，每次触发都会重新计时，直到最后一次触发超过了限定的时间。 var div = document.querySelector(\"div\"); function debounce(fn, time) { var timer; return function () { if (timer) { clearTimeout(timer); } timer = setTimeout(function () { fn.apply(this, arguments); }, time); }; } var clickHandler = debounce(function () { console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; %accordion% 防抖函数🚀 %accordion% 第一次触发等待3秒才执行，如频繁触发就从0开始直到你不按为止，待3秒才执行。 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer return function () { if (timer) { clearTimeout(timer) } timer = setTimeout(function () { fn() }, delayTime) } } var handler = deBounce(function () { console.log(123); }, 3000) btn.addEventListener(\"click\", handler) %/accordion% 3、优化版的防抖函数 [info] 优化版 防抖函数的问题，频繁的延迟会导致用户迟迟得不到响应。优化版的防抖函数本质上还是节流函数。 var div = document.querySelector(\"div\"); function betterDebounce(fn, time) { var timer; var last = 0; return function () { var now = +new Date(); if (now - last %accordion% 优化版的防抖函数🚀 %accordion% 第一次触发就执行，如频繁触发就从0开始直到你不按为止，才执行 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer var endTime = 0 return function () { var nowTime = +new Date() if (nowTime - endTime %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:34:54 "},"24面向对象.html":{"url":"24面向对象.html","title":"24面向对象","keywords":"","body":" 一、面向对象的优势和特性 二、类的创建方式 1、工厂模式，生产出来的所有实例化对象都是一样 2、实例化模式，复用性差，没有共性 3、基于原型的混合模式，同时具有共性和特性 三、实例化对象、构造函数、原型 四、原型链 五、对象的方法 六、堆和栈 1）浅克隆和深克隆 浅克隆,只克隆对象的第一层属性 深克隆,克隆对象的所有层级的属性 2）类的继承 面向对象 [info] 面向对象(oop) 是一种软件开发方法，一种编程范式。面向对象是相对于面向过程来讲的，面向对象方法，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。 一、面向对象的优势和特性 [!COMMENT] 优势 1、方便 2、复用性高 3、高内聚低耦合 4、代码冗余低 特点 1、封装。也就是把客观事物封装成抽象的类。 2、继承。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 3、多态。允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 %accordion% 历史解说🚀 %accordion% c 面向过程 过程，难以理解 c++ 面向对象 对象，容易理解，维护性高 ecma es6 (2015) JavaScript： js 不是面向对象语言，面向原型语言 prototype es6 面向对象 class %/accordion% %accordion% 三种法🚀 %accordion% // 1、函数 function person(){//函数 } person() // 2、构造函数、类 function Person(){//以前：构造函数 //现在：类 } new Person() // 3、类、构造函数（es6） class Person{//类 constructor(){//构造函数 } } 简单定义一个函数 // function person() {//函数 // this.name = \"小明\"// 给window加 // } function person() {//以前：构造函数 //现在：类 this.name = \"小明\" } var p = new person()//对象 console.log(p); //person {name: \"小明\"} %/accordion% 二、类的创建方式 1、工厂模式，生产出来的所有实例化对象都是一样 function Car(){ this.name = \"奔驰\" this.color = \"black\" } let a = new Car() let b = new Car() console.log(a) console.log(b) %accordion% 克隆工厂模式🚀 %accordion% function person() {//构造函数/类 this.name = \"小明\" } var p1 = new person()//对象 console.log(p1); //person {name: \"小明\"} var p2 = new person()//对象 console.log(p2); //person {name: \"小明\"} %/accordion% 2、实例化模式，复用性差，没有共性 function Car(name,color){//实例化模式，复用性差 this.name = name this.color = color } let a = new Car(\"奔驰\",\"黑色\") let b = new Car(\"宝马\",\"蓝色\") console.log(a) console.log(b) %accordion% 实例化模式🚀 %accordion% function person(name) {//构造函数/类 this.name = name } var p1 = new person(\"小明\")//对象 console.log(p1); //person {name: \"小明\"} var p2 = new person(\"小红\")//对象 console.log(p2); //person {name: \"小红\"} %/accordion% 3、基于原型的混合模式，同时具有共性和特性 function Car(name){ this.name = name } Car.prototype.color = \"黑色\" let a = new Car(\"奔驰\") let b = new Car(\"宝马\") console.log(a) console.log(b) %accordion% 混合模式，同时具有共性和特性🚀 %accordion% function person(name, age, sex) {//构造函数/类 this.name = name this.age = age this.sex = sex } person.prototype.country = \"中国\"//共性(原型去添加) var p1 = new person(\"小明\", 18, \"男\")//特性 console.log(p1); //person {name: \"小明\", age: 18, sex: \"男\"} var p2 = new person(\"小红\", 23, \"女\")//特性 console.log(p2); //person {name: \"小红\", age: 18, sex: \"男\"} 这种仅参考 function person(name, age, sex, country) {//构造函数/类 this.name = name this.age = age this.sex = sex this.country = country } var p1 = new person(\"小明\", 18, \"男\", \"中国\")//对象 console.log(p1); //person {name: \"小明\", age: 18, sex: \"男\", country: \"中国\"} var p2 = new person(\"小红\", 23, \"女\", \"中国\")//对象 console.log(p2); //person {name: \"小红\", age: 18, sex: \"男\", country: \"中国\"} %/accordion% 三、实例化对象、构造函数、原型 [!COMMENT] For !COMMENT 所有引用类型都有一个__proto__(隐式原型)属性，属性值是一个普通的对象。 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象。 所有引用类型的__proto__属性指向它构造函数的prototype。 function Car(){//构造函数 this.name = \"奔驰\" this.color = \"black\" } let a = new Car() console.log(a)//实例化对象 console.log(a.__proto__)//实例化对象a的原型 console.log(Car.prototype)//实例化对象a的原型 console.log(a.__proto__ === Car.prototype)//true 四、原型链 [!NOTE] 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 function Car(){//构造函数 this.name = \"奔驰\" this.color = \"black\" } let a = new Car() console.log(a.__proto__)//实例化对象a的原型。即Car.prototype console.log(a.__proto__.__proto__)//对象Object的原型。即Object.prototype console.log(a.__proto__.__proto__.__proto__)//null 图片块 类\\\\构造函数 1、prototype -> 访问原型 2、__proto__ -> 指针，访问构造这个类的原型 原型 1、prototype -> 访问原型 2、__proto__ -> 指针，访问构造这个原型的原型 3、constructor -> 访问类\\\\构造函数 实例化对象 1、__proto__ -> 指针，访问构造这个实例化对象的原型 2、constructor -> 访问类\\\\构造函数 [!cogs] %accordion% 练习 %accordion% function Person(name) {//类、构造函数 this.name = name//实例属性 } var p = new Person(\"小明\") // console.log(Person.prototype); // console.log(Person.__proto__.constructor);//指针，指向构造这个类的原型 // console.log(Person.__proto__.__proto__); // console.log(person.__proto__.__proto__.__proto__);//null Person.__proto__.__proto__.constructor.prototype.eyes = 3 Person.prototype.eyes = 3 console.log(p.eyes);//3 %/accordion% 五、对象的方法 //返回指定对象的原型，用来代替__proto__ Object.getPrototypeOf(obj) //在对象自身查找属性而不到原型上查找 hasOwnProperty() //判断一个对象是否是某个实例的原型对象 isPrototypeOf //判断一个对象是否是一个类的实例 instanceof //根据__proto__来创建一个新对象 Object.create() //用于将所有可枚举属性的值从一个或多个源对象复制到目标对象 Object.assign() //案例 function Car(name){ this.name = name } Car.prototype.color = \"黑色\"//原型属性（共性） let a = new Car(\"奔驰\") console.log(a.hasOwnProperty(\"name\"))//true console.log(a.__proto__.isPrototypeOf(a))//true console.log(a instanceof Car)//true let b = Object.create(a.__proto__)//创建一个基于原型的新对象 console.log(b) let obj = {name:\"小明\"} let obj2 = {name:\"小红\"} console.log(Object.assign(obj,obj2)) 六、堆和栈 //堆 存储引用类型数据object(函数，数组等都是) //栈 存储普通类型数据number,string,boolean,undefined,null //栈是直接赋值数据，堆是赋值引用地址 //栈类型数据 var a = \"123\" var b = a b = \"456\" console.log(a)//123 console.log(b)//456 //堆类型数据 var a = {\"name\":\"小明\"} var b = a b.name = \"小红\" console.log(a)//{name: \"小红\"} console.log(b)//{name: \"小红\"} %accordion% 堆和栈的区别 %accordion% 堆和栈 栈是直接赋值数据：速度快 堆是赋值引用地址：速度慢 堆： 粘贴 文件a（10mb） 文件b（10,mb） 栈： 粘贴快捷方式 文件a（10mb） 文件b（5kb） 直接赋值 【栈】 var a = 1 var b = a b = 2 console.log(a); //1 console.log(b); //2 赋值的是引用地址，CPU地址 对象 【堆】 var a = { name: \"小明\" } var b = a; b.name = \"小红\" console.log(a); //小红 console.log(b); //小红 %/accordion% 1）浅克隆和深克隆 浅克隆,只克隆对象的第一层属性 var obj = {name:\"小明\"} var obj2 = Object.assign({},obj) obj2.name = \"小红\" console.log(obj) //{name: \"小明\"} console.log(obj2) //{name: \"小红\"} %accordion% 浅克隆——更改值另一个不受影响 %accordion% var a = { name: \"小明1\", obj: { name: \"小明2\" } } var b = Object.assign({}, a) b.obj.name = \"小红\" console.log(a); console.log(b); %/accordion% 深克隆,克隆对象的所有层级的属性 [!COMMENT] 深克隆有三种方法 1、自定义深克隆——麻烦 2、JSON.parse(JSON.stringify())——缺陷 3、jq方法 $.extend(true,{},obj)——引用函数库 [!cogs] %accordion% 简单深克隆 %accordion% var a = { name: \"小明1\", obj: { name: \"小明2\" } } var x = Object.assign({}, a) var y = Object.assign({}, a.obj) x.obj = y x.obj.name = \"小红2\" console.log(x); console.log(a); %/accordion% %accordion% 1、自定义深克隆 %accordion% function deepClone(obj){ var x = {} for(key in obj){ if(typeof obj[key] === \"object\"){ x[key] = deepClone(obj[key]) }else{ x = Object.assign(x,obj) } } return x } var b = deepClone(a) b.obj.name = \"小红2\" console.log(a)//{name: \"小明1\",obj: {name: '小明2'}} console.log(b)//{name: \"小明1\",obj: {name: '小红2'}} %/accordion% %accordion% 2、JSON.parse(JSON.stringify()) %accordion% 工作中用得最多了 缺陷里面有——构造涵数、正则表达式 都会有问题 var a = { name: \"小明1\", obj: { name: \"小明2\" } } var b = JSON.parse(JSON.stringify(a)) b.obj.name = \"小红\" console.log(a); console.log(b); %/accordion% %accordion% 3、jq方法 $.extend(true,{},obj) 引用函数库 %accordion% jquery var a = { name: \"小明1\", obj: { name: \"小明2\" }, reg: /hello/ } var b = $.extend(true, {}, a) b.obj.name = \"小红2\" console.log(a); console.log(b); %/accordion% 2）类的继承 es5 //es5 function Person(){ this.name = \"小明\" } Person.prototype.age = 18 var p = new Person() function Student(){ Person.call(this) } Student.prototype = Person.prototype var s = new Student() console.log(s.age) es6 ——方便 class Person{ constructor(name){ this.name = name } } var p = new Person(\"小明\") class Student extends Person{ constructor(name){ super(name) } } var s = new Student(\"小红\") console.log(s) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:35:09 "},"repair.html":{"url":"repair.html","title":"npm包管理系统","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"npm包管理系统.html":{"url":"npm包管理系统.html","title":"npm包管理系统","keywords":"","body":"npm包管理系统 npm包管理系统是nodejs自带的一个插件管理系统。需要先安装完node才可以使用。 基本指令 初始化项目 //npm init是初始化npm包，-y是全部选yes，注意项目名字不能是中文 npm init 或 npm init -y 安装插件 npm install 或 npm i 安装选择的环境 development 开发环境 上线不需要的 -D production 生产环境 上线也需要的 -S 文件目录 package.json npm包管理文件 package-lock.json npm版本管理锁，不让npm里面的插件包自动升级 node_modules npm包存放插件的地方（依赖包） Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-15 20:52:14 "},"webpack.html":{"url":"webpack.html","title":"webpack练习","keywords":"","body":" 打包器 安装webpack webpack配置 前端工程目录规范 核心概念 入口 出口 loader翻译器 plugins插件 webpack常用插件 webpack实现vue代码运行 webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 打包器 什么是打包器？ 以前：html\\css\\js 没有模块化 现在：vue项目 模块化（复用性高、维护便利） npm run build 打包:把现代的项目变回以前的项目，目的是让浏览器能识别的同时又能让我们开发的时候可以使用现代的模块化开发 安装webpack //初始化包管理系统（注意项目目录名字不要写webpack） npm init -y //安装最新版webpack和指定版本webpack（不建议全局安装） npm install --save-dev webpack npm install --save-dev webpack@ //全局安装，因为webpack各版本之间互不兼容，所以【不建议全局安装】 npm i webpack -g //如果是4及以上的版本还需要额外安装cli npm install --save-dev webpack-cli 正常安装三条命令 npm init -y npm install --save-dev webpack npm install --save-dev webpack-cli webpack配置 在根目录下创建webpack.config.js文件 const path = require(\"path\")//npm自带的路径管理器 module.exports = { entry:\"./index.js\",//入口 output:{//出口(只支持绝对路径) path:path.resolve(__dirname,\"dist\") } } 配置package.json文件 { \"name\": \"webapck_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\", \"build\":\"webpack --config webpack.config.js\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"webpack\": \"^5.52.0\", \"webpack-cli\": \"^4.8.0\" } } 前端工程目录规范 public存放不需要改动的文件 src存放核心文件 核心概念 入口 webapck会根据某个指定的文件作为核心文件，然后其他文件以这个文件为依赖进行依赖关系图设置，从而找到其他文件。 module.exports = { entry: \"./src/main.js\",//入口 } 出口 根据核心文件打包后的文件。 const path = require(\"path\")//npm自带的路径管理器 module.exports = { entry: \"./src/main.js\",//入口 output: {//出口(只支持绝对路径) path: path.resolve(__dirname, \"dist\") } } loader翻译器 这里先安装两个插件 npm i style-loader css-loader -D 处理非js文件，因为webpack无法识别非js文件，所以需要loader进行转换。 const path = require(\"path\")//npm自带的路径管理器 module.exports = { entry: \"./src/main.js\",//入口 output: {//出口(只支持绝对路径) path: path.resolve(__dirname, \"dist\") }, module: {//loader的执行顺序是下往上，右往左 rules: [ { test: /\\\\.css$/, use: [ { loader: 'style-loader' // 可以把css放在页面上 }, { loader: 'css-loader' // 放在后面的先被解析 } ] } ] } } plugins插件 这里先安装一下 npm i html-webpack-plugin -D 专门处理一些webpack本身无法处理的事情，比如css、js、图片压缩等额外操作。 const path = require(\"path\")//npm自带的路径管理器 const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: \"./src/main.js\",//入口 output: {//出口(只支持绝对路径) path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\\\.css$/, use: [ { loader: 'style-loader' // 可以把css放在页面上 }, { loader: 'css-loader' // 放在后面的先被解析 } ] } ] }, plugins:[ new HtmlWebpackPlugin() ] } webpack常用插件 这里安装依赖包 npm install webpack-dev-server -D HtmlWebpackPlugin 创建html模版 webpack-dev-server 运行本地服务器 package.json文件 { \"name\": \"webapck_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\\\"Error: no test specified\\\\\" && exit 1\", \"build\": \"webpack --config webpack.config.js\", \"dev\":\"webpack serve\" //记得加入这一句 }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"css-loader\": \"^6.2.0\", \"html-webpack-plugin\": \"^5.3.2\", \"style-loader\": \"^3.2.1\", \"webpack\": \"^5.52.0\", \"webpack-cli\": \"^4.8.0\", \"webpack-dev-server\": \"^4.1.1\" } } module.exports = { mode: \"development\", //记得加入这一句 entry: \"./src/main.js\", //入口 }; 然后打开浏览器输入http://localhost:8080即可查看效果 webpack实现vue代码运行 1、安装插件和loader npm i vue@2 vue-loader@14.2.2 babel-loader @babel/core @babel/preset-env -D vue vue核心文件 vue-loader vue翻译器，让我们能够使用vue文件 vue-template-compiler 翻译vue的template标签 babel-loader 让es6或者更高版本的js代码降级为大部分浏览器能识别的es5代码 @babel/core babel的核心核心（新版的babel都需要安装） @babel/preset-env babel的预设文件（就是内部配置好的文件） \"vue\": \"^2.6.14\", \"vue-loader\": \"^14.2.2\", 2、配置.babelrc文件 { \"presets\": [ \"@babel/env\" ] } 3、webpack进行vue-loader和babel配置 const path = require(\"path\")//npm自带的路径管理器 const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: \"development\", entry: \"./src/main.js\",//入口 output: {//出口(只支持绝对路径) path: path.resolve(__dirname, \"dist\") }, module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' // 可以把css放在页面上 }, { loader: 'css-loader' // 放在后面的先被解析 } ] }, { test: /\\.vue$/, use: [ { loader: 'vue-loader' }, ] }, { test: /\\.js$/, // exclude：排除 exclude: /(node_modules|bower_components)/, use: { loader: \"babel-loader\", }, } ] }, plugins: [ new HtmlWebpackPlugin({ template: './public/index.html'//必须要有这个步骤 }) ] } 4、根目录下public/index.html Document 5、创建src/App.vue export default { data() { return { msg: \"你是猴子派来的救兵吗？\", }; }, }; 6、更改main.js文件 import Vue from \"vue\"; import App from \"./App.vue\"; import \"./index.css\" new Vue({ render: (h) => h(App), }).$mount(\"#app\"); 这是所有配置package.json { \"name\": \"webpack_test\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack --config webpack.config.js\", \"dev\": \"webpack serve\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"@babel/core\": \"^7.17.5\", \"@babel/preset-env\": \"^7.16.11\", \"babel-loader\": \"^8.2.3\", \"css-loader\": \"^6.6.0\", \"html-webpack-plugin\": \"^5.5.0\", \"style-loader\": \"^3.3.1\", \"vue\": \"^2.6.14\", \"vue-loader\": \"^14.2.2\", \"webpack\": \"^5.69.1\", \"webpack-cli\": \"^4.9.2\", \"webpack-dev-server\": \"^4.7.4\" } } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-25 18:48:34 "},"es6.html":{"url":"es6.html","title":"Es6","keywords":"","body":"ES6 [success] ecmaScript6（es6/es2015） 是一种由Ecma国际(欧洲计算机制造商协会)通过ECMA-262标准化的脚本程序设计语言(2015年发布) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-04 13:57:18 "},"01变量-es6.html":{"url":"01变量-es6.html","title":"01变量","keywords":"","body":" 一、变量let 1、没声明变量 2、常见报错(es5—es6) 1） 2） 3） 4） 5） 3、块级作用域 变量 一、变量let //1)不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用 console.log(a) let a = 1//报错 //2)同一作用域的同一个变量不能够重复声明，避免我们重复声明变量 let a = 'hello world' let a = 'hello world'//报错 //3)let声明的变量不会绑定到window let a = 'hello swr' console.log(window.a)//undefined //4)let和代码块{}结合使用会形成块级作用域 { let str = \"hello\" } console.log(str)//hello //5)暂时性死区 //在代码块内，使用let命令声明变量之前，该变量都是不可用的 if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } [!cogs] %accordion% 历史解说 %accordion% JavaScript JScript ecma(计算机标准组织) es5 ———— （2015以下都是es5） es6 ———— (es2015) es7 es8 es9 es10 es11（最新） %/accordion% 1、没声明变量 不存在变量作用域提升，这样可以避免了我们还没声明变量就拿变量来用 //es5 console.log(a);//安笛梵undefined var a = 1; //es6 console.log(a); //报错 let a = 1; 2、常见报错(es5—es6) 1） //es5 var a = 1; function fn() { console.log(a);//undefined var a = 2; } fn(); //es6 let a = 1 function fn() { console.log(a); //报错 let a = 2 } fn() fn()//var fn()这个是变量提升 es6就会报错 es5就undefined var fn = function () { console.log(123); } 2） //es5 var a = 1 var a = 2 console.log(a);//这种是2 //es6 let a = 1 let a = 2 console.log(a);//报错 //es6 let a = 1 a = 2 console.log(a);//这种是2 3） //es5 var a = 1 console.log(window.a);//这种是1 //es6 let a = 1 console.log(window.a); //undefined 4） //es5 for (var i = 1; i 5） //es5 function fn() { a = 1 console.log(a); //1 } fn() //es6 function fn() { a = 1 console.log(a);//报错 let a } fn() 3、块级作用域 [info] 块级{} 花括号都是块级{} let和代码块{}结合使用会形成块级作用域 //es5 { var a = 1 console.log(a);//1 } { var a = 1 console.log(window.a);//1 } //es6 { let a = 1 console.log(a);//1 } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:26:49 "},"02常量-es6.html":{"url":"02常量-es6.html","title":"02常量","keywords":"","body":"常量 //常量是固定的量，一般用于存地址等信息 const a = 1 const baseUrl = \"www.baidu.com\" [!cogs] //es5 var BASE_URL = \"www.baidu.com\" BASE_URL = \"www.sina.com\" console.log(BASE_URL); //www.sina.com //es6 const BASE_URL = \"www.baidu.com\" BASE_URL = \"www.sina.com\" console.log(BASE_URL); //报错 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:27:23 "},"03解构赋值-es6.html":{"url":"03解构赋值-es6.html","title":"03解构赋值","keywords":"","body":" 一、使用解构赋值 二、数组解构赋值 三、对象解构 解构赋值 一、使用解构赋值 function fn(){ let a = 1 let b = 2 return { a,b } } //没有解构赋值 let obj = fn() console.log(obj.a) console.log(obj.b) //使用了解构赋值 let {a,b} = fn() console.log(a) console.log(b) //等同于下面的代码，在es6里面，对象的key和value相同时，可以省略后面的冒号和value let {a:a,b:b} = fn() console.log(a) console.log(b) //结构赋值命名 let {a:x,b:y} = fn() console.log(x) console.log(y) [!cogs] %accordion% es5与es6写法 %accordion% //es5 var obj = { name: \"张三\", age: 18 } console.log(obj.name); //张三 console.log(obj.age); //18 //es6 let { name, age } = { name: \"张三\", age: 18 }; console.log(name); //张三 console.log(age); //18 %/accordion% 二、数组解构赋值 //数组解构 let [a,b,c] = [1,2,3,4,5] console.log(a) console.log(b) console.log(c) //默认值 let [a=1,b,c] = [\"x\",2,3,4,5] console.log(a) console.log(b) console.log(c) //克隆 let a = [1,2,3,4,5] // let b = Object.assign([],a) 浅克隆 // let b = JSON.parse(JSON.stringify(a)) 深克隆 let b = [...a]//es6 b.push(6) console.log(a)//[1,2,3,4,5] console.log(b)//[1,2,3,4,5,6] let [b,c,d] = [...a]//es6 console.log(b)//1 console.log(c)//2 console.log(d)//3 [!cogs] %accordion% 数组解构赋值 %accordion% let [a, b, c] = [\"张三\", \"李四\", \"老王\"] console.log(a); //张三 console.log(b); //李四 console.log(c); //老王 %/accordion% %accordion% 默认 %accordion% let [a, b, c = \"张三\"] = [\"李四\", \"老王\", \"赵四\"] console.log(a); //李四 console.log(b); //老王 console.log(c); //赵四 %/accordion% %accordion% 浅克隆 %accordion% let a = [1, 2, 3] let b = [...a] console.log(b);//[1, 2, 3] let a = [1, 2, 3] let b = [...a] b[0] = 'x' console.log(b);//[\"x\", 2, 3] let a = [ { name: \"张三\", obj: { name: \"李四\" } } ] let b = [...a] b[0].obj.name = \"老王\" console.log(a);//{name: \"张三\", obj: {…}} console.log(b);//{name: \"张三\", obj: {…}} let a = [1, 2, 3] let b = a b[0] = \"x\" console.log(a);//[\"x\", 2, 3] console.log(b);//[\"x\", 2, 3] let a = [1, 2, 3] let b = [...a] b[0] = \"x\" console.log(a); //[1, 2, 3] console.log(b); //[\"x\", 2, 3] %/accordion% 三、对象解构 //对象解构 let {name,age} = {name:\"swr\",age:28} console.log(name) // 'swr' console.log(age) // 28 //对象解构-命名 let { name:Name,age } = { name:'swr',age:28 } console.log(Name) // 'swr' console.log(age) // 28 //默认值 let {name=\"swr\",age} = {age:28} console.log(name) // 'swr' console.log(age) // 28 //解构函数参数 function fn({name,age}){ console.log(name) console.log(age) } fn({name:\"小明\",age:18}) //数组对象解构 let [,{name}] = [{name:'小明',age:18},{name:'小红',age:19}] console.log(name)//小红 [!cogs] %accordion% 对象解构%accordion% //对象解构-命名 let { name: a } = { name: \"张三\" } console.log(a); //张三 let { name, age = 18 } = { name: \"张三\", age: 19 } console.log(age); //19 %/accordion% %accordion% 解构函数参数 %accordion% function fn({ name, age }) { console.log(name); //张三 console.log(age); //18 } fn({ name: \"张三\", age: 18 }) %/accordion% %accordion% 数组对象解构 %accordion% //打印第一个 let [{ name, age }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(name)//张三 console.log(age)//18 //打印第二个 let [, { name, age }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(name) //李四 console.log(age) //19 //打印二个 let [{ name: aName, age: aAge }, { name: bName, age: bAge }] = [{ name: '张三', age: 18 }, { name: '李四', age: 19 }] console.log(aName) //张三 console.log(aAge) //18 console.log(bName) //李四 console.log(bAge) //19 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:28:00 "},"04字符串拓展-es6.html":{"url":"04字符串拓展-es6.html","title":"04字符串拓展","keywords":"","body":"字符串拓展 //for of 字符串遍历 let str = \"hello world\" for(s of str){ console.log(s) } //includes 返回布尔值，表示是否找到了参数字符串 let str = \"hello world\" console.log(str.includes(\"hello\"))//true //repeat 方法返回一个新字符串，表示将原字符串重复n次 let str = \"hello\" console.log(str.repeat(2))//hellohello //模版字符串 let str = `hello world` let str = `飞流直 下三千尺` console.log(str) let s = \"world\" let str = \"hello\"+s console.log(str) let s = \"world\" let str = `hello ${s}` console.log(str) [!cogs] %accordion% for of 字符串遍历 %accordion% let str = \"hello world\" for (idx of str) { console.log(idx); } %/accordion% 模版字符串 let str = `hello world` console.log(str); //答案： //hello //world let a = \"hello\" let b = \"world\" console.log(`${a}${b}`); //helloworld Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:28:42 "},"05数字拓展-es6.html":{"url":"05数字拓展-es6.html","title":"05数字拓展","keywords":"","body":"数字拓展 //isFinite() 检查一个数值是否为有限的 Number.isFinite(15); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false //isNaN() 判断一个值是否为非数字 let str = \"hello\" console.log(isNaN(Number(str)))//true //parseInt() 把字符串变为正整数 Number.parseInt('12.34') //parseFloat() 把字符串变为浮点数 Number.parseFloat('12.34') //isInteger() 用来判断一个值是否为整数 //Math.sign() 用来判断一个数到底是正数、负数、还是零 console.log(Math.sign(5))//1，正数 console.log(Math.sign(-5))//-1，负数 console.log(Math.sign(0))//0，零 [!cogs] %accordion% 用来判断一个值是否为整数 %accordion% let num = 1.5 console.log(Number.isInteger(num)); //false %/accordion% %accordion% js的浮点数缺陷 %accordion% let num1 = 0.1 let num2 = 0.2 let num3 = (num1 + num2).toFixed(1) console.log(Number(num3)); //0.3 %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:28:59 "},"06数组拓展-es6.html":{"url":"06数组拓展-es6.html","title":"06数组拓展","keywords":"","body":"数组拓展 //Array.from() 把类数组转化成数组 function fn(){ console.log(Array.from(arguments)) } fn(1,2,3) //Array.of 将一组值，转换为数组 console.log(Array.of(3, 11, 8)) // [3,11,8] //find() 找出第一个符合条件的数组成员 let arr = [1,2,3,4,5] let newArr = arr.find(function(item){ return item % 2 === 0 }) console.log(newArr)//2 //findIndex() 找出第一个符合条件的数组成员的索引值 let arr = [1,2,3,4,5] let newArr = arr.findIndex(function(item){ return item % 2 === 0 }) console.log(newArr)//1 //fill() 填充数组 console.log(['a', 'b', 'c'].fill(7))//[7, 7, 7] console.log([,,,].fill(6))//[6,6,6] //flat() 数组扁平化 let arr = [['name', '小明'], ['age', 18], ['sex', '男']] console.log(arr.flat(1))//[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] let arr = [1,2,[3,4,[5,6]]] console.log(arr.flat(Infinity))//永远变成1维数组 [!cogs] %accordion% 把类数组转化成数组 %accordion% function fn() { console.log([...arguments]); //[1, 2, 3] // console.log(Array.from(arguments)); //[1, 2, 3] } fn(1, 2, 3) //Array.of 将一组值，转换为数组 console.log(Array.of(3, 11, 8)) // [3,11,8] //find() 找出第一个符合条件的数组成员 let arr = [1, 2, 3, 4, 5] let newArr = arr.find(function (item) { return item % 2 === 0 }) console.log(newArr)//2 %/accordion% 数组扁平化✨ //flat() 数组扁平化 let arr = [ ['name', '小明'], ['age', 18], ['sex', '男'] ] console.log(arr.flat(1)) //[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] //flat() 数组扁平化 //Infinity永远都是一维 let arr = [ [1, 2, [3, 4, [5, 6]]] ] console.log(arr.flat(Infinity)) //[1, 2, 3, 4, 5, 6] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:29:27 "},"07函数拓展-es6.html":{"url":"07函数拓展-es6.html","title":"07函数拓展","keywords":"","body":" 箭头函数 1、单行的时候可以不加大括号 2、单行使用的时候可以直接返回值，不需要加return 3、无参数写法 4、绑定this指针 5、无法当成构造函数使用 6、箭头函数没有arguments 函数拓展 //形参默认值 function fn(a=1){ console.log(a) } fn(2) ///与解构赋值一起用 function fn({name}){ console.log(name) } fn({name:\"小明\"}) //和扩展预算符一起使用 function fn(a,...b){ console.log(a)//1 console.log(b)//[2, 3, 4, 5] } fn(1,2,3,4,5) %accordion% 练习 %accordion% //形参默认值 function fn(a,b=1){ console.log(a+b) } fn(1) //2 %/accordion% 箭头函数 1、单行的时候可以不加大括号 let fn = ()=> console.log(\"hello world\") console.log() 2、单行使用的时候可以直接返回值，不需要加return let fn = ()=> \"hello world\" console.log(fn()) 3、无参数写法 //没有参数的时候可以使用括号也可以使用下划线 let fn = _ => \"hello world\" console.log(fn()) %accordion% 练习 %accordion% //有参数 let fn = () => 1 console.log(fn()); //1 // 无参数 let fn = _ => 1 console.log(fn());//1 %/accordion% 4、绑定this指针 //使用箭头函数的时候，无法修改this指针 function fn(){ console.log(this)//obj } let fn = ()=>{ console.log(this)//window } let obj = { name:\"小明\" } fn.call(obj) %accordion% 练习 %accordion% let obj = { name: \"张三\" } function fn() { console.log(this); } fn.call(obj)//{name: \"张三\"} let obj = { name: \"张三\" } let fn = () => { console.log(this); //Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …} } fn.call(obj) %/accordion% 5、无法当成构造函数使用 let Person = ()=>{ } new Person()//报错 6、箭头函数没有arguments let Person = ()=>{ console.log(arguments)//报错 } Person() %accordion% 练习 %accordion% // 错误法 let fn = (name) => { this.name = name } let f = new fn(\"张三\") console.log(f); let fn = () => { console.log(arguments); } fn(1, 2, 3) %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:30 "},"08对象拓展-es6.html":{"url":"08对象拓展-es6.html","title":"08对象拓展","keywords":"","body":"对象拓展 //Object.is() 判断两个值是否相等 console.log(Object.is('foo', 'foo'))//true console.log(Object.is({}, {}))//false //Object.assign() 用于对象的合并 let obj = {name:\"小明\"} let obj2 = {age:18} console.log(Object.assign(obj,obj2))//{name:\"小明\",age:18} let obj = {name:\"小明\"} let obj2 = {name:\"小红\"} console.log(Object.assign(obj,obj2))//小红 //对键名的遍历和对键名的遍历 let obj = {name:\"小明\",age:18,sex:\"男\"} console.log(Object.keys(obj))//['name', 'age', 'sex'] console.log(Object.values(obj))//['小明', 18, '男'] //entries() 对键值对的遍历 let obj = {name:\"小明\",age:18,sex:\"男\"} console.log(Object.keys(obj))//['name', 'age', 'sex'] console.log(Object.values(obj))//['name', 'age', 'sex'] console.log(Object.entries(obj))//[['name', '小明'], ['age', 18], ['sex', '男']] let newArr = Object.entries(obj) console.log(newArr) console.log(newArr.flat(1))//[\"name\",\"小明\",\"age\",18,\"sex\",\"男\"] [!cogs] %accordion% Object.is() 判断两个值是否相等 %accordion% console.log(Object.is(\"hello\",\"world\")); //true let str=\"hello\" let str2=\"hello\" console.log(str==str2); //true // 对象不能同时出现两个不然会报错 let str ={name:\"张三\"} let str2 ={name:\"张三\"} console.log(str==str2); //false %/accordion% %accordion% Object.assign() 用于对象的合并🚀 %accordion% //Object.assign() 用于对象的合并 ✨ let obj = { name: \"张三\" } let obj2 = { age: 18 } console.log(Object.assign(obj, obj2)); //{ name: \"张三\", age: 18 } console.log({ ...obj, ...obj2 }); //{ name: \"张三\", age: 18 } %/accordion% %accordion% 对键名的遍历和对键名的遍历 %accordion% let obj = { name: \"张三\", age: 18 } let arr = Object.keys(obj) console.log(arr);//[\"name\", \"age\"] let arr = Object.values(obj) console.log(arr);//[\"张三\", 18] let arr = Object.entries(obj) console.log(arr.flat(1)); //[\"name\", \"张三\", \"age\", 18] %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:30:02 "},"09类拓展-es6.html":{"url":"09类拓展-es6.html","title":"09类拓展","keywords":"","body":" 一、创建类 二、类继承 类拓展 一、创建类 class Person{ constructor(name) {//构造器 this.name = name//实例化属性 } age = 18//实例化属性 static hobby = \"打游戏\"//静态属性 } Person.prototype.sex = \"男\"//原型属性 let p = new Person(\"小明\") Person.hobby//打游戏 [!cogs] %accordion% 这种是活了 %accordion% class Person {//类 constructor(name, age) {//构造函数 this.name = name//实例属性 this.age = age } } let p = new Person(\"张三\", 18) console.log(p); //Person {name: \"张三\", age: 18} %/accordion% %accordion% 这种age已经写死了 %accordion% class Person {//类 constructor(name) {//构造函数 this.name = name//实例属性 } age = 18//实例化属性 } let p = new Person(\"张三\") console.log(p); //Person {age: 18, name: \"张三\"} %/accordion% %accordion% 语法糖 %accordion% class Person {//类 constructor(name) {//构造函数 ——对象上调用 this.name = name//实例属性 ——对象上调用 } age = 18//实例化属性 static hobby = \"打游戏\"//静态属性，——在类上调用 } Person.prototype.sex = \"男\"//原型属性 ——对象上调用 let p = new Person(\"张三\") console.log(p); //Person {age: 18, name: \"张三\"} console.log(Person.hobby); //打游戏 %/accordion% 二、类继承 class Person{ constructor(name) { return this.name = name } say(){ return \"呵呵\" } } class Student extends Person{ constructor(name,age){ super(name)//继承父类的构造函数方法 this.age = age//student类自己独有的属性 } saying(){ return super.say()+\"哈哈\"//调用父类的原型方法 } } let s = new Student(\"小明\",18) console.log(s.saying())//呵呵哈哈 [!cogs] %accordion% 1️⃣😀 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { } let s = new Student() console.log(s); //Student {age:18, name: undefined} %/accordion% %accordion% 2️⃣😂 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { } let s = new Student(\"李四\") console.log(s); //Student {age:18, name: \"李四\"} %/accordion% %accordion% 3️⃣🤣 %accordion% class Person { constructor(name) { this.name = name } age = 18 } let p = new Person(\"张三\") class Student extends Person { constructor(name) { super(name) //可以更改属性 } } let s = new Student(\"李四\") console.log(s); //Student {age:18, name: \"李四\"} %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:30:26 "},"10扩展运算符-es6.html":{"url":"10扩展运算符-es6.html","title":"10扩展运算符","keywords":"","body":"扩展运算符 //数组运用 let arr = [1,2,3,4,5] let arr2 = [6,7,8,9,10] let newArr = [...arr,...arr2] console.log(newArr) //对象运用 let obj = {name:\"小明\",age:18} let obj2 = {sex:\"男\",hobby:\"打游戏\"} let newObj = {...obj,...obj2} console.log(newObj) //类数组运用 function fn(){ console.log([...arguments]) } fn(1,2,3) //形参，要注意使用结构运算符获取参数的时候，只能写在最后一个参数上 function fn(a,...b){ console.log(a) console.log(b) } fn(1,2,3,4,5) [!cogs] // 数组 let arr = [1, 2, 3]; let arr2 = [4, 5, 6]; console.log([...arr, ...arr2]);//[1, 2, 3, 4, 5, 6] // 对象 let obj = { name: \"张三\" } let obj2 = { age: 18 } console.log({ ...obj, ...obj2 });//{name: \"张三\", age: 18} // 类数组 function fn() { console.log([...arguments]);//[1, 2, 3] } fn(1, 2, 3) // 参数 function fn(a, ...b) { console.log(a);//1 console.log(b);//[2, 3, 4, 5] } fn(1, 2, 3, 4, 5) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:30:47 "},"11set数据结构-es6.html":{"url":"11set数据结构-es6.html","title":"11set数据结构","keywords":"","body":" 一、创建set数据结构 set数据结构操作 set数据结构 一、创建set数据结构 console.log(new Set([1,2,3,3,1,5]))//{1,2,3,5} console.log(new Set([\"a\",\"c\",\"a\",\"b\",\"b\"]))//{'a', 'c', 'b'} //如果是数组对象，对象不会进行去重 console.log( new Set([ { name: \"小明\", age: 18 }, { name: \"小红\", age: 19, sex: \"女\" }, { name: \"小蓝\", sex: \"男\" }, ]) ); //去重 let arr = [1,2,3,1,2] console.log([...new Set(arr)])//(new Set(arr) set数据结构操作 //add(value) 添加某个值，返回Set结构本身 let s = new Set([1,2,3]) let newS = s.add(4) console.log(s)//{1, 2, 3, 4} console.log(newS)//{1, 2, 3, 4} //delete(value) 删除某个值，返回一个布尔值，表示删除是否成功 let s = new Set([1,2,3]) let newS = s.delete(3) console.log(s)//{1,2} console.log(newS)//true //has(value) 返回一个布尔值，表示该值是否为Set的成员 let s = new Set([1,2,3]) let newS = s.has(1) console.log(newS)//true //clear() 清除所有成员，没有返回值 let s = new Set([1,2,3]) let newS = s.clear() console.log(s)//{} console.log(newS)//undefined //Array.from 和 [...] 把set数据结构转成数组结构 let s = new Set([1,2,3]) console.log(Array.from(s))//[1, 2, 3] console.log([...s])//[1, 2, 3] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:31:33 "},"12map数据结构-es6.html":{"url":"12map数据结构-es6.html","title":"12map数据结构","keywords":"","body":" 一、创建map数据结构 二、接受二维数组作为参数 三、size获取长度 四、操作 map数据结构 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 一、创建map数据结构 let m = new Map();//创建map数据结构 m.set({ name: \"小明\" }, 2);//设置map数据结构 console.log(m);//{Object => 2} 二、接受二维数组作为参数 let m = new Map([[\"name\",\"张三\"],[\"age\",18]]) console.log(m.get(\"name\"))//张三 三、size获取长度 let m = new Map([[\"name\",\"张三\"],[\"age\",18]]) console.log(m.size)//2 四、操作 let m = new Map([[\"name\",\"张三\"],[\"age\",18]]) //set(key, value) 设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 //也可以链式调用 m.set(\"sex\",\"男\") console.log(m) //get(key) 读取key对应的键值，如果找不到key，返回undefined console.log(m.get(\"age\"))//18 //has(key) 返回一个布尔值，表示某个键是否在Map数据结构中 console.log(m.has(\"age\"))//true //delete(key) 删除某个键，返回true。如果删除失败，返回false。 m.delete(\"age\") console.log(m)//m.delete(\"age\") //clear() 清除所有成员，没有返回值 m.clear() console.log(m)//{} Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:31:53 "},"13同步和异步-es6.html":{"url":"13同步和异步-es6.html","title":"13同步和异步","keywords":"","body":" 一、同步任务和异步任务 二、异步函数 三、异步函数-promise 1)使用promise 2、案例 3、promise带来的问题-回调地狱 四、async await 同步和异步 js是单线程语言，代码的执行顺序是由上往下执行的 //先执行打印1，再执行打印2 console.log(1) console.log(2) %accordion% 历史解说 %accordion% 线程和进程 js是单线程语言 单位时间内只能做一件事 单线程 异步执行 提高效率 阻塞 双线程 同步执行 执行栈 ——备选中 先保存 在做考虑 new Promise() 异步函数，把异步变成同步 async await() 异步函数 回调函数 promise async await 前后端分离 前端 请求/响应 后端 列表 渲染页面 promise 需要通过回调函数获取值，asyncawait不需要 promise有回调地狱 %/accordion% 一、同步任务和异步任务 因为js是单线程的原因，如果执行完计时器再执行其他代码，那么会造成阻塞。 所以js会把需要消耗时间的操作都分类为异步任务，不需要消耗时间的分为同步任务。 js会把异步任务分配到任务队列里面，而同步任务分配到主线程里面，先执行完主线程的任务再执行任务队列的任务。 //先执行打印2，隔2秒后再执行打印1 setTimeout(()=>{ console.log(1) },2000) console.log(2) %accordion% 练习🚀 %accordion% //先打印2再隔一秒打印1 setTimeout(function () { console.log(2); //2 }, 1000) console.log(1); //1 function fn(f) { f(1) } fn(function (val) {//调用fn console.log(val);//1 }) %/accordion% 二、异步函数 异步函数是把异步任务变成同步任务执行。 //这种写法就是先等待2秒后执行1，然后再执行2。 function a(){ return new Promise((resolve,reject)=>{ setTimeout(()=>{ console.log(1) resolve() },2000) }) } a().then(()=>{ console.log(2) }) %accordion% 练习🚀%accordion% // 先执行2在执行1 隔得1秒 function fn(f) { setTimeout(function () { console.log(2); f() }, 1000) } fn(function () { console.log(1); }) %/accordion% 三、异步函数-promise 1)使用promise //promise对象里面提供了一个resolve回调和reject回调，分别代表成功和失败 let bool = false let p = new Promise((resolve,reject)=>{ if(bool){ resolve() }else{ reject() } }) //成功后用.then()的方式获取成功的回调，.catch()获取失败回调 p.then(()=>{ console.log(123) }).catch(()=>{ console.log(456) }) %accordion% 练习🚀 %accordion% 成功执行的2然后就执行1，失败就凉了 function fn() { return new Promise((resolve) => { setTimeout(function () { console.log(2);//2 resolve() }, 1000) }) } fn().then(function () { console.log(1);//1 }) new Promise((resolve,reject)=>{ resolve()//成功的 reject()//失败的 }) %/accordion% 2、案例 //这个案例实现了把异步任务变成同步任务执行 function a(){ return new Promise((resolve,reject)=>{ setTimeout(()=>{ console.log(1) resolve() },2000) }) } a().then(()=>{ console.log(2) }) 3、promise带来的问题-回调地狱 //promise会带来一个问题，称为回调地狱，无法从then的外面获取值，而且不美观 function a(){ return new Promise((resolve,reject)=>{ setTimeout(()=>{ resolve(1) },2000) }) } a().then((res)=>{ console.log(res)//1 }) 四、async await //async await 就是用来解决promise产生的回调地狱的问题 function a(){ return new Promise((resolve,reject)=>{ setTimeout(()=>{ resolve(1) },2000) }) } async function fn(){ let x = await a() console.log(x)//1 } fn() [!cogs] // new Promise() 异步函数，把异步变成同步 // async await() 异步函数 function fn1() { return new Promise((resolve) => { setTimeout(function () { console.log(1); resolve() }, 1000) }) } function fn2() { return new Promise((resolve) => { setTimeout(function () { console.log(2); resolve() }, 1000) }) } function fn3() { return new Promise((resolve) => { setTimeout(function () { console.log(3); resolve() }, 1000) }) } /——仅参考 // fn1().then(() => { // fn2().then(() => { // fn3().then(() => { // console.log(4); // }) // }) // }) async function f() { await fn1() //1 await fn2() //2 await fn3() //3 console.log(4); //4 } f() Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:32:27 "},"git.html":{"url":"git.html","title":"Git","keywords":"","body":" 2 git诞生 3 集中型版本控制工具和分布式版本控制工具 3.1 集中型的版本控制工具 3.2 分布式版本控制工具 1 git是什么？ 可参考my博文 git是目前世界上最先进的分布式版本控制工具（没有之一）。 git由什么特点? 什么是版本控制工具? 说白了就是帮助我们管理不同版本的文件的一个应用程序。 2 git诞生 2002年之前，linus自己手动维护linux的版本代码 2002之后到2005年，使用的免费的bitkeeper 2005年之后，linus开发git 3 集中型版本控制工具和分布式版本控制工具 3.1 集中型的版本控制工具 svn,cvs,vss 特点： 1. 实现大部分开发中对版本管理的需求 2. 结构很简单，上手容易 缺点： 1. 对中央仓库依赖严重，一旦损坏了，历史数据怎么恢复？ 2. 程序员上传的都是完整版，如何追溯查询？ 3. 系统正在上线运行，需要修改bug或增加几个不同的功能，持续几个月的时间。如何同时管理几个版本 4. 如果管理一个分布在世界上各地且互不相识的大型开发团队 3.2 分布式版本控制工具 github是一个git项目托管网站，主要提供基于git的版本托管服务。 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-20 14:07:03 "},"git教程.html":{"url":"git教程.html","title":"git教程","keywords":"","body":" git是什么 git配置 git初始化 1、没有远程仓库 2、有远程仓库 git常用指令 工作区 冲突 git图形化界面 基本流程 liunx的界面命令 提交命令 查看所有文件命令 分支的命令 查看分支命令 创建分支命令 切换分支命令 合并分支模块 查看冲突命令 更改文件保存命令流程 部署GitHub云端去 Git Bash操作流程 1.搭建代码库 2.提交代码 3.增加远程地址 4.推送到远程库 5.真正生效到GitHub云端去 6、成功之后再推送命令 Git 分布式版本管理系统 git是什么 git(分布式版本控制器) 不需要联网，直接存到本地，上传远程仓库才需要联网 svn(集中式版本控制器) git配置 git config user.name (检查配置用户名) git config user.email (检查配置邮箱) git config --global user.name \"用户名\" （全局配置用户名） git config --global user.email \"邮箱\" （全局配置邮箱） git初始化 1、没有远程仓库 git init 2、有远程仓库 git clone 远程仓库地址 git常用指令 git status //检查当前本地git仓库的状体 git add . //把当前目录的所有文件和目录都管理起来 git commit -m \"存档描述\" //把当前管理的文件都进行存档 git log //打印日志，显示本地的存档和其他操作 git reset --hard 具体的id //回档操作，回到具体的某个存档 git reflog //打印所有操作日志，比git flog显示更多的内容 git clone 远程仓库地址 //克隆远程仓库地址到本地 git push //推送到远程仓库 git pull //拉取远程仓库最新的分支和代码合并到本地 git branch +分支名称 //创建分支命令 git branch -a //检查所有的本地和远程分支 git checkout xxx分支 //检出到具体某个分支上 切换分支命令 git merge +分支名 //合并分支模块 git branch -d xxx分支 //删除具体某个分支 git fetch --prune origin //删除本地的缓存信息 工作区 工作区 暂存区 本地仓库 远程仓库 未管理的区域 已管理的区域 已存档 远程存档 避免每次提交都需要输入账号密码 git 提交代码时每次都要输入用户名密码，执行下面的操作就不需要了 第一步：git config --global credential.helper store （保存用户名/密码） 第二步：正常git pull /git push 后输入用户名和密码 后续就不需要输入用户名和密码 冲突 当远程仓库和本地仓库不一致或者分支不一致时，就会出现冲突。 解决冲突：把本地的代码先提交到本地仓库，然后拉取远程的仓库，然后执行手动合并，最后再重新提交。 git图形化界面 使用命令行不方便操作也不够直观，图形界面就可以解决这个问题。 基本流程 Github教程 GitHub仓库地址：https://github.com/用户名/仓库名.git 终端操作流程 在管理员面板命令切换存盘：【d:】 转换到文件夹的路径下：cd +本地地址 liunx的界面命令 修改文档：LL 存储地址：cd 文件名/ 修改文件：vi 文件名 提交命令 git commit -m \"update 002【提交提示信息】\" 回退到2个版本之前的版本 git reset --hard HEAD~2 查看所有文件命令 git reflog 分支的命令 分支模块 查看分支命令 git branch -v 创建分支命令 git branch +分支名称 切换分支命令 git checkout +分支名 合并分支模块 先切换到主分支命令：git checkout master 合并命令：git merge +分支名 查看冲突命令 git diff 修改冲突首先进入liunx界面命令 v- +分支名称 更改文件保存命令流程 git add src/a.txt git commit -m \"update 004\" git log --pretty=oneline 部署GitHub云端去 git push -u origin master Git Bash操作流程 1.搭建代码库 1、git init 2、git config user.name \"用户名\" git config user.email \"真实邮箱\" 2.提交代码 1、git status 2、git add . 3、git commit -m 'first_commit[提示信息]' 3.增加远程地址 //git remote add 1、git remote add origin 【+GitHub上的库存地址】 4.推送到远程库 推送远程的分支【可选】 //git push 1、git push origin master 5.真正生效到GitHub云端去 这个好像是管理员命令里【✨这个是一次推送远端命令】 git push -u origin master 6、成功之后再推送命令 git push Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-20 23:41:06 "},"常用Git命令清单.html":{"url":"常用Git命令清单.html","title":"常用Git命令清单","keywords":"","body":" 一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、其他 常用 Git 命令清单 参考 我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他 # 生成一个可供发布的压缩包 $ git archive Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-20 14:09:03 "},"scss.html":{"url":"scss.html","title":"scss","keywords":"","body":" 一、scss是什么 二、scss版本问题 三、scss和sass有什么区别？ 四、变量 五、嵌套 六、导入scss文件 七、控制语句 scss 一、scss是什么 Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 二、scss版本问题 //npm版本 6.14.10 npm i npm@6.14.11 -g //sass-loader版本 8.0.2 npm i sass-loader@8.0.2 -D //node-sass 4.14.1 npm i node-sass@4.14.1 -D 三、scss和sass有什么区别？ sass是最早的名字，而且省略了大括号，导致可读性非常差 scss回归样式的规范，添加大括号 四、变量 $color:blue; .a{ width: 200px; height: 200px; background: $color; } .b{ width: 100px; height: 100px; background: $color; } //拼接字符 $color:blue; $width:200; .a{ width: ##{$width}px; height: 200px; background: $color; } 五、嵌套 .a { width: 100px; height: 100px; background: blue; //&是父选择器标识符 &:hover { background: red; } //属性嵌套 border: 1px solid ##000{ left: 5px solid ##000; right: 10px solid ##000; } } 六、导入scss文件 //引入其他的scss文件 @import \"@/css/index.scss\"; //使用他人提供的css文件的时候，可以把该文件改成scss文件，然后再引入 @import \"@/css/test.scss\"; //默认变量，使用!default做标识。 @import \"@/css/index.scss\"; $color:blue !default; .a{ width: 100px; height: 100px; background: $color; } 七、控制语句 //@if $num:3; .a{ @if $num == 1 { color: red; }@else if $num == 2{ color: blue; }@else{ color: green; } } //@for 循环数字（必须是正整数） @for $num from 1 through 5 {//1-5 .item##{$num}{ width: ##{$num*10}px; height: 20px; border: 1px solid; } } @for $num from 1 to 5 {//1-4 .item##{$num}{ width: ##{$num*10}px; height: 20px; border: 1px solid; } } //@each 循环数组 @each $color in blue,red,yellow { .item-##{$color}{ color:$color } } //@mixin和@include @mixin font-size($num:10) { font-size: ##{$num}px; } p{ color: red; @include font-size(); } a{ color: blue; @include font-size(); } span{ color: yellow; @include font-size(30); } //@extend .a{ color: blue; font-size: 20px; font-weight: bold; } .b{ color: red; @extend .a; } //@function @function getWidth($width){ @return $width + 10 } .a{ width: ##{getWidth(10)}px; height: 10px; background: red; } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-26 13:35:04 "},"01安装和配置文件.html":{"url":"01安装和配置文件.html","title":"01安装和配置文件","keywords":"","body":" 0、初始化npm 1、安装typescript 2、新建index.ts后缀文件 3、编译ts文件 4、自动编译ts文件 5、在package.json中配置 安装和配置文件 浏览器是识别不了ts，所以上线前ts会转换成js npx和npm有什么关系？ npx最新的npm语法 0、初始化npm npm init -y 1、安装typescript npm i typescript -D 2、新建index.ts后缀文件 let num: number = \"hello ts\"; console.log(num); 3、编译ts文件 tsc index.ts//mac npx tsc index.ts//windows 4、自动编译ts文件 vscode 使用命令行tsc –init 生成tsconfig.json配置文件 tsc --init//mac npx tsc --init//windows tsc –init 生成tsconfig.json配置文件，然后在终端运行 tsc -w tsc -w//mac npx tsc -w//windows 5、在package.json中配置 \"scripts\": { \"serve\":\"tsc -w\"} tsconfig.json配置文件 地址：官网TS { \"compilerOptions\": { \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES5' 'es2015' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"moduleResolution\": \"node\", // 选择模块解析策略 \"experimentalDecorators\": true, // 启用实验性的ES装饰器 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 \"sourceMap\": true, // 把 ts 文件编译成 js 文件的时候，同时生成对应的 map 文件 \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"alwaysStrict\": true, // 以严格模式检查模块，并在每个文件里加入 'use strict' \"declaration\": true, // 生成相应的.d.ts文件 \"removeComments\": true, // 删除编译后的所有的注释 \"noImplicitReturns\": true, // 不是函数的所有返回路径都有返回值时报错 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"lib\": [\"es6\", \"dom\"], // 指定要包含在编译中的库文件 \"typeRoots\": [\"node_modules/@types\"], \"outDir\": \"./dist\", //打包过的目录 \"rootDir\": \"./src\", //打代码的目录 \"baseUrl\": \".\", //基本地址为根目录 \"paths\":{ \"@/*\": [\"src/*\"] //路径别名 } }, \"include\": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题 \"./src/**/*.ts\" ], \"exclude\": [ \"node_modules\", \"dist\", \"**/*.test.ts\", ] } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 19:51:13 "},"02静态检查.html":{"url":"02静态检查.html","title":"02静态检查","keywords":"","body":"静态检查 ts只会在编译时进行静态检查， 如果有错误，会直接报错， 但是即使报错了，仍然会生成编译结果。 //index.ts function hello(person:string){ console.log(person) } hello(123) //index.js function hello(person) { console.log(person); } hello(123); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:05:10 "},"03类型推论.html":{"url":"03类型推论.html","title":"03类型推论","keywords":"","body":"类型推论 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 以下代码虽然没有指定类型，但是会在编译的时候报错 let str = 'hello'; str = 1; //相当于 let str:string = 'hello' str = 1 如果定义的时候没有赋值，不管后面有没有赋值，都会被推断为any类型 //正确 let str str = \"hello\" str = 1 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:06:44 "},"04原始数据类型.html":{"url":"04原始数据类型.html","title":"04原始数据类型","keywords":"","body":" 1、布尔值 2、数字 3、字符串 4、空值 5、undefined和null 6、symbol唯一值 7、对象 原始数据类型 原始数据类型包括：布尔值、数值、字符串、null、undefined、symbol 1、布尔值 let bool:boolean = true 注意，使用构造函数Boolean创造的对象不是布尔值 //错误 let bool:boolean = new Boolean(1) //正确 let bool:Object = new Boolean(1) //或 let bool:Boolean = new Boolean(1) 2、数字 let num:number = 1 3、字符串 let str:string = \"hello\" 4、空值 1) void可以表示函数没有任何返回值 function fn():void{ console.log(\"没有任何返回值\") } fn() 2) 也可以设置一个变量的类型为void，但是没有意义，只能赋值undefined和null let a:void = undefined 5、undefined和null let a:undefined = undefined let b:null = null 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： //正确 let num: number = undefined; //错误 let num: number = void; 6、symbol唯一值 let s1:symbol = Symbol(\"唯一值\") 7、对象 let obj:object = {} Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:27:49 "},"05any.html":{"url":"05any.html","title":"05any","keywords":"","body":"any 1) 任意值any用来表示允许赋值为任意类型 //不会报错 let num:any = 1 num = \"hello\" 2) 在任意值上访问任何属性和调用任何方法都是允许的 //不会报错 let num:any = 1 console.log(num.aaa) console.log(num.aaa.bbb) num.hello() 3) 变量在未指定类型的时候，默认为任意类型 let a a = \"hello\" a = 1 //等同于 let a:any a = \"hello\" a = 1 任意类型不能乱用，否则失去强制类型的意义。 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:29:52 "},"06unknown.html":{"url":"06unknown.html","title":"06unknown","keywords":"","body":"unknown unknown 是 TypeScript 3.0 引入了新类型,是 any 类型对应的安全类型。 let a:any a.name//正确 a.toString()//正确 a.b.c//正确 let a:unknown a.name//ERROR a.toString()//ERROR a.b.c//ERROR Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:30:52 "},"07never.html":{"url":"07never.html","title":"07never","keywords":"","body":"never never 类型表示的是那些永不存在的值的类型， never 类型是任何类型的子类型，也可以赋值给任何类型； 然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了never本身之外）， 即使any也不可以赋值给never。 使用场景 // 抛出异常的函数永远不会有返回值 function error(message: string): never { throw new Error(message); } // 空数组，而且永远是空的 const empty: never[] = [] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:32:57 "},"08数组.html":{"url":"08数组.html","title":"08数组","keywords":"","body":" 元组 多个类型在同一个数组里面 数组 数组的定义方式有两种 let arr:Array = [1,2,3] let arr:number[] = [1,2,3] 元组 元组类型与数组类型非常相似，表示一个已知元素数量和类型的数组，各元素的类型不必相同。 元组包含的元素必须与声明的类型一致，不能多不能少顺序不能不符。 let arr:[string,number] = [\"hello\",1]//正确 let arr:[string,number] = [1,\"hello\"]//错误 多个类型在同一个数组里面 let arr:Array = [1,\"小明\"] let arr2:(number|string)[] = [1,\"小明\"] Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-28 20:34:57 "},"09枚举类型.html":{"url":"09枚举类型.html","title":"09枚举类型","keywords":"","body":" 1、数字枚举 2、字符串枚举 3、异构枚举 4、反向映射 枚举类型 枚举类型是很多语言都拥有的类型,它用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型。 1、数字枚举 当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加。 enum color{ blue, red, green } console.log(color.blue === 0)//true console.log(color.red === 1)//true console.log(color.green === 2)//true 赋值第一个值之后，后面的值会进行累加 enum color{ blue = 10, red, green } console.log(color.blue)//10 console.log(color.red)//11 console.log(color.green)//12 2、字符串枚举 值也可以是字符串。 enum color{ blue = 'blue', red = 'red', green = 'green' } console.log(color.blue)//blue console.log(color.red)//red console.log(color.green)//green 3、异构枚举 值可以是不同类型的数据。 enum color{ blue = 0, red = 'red', green = 1 } console.log(color.blue)//0 console.log(color.red)//red console.log(color.green)//1 4、反向映射 enum color{ blue, red, green } console.log(color[0])//blue console.log(color[1])//red console.log(color[2])//green Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-01 19:17:24 "},"10函数.html":{"url":"10函数.html","title":"10函数","keywords":"","body":" 1、函数声明和函数表达式 2、用接口定义函数的形状 3、可选参数 4、默认参数 5、剩余参数 6、函数重载 函数 1、函数声明和函数表达式 //函数声明 function fn(x:number,y:number):number{ return x+y } fn(1,2) //函数表达式 let fn = function(x:number,y:number):number{ return x+y } fn(1,2) //注意，函数表达式这种写法只对等号右边的匿名函数进行类型定义，而等号左边的fn是通过赋值操作进行类型推断出来的。如果需要给左边的fn添加类型，需要这样写: let fn:(x:number,y:number)=>number = function(x:number,y:number):number{ return x+y } //在ts中，=>用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。而es6的=>是箭头函数。 2、用接口定义函数的形状 interface Fn{ (x:number,y:number):number; } let fn:Fn = function(x:number,y:number){ return x+y } fn(1,2) 3、可选参数 //可选参数必须在必选参数的后面 function fn(x:number,y?:number){ return x+y } fn(1) //练习 function fn(x:number,y?:number){ if(y){ return x+y }else{ return x } } console.log(fn(1)) 4、默认参数 function fn(x:number,y?:number,z:number=1){ return x+z } console.log(fn(1)) 5、剩余参数 //...items本质上是一个数组 function fn(a,...items:any[]){ console.log(a) console.log(items) } fn(1,2) 6、函数重载 java中方法的重载：重载指的是两个或者两个以上同名函数，但它们的参数不一样，这时会出现函数重载的情况。 typescript中的重载：通过为同一个函数提供多个函数类型定义来试下多种功能的目的。 ts为了兼容es5 以及 es6 重载的写法和java中有区别。 function fn(name:string):void; function fn(age:number):void; function fn(arg:any):void{ if(typeof arg === \"string\"){ console.log(\"字符串\") } if(typeof arg === \"number\"){ console.log(\"数字\") } } fn(\"小明\")//字符串 fn(18)//数字 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-01 19:44:13 "},"12接口.html":{"url":"12接口.html","title":"12接口","keywords":"","body":" 1、接口的使用 2、可选属性 3、只读属性 4、函数类型 5、可索引类型 6、继承接口 7、类继承接口 接口(interface) TypeScript 的核心原则之一是对值所具有的结构进行类型检查,它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 ==注意：接口只能作用于对象类型。== 1、接口的使用 比如，定义了一个fn函数，函数里面传一个对象，然后返回对象里面的属性。这个时候就会报错 const fn = (obj)=>obj.name 应该这样使用,使用接口去描述这个类型 interface Obj{ name:string age:number sex:string } const fn = (obj:Obj)=>obj.name //函数写法 interface Fn{ (num1:number,num2:number):number } let fn:Fn=function(num1:number,num2:number):number{ return num1+num2 } 2、可选属性 在使用接口去描述一个创建对象的时候，会发现，对象的属性必须跟接口一模一样，多了或少了都不行 interface Obj{ name:string age:number sex:string } let o:Obj = { name:\"小明\", age:18, sex:\"男\" } 但有时候需要某个值为可选属性【这里加?就有可选功能】 interface Obj{ name:string age:number sex?:string//这里的sex是指即可以是字符串，也可以是undefined } let o:Obj = { name:\"小明\", age:18, } ==这样，o对象没有sex属性也不会报错。== 3、只读属性 添加只读属性后，无法修改 interface Obj{ name:string readonly age:number } let o:Obj = { name:\"小明\", age:18, } o.age = \"18\"//无法分配到\"age\"，因为它是只读属性 4、函数类型 接口可以用来描述函数类型。函数属于对象类型。 interface Fn{ (arg:string):string } let fn:Fn = (arg:string):string=>{ return arg } 5、可索引类型 可索引类型是指一个对象里面的字段可以索引，一般用于描述对象和数组类型 //描述数组类型，idx代表索引的意思，可改成任意变量。左边的number代表索引类型是数字类型。右边的number代表值为number类型。 interface Arr{ [idx:number]:number } let arr:Arr = [1,2,3] //描述对象类型，对象也是可以用索引描述的类型。左边的string代表key的类型是字符串，在这里为name。右边的string代表值为string类型。 interface Obj{ [key:string]:string } let obj:Obj = {name:\"小明\"} //复用性 可以用于多个对象的属性复用 interface Obj{ name:string; age:number; sex:string; [key:string]:string|number; } let obj:Obj = { name:\"小明\", age:18, sex:\"男\", hobby:\"篮球\", address:\"黄村\", height:180 } let obj2:Obj = { name:\"小红\", age:19, sex:\"女\", } //练习 //数组字符串接口 interface Arr{ [idx:number]:number|string//复用性 可以用于多个对象的属性复用 } let arr:Arr=[1,2,3,4,\"5\"] 6、继承接口 interface Animal{ name:string call:()=>void } interface Person extends Animal{ age:number sex:string } let p:Person = { name:\"小明\", age:18, sex:\"男\", call:()=>console.log(\"呵呵\") } //练习 //接口继承 interface Animal{ name:string } interface Cat extends Animal{ age:number } let c:Cat={ name:\"张三\" age:18 } 7、类继承接口 interface Animal{ name:string; } class Person implements Animal{ //name!:string; //加【!】就不用谢构造函数 name:string; constructor(name:string){ this.name = name } } let c = new Cat(\"张三\") console.log Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-12 17:18:55 "},"13联合类型&交叉类型.html":{"url":"13联合类型&交叉类型.html","title":"13联合类型&交叉类型","keywords":"","body":" 1、联合类型 表示取值可以为多种类型中的一种。 2、交叉类型 表示取值为多种类型的全部情况 3、类型别名 联合类型&交叉类型 1、联合类型 表示取值可以为多种类型中的一种。 let a:number|string a = 1 a = \"hello\" //或 function fn(arg:string | number){ console.log(arg) } fn(\"hello\") fn(1) //练习 let a:number | string = \"1\" let arr:Array=[1,\"1\"] //数组 function fn(arg:Array|number){ //函数 } 2、交叉类型 表示取值为多种类型的全部情况 interface a{ name:string age:number } interface b{ sex:string age:number } let obj:a&b = {name:\"小明\",age:18,sex:\"男\"} //练习 interface Person { name: string; } interface Student { age: number; } let a: Person & Student = { name: '张三', age: 18 }; 3、类型别名 类型别名就是自定义类型 type x = number | string let a:x = 1//ok let b:x = \"1\"//ok let c:x = true//error //练习 type Person = { name: string; age: number; }; let p: Person = { name: '张三', age: 18 }; 案例 用type来定义数组 //表示数组的值即可以是字符串也可以是数字 type Arr = (string|number)[] let arr:Arr = [1,\"2\",3] 用type来定义对象 type Obj = {name:string,age?:number,readonly sex?:string} let obj:Obj = {name:\"小明\",sex:\"男\"} obj.sex = \"女\"//报错，不能修改 用type来定义函数 type Fn = (arg:number)=>number let fn:Fn = function(arg:number):number{ return arg } console.log(fn(1)) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 14:07:36 "},"14泛型.html":{"url":"14泛型.html","title":"14泛型","keywords":"","body":" 1、定义泛型 2、多个类型参数 3、泛型变量 4、泛型接口 5、泛型类 6、泛型约束 7、泛型约束与索引类型 8、多重类型约束 9、约束为构造函数 泛型 泛型可以用来创建可重用的组件，一个组件可以支持多种类型的数据。 1、定义泛型 //这里的T可以传入任何类型数据,并返回相同的类型数据，相当于一个变量 function fn(arg:T):T{ return arg } //练习 function fn(arg: T): T { return arg; } console.log(fn('hello 泛型')); 2、多个类型参数 //这里定义了两个不同的类型参数T、U，返回的值为U类型 function fn(arg:T,arg2:U):U{ return arg2 } //练习 function fn(arg: T, arg2: U): U { return arg2; } //console.log(fn(1, '2')); //2 console.log(fn('1', 2)); //2 3、泛型变量 如果我们想传入一个数组，然后再函数里面打印数组的长度会显示报错，因为ts无法判断T类型有没有length属性 function fn(arg:T){ console.log(arg.length)//类型T不存在length属性 } 这个时候我们可以把T类型作为数组的一部分 function fn(arg:Array){ console.log(arg.length)//不报错 } //练习 function fn(arg: Array): void { console.log(arg.length); } 4、泛型接口 interface Fn{ (arg:T):T } const fn:Fn = (arg)=>arg //这里把number传入接口当成参数使用 //练习 interface Fn { (arg: T): T; } let f: Fn = function(arg) { return arg; }; console.log(f(1)); 5、泛型类 泛型同样可以运用在类上。 class Arr{ private arr:number[] = []//arr属性为一个空数组，类型是全部数字的数组 public push(item:number){ this.arr.push(item) } } 使用泛型。 class Arr{ private arr:T[] = []//arr数组里面的类型可以是任意的 public push(item:T){ this.arr.push(item) } } //练习 class Person { constructor(name: T) { this.name = name; } name: T; } // let p = new.Person(123); let p = new Person('泛型-字符串'); console.log(p.name); 6、泛型约束 可以使用extends来约束泛型 function fn(arg:T){ console.log(arg) } fn(1)//这里的参数只可以使用number或者是string类型 //练习 function fn(arg: T) { console.log(arg); } fn('字符串'); fn(123); // fn(true) //这里就报错了 7、泛型约束与索引类型 假如传入一个对象，再传入一个key，最后打印出这个对象的value值 function fn(obj:object,key:string){ console.log(obj[key])//无法确定obj是否有key属性 } 应该这样做 //T被约束为对象类型，U被约束为T的字段 function fn(obj:T,key:U){ console.log(obj[key])//ok } let obj = {name:\"小明\",age:18} fn(obj,\"name\") //练习 // let obj{//代表【T】 // name:\"\"//代表【U】 // } function fn(obj: T, key: U) { console.log(obj[key]); } 8、多重类型约束 使用&和|对泛型进行约束 interface a{ name:string } interface b{ age:number } function fn(arg:T){ console.log(arg) } fn({name:\"小明\",age:18})//必须同时符合a和b两种接口 interface a{ name:string } interface b{ age:number } function fn(arg:T){ console.log(arg) } fn({name:\"小明\"})//只需要符合a或者b其中一个即可 //练习 interface Person { name: string; } interface Student { age: number; } function fn(arg: T): void { console.log(arg); } fn({ name: '张三', age: 18 }); 9、约束为构造函数 function fn(type:T):T{ return new type()//不可构造 } 正确做法 //写法1 function fn(type:{new ():T}):T{ return new type() } class Person{ public name:string = \"小明\" } fn(Person) //写法2 function fn(arg:{new(U:string):T}):void{ console.log(new arg(\"小红\")) } class Person{ constructor(name:string){ this.name = name } name:string } fn(Person) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 15:06:16 "},"15类型断言.html":{"url":"15类型断言.html","title":"15类型断言","keywords":"","body":" 1、将一个联合类型断言为其中一种 2、将一个父类断言为更加具体的子类 3、将任何一个类型断言为any 4、将any断言为一个具体的类型 5、类型守卫 类型断言 类型断言可以用来手动指定一个值的类型。 ==语法== 值 as 类型（推荐） //或 值 1、将一个联合类型断言为其中一种 //val的联合类型为number和string，而number类型并没有length属性，所以直接使用会报错 function fn(val:number|string){ console.log(val.length) } fn(\"hello\") //这时候将val断言为string就可以解决 function fn(val:number|string){ console.log((val as string).length) } fn(\"hello\") 注意，断言只能欺骗ts编译器，并不能避免运行时的错误 //断言并不能把number类型的123转为string的123，所以下列代码在运行的时候是错的 function fn(val:number|string){ console.log((val as string).length) } fn(123) //练习 function fn(arg: string | number) { console.log((arg as string).length); } fn(\"hello\")//hello fn(1);//undefined //因为数字1没有length了 2、将一个父类断言为更加具体的子类 //由于Person没有study属性，故直接通过p.study调用会报错 class Person{} class Student extends Person{ study:string = \"学习\" } class Teacher extends Person{ work:string = \"工作\" } function fn(p:Person){ console.log((p as Student).study) } fn(\"小明\") 3、将任何一个类型断言为any //如果直接给window赋值aaa是错误的，因为window上没有aaa这个属性 window.aaa = 1 //解决办法是把window断言为any类型 (window as any).aaa = 1 4、将any断言为一个具体的类型 //可精确的提高代码的具体类型，以提高代码维护性 function fn():any{ return \"hello\" } let str = fn() as string console.log(str) 5、类型守卫 可通过instanceof、in等进行类型守卫。 1、instanceof一般用于判断类 class Teacher{ work(){ console.log(\"工作\") } } class Student{ study(){ console.log(\"学习\") } } function fn(arg:Teacher|Student){ if(arg instanceof Teacher){//类型守卫 arg.work() }else{ arg.study() } } fn(new Teacher()) 2、in判断类或者对象里面是否有某个属性 interface p1{ name:string } interface p2{ age:number } function fn(arg:p1 | p2){ if(\"name\" in arg){ console.log(\"p1\") }else{ console.log(\"p2\") } } fn({name:\"小明\"})//p1 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 15:38:08 "},"16命名空间.html":{"url":"16命名空间.html","title":"16命名空间","keywords":"","body":"命名空间 命名空间里面的方法或者类需要export暴露出来，否则外部无法使用 namespace A{ export class Person{ constructor(name:string){ this.name = name } name:string; } } console.log(new A.Person(\"小明\")) namespace B{ export class Person{ constructor(name:string,age:number){ this.name = name this.age = age } name:string; age:number } } console.log(new B.Person(\"小红\",18)) 输出和引入命名空间 //index.ts export namespace A{ export class Person{ constructor(name:string){ this.name = name } name:string; } } //other.ts import {A} from \"./index\" new A.Person(\"小明\") Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 15:58:12 "},"17声明文件.html":{"url":"17声明文件.html","title":"17声明文件","keywords":"","body":" 1、声明语句 2、声明文件 声明文件 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 1、声明语句 当我们使用第三方库比如jquery的时候，ts并不知道$或者jquery是什么 console.log($(\"body\")) error TS2304: Cannot find name '$'. 这时候我们需要使用declare let来定义它的类型 //正确 //declare let并没有真正定义一个变量，只是定义了全局变量jquery的类型，仅仅用于编译时的检查，在编译结果中会被删除。 declare let $:(selector:string)=>any; console.log($(\"body\")) 2、声明文件 把声明语句放到一个单独的文件（filename.d.ts）中，就是声明文件。 一般常见的库都有定义好的声明文件，不需要我们自己定义。比如：jquery 当然，最好的方式是使用@types统一管理第三方库的声明文件。例如： npm i @types/jquery -D 所有的第三方库声明文件在这里查看 https://www.typescriptlang.org/dt/search?search= Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 16:01:09 "},"18装饰器.html":{"url":"18装饰器.html","title":"18装饰器","keywords":"","body":" 1、类装饰器 2、属性装饰器 3、方法装饰器 案例 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。简单的说装饰器就是一种非侵入式修改。 在TypeScript中装饰器还属于实验性语法，你必须在命令行或tsconfig.json里启用。 { \"experimentalDecorators\": true} 1、类装饰器 function fn(target:Function){ target.prototype.name = \"小明\" } @fn class Person { public name!:string//这里的叹号指得是name的值非null、非为定义。 } let p = new Person() console.log(p.name)//小明 //传参数写法 function fn(name:string){ // return function(target:any){} //这是function写法 return (target:Function)=>{ target.prototype.name = name } } @fn(\"小红\") class Person { public name!:string } let p = new Person() console.log(p.name)//小红; //可用于重写构造函数 function fn(target:any){ return class extends target{ name = \"小红\" } } @fn class Person{ constructor(){ this.name= \"小明\" } name:string } let p = new Person() console.log(p)//小红 2、属性装饰器 function fn(params:any){ return function(target:any,name:any){ // console.log(params) 参数 // console.log(target) 对象原型 // console.log(name) 属性名 target.name = params } } class Person{ @fn(\"小明\") name:string | undefined } let p = new Person() console.log(p.name)//小明 3、方法装饰器 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。 //方法装饰器一共有3个参数，第一个参数在不同的方法上是不一样的。 //对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 function fn(target:any,key:any,descriptor:any){ console.log(target) } class Person{ @fn//p.__proto__ sayHello(){//实例方法 } @fn//p.constructor static sayHi(){//静态方法 } } let p = new Person() //第二个参数key是方法名字 function fn(target:any,key:any,descriptor:any){ console.log(key) } class Person{ @fn//sayHello sayHello(){ } @fn//sayHi static sayHi(){ } } //第三个参数是属性修饰对象 function fn(target:any,key:any,descriptor:any){ console.log(descriptor) } class Person{ //writable是否可以重写，enumerable是否可以枚举，configurable是否可以配置 @fn//{\"writable\":true,\"enumerable\":true,\"configurable\":true} sayHello(){ } @fn//{\"writable\":true,\"enumerable\":true,\"configurable\":true} static sayHi(){ } } 案例 //改写方法 function fn(target: any, name: any, descriptor: any) { descriptor.value = ()=>{ console.log(\"hehe\") } } class Person { @fn sayHello() { console.log(\"hello\") } } let p = new Person() p.sayHello()//hehe //设置方法为不可修改 function fn(target: any, name: any, descriptor: any) { descriptor.writable = false } class Person { @fn sayHello() { console.log(\"hello\") } } let p = new Person() p.sayHello = function(){//报错，不可以修改 console.log(\"hehe\") } p.sayHello() Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-03-13 16:35:33 "},"phase03.html":{"url":"phase03.html","title":"Phase III","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"vue.html":{"url":"vue.html","title":"Vue","keywords":"","body":"Vue框架 [success] Js框架 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的mvvm渐进式js框架。 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 22:22:38 "},"01mvvm和mvc.html":{"url":"01mvvm和mvc.html","title":"01mvvm和mvc","keywords":"","body":"mvvm和mvc //mvc（后端） m model 数据模型 数据库 v view 视图 标签 c control控制器 逻辑代码 //mvvm（前端） m model 数据模型 在vue里面指代data，数据存储的地方 v view 视图 在vue里面指代html标签，数据渲染的地方 vm view-model 视图模型 在vue里面指的的是vue本身，帮我们把数据从数据存储的地方转到数据渲染的地方进行渲染 %accordion% js&vue %accordion% //vue和jq有什么区别 1、vue是数据驱动，jqdom驱动 2、Vue =双向数据绑定 %/accordion% Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:22 "},"04生命周期.html":{"url":"04生命周期.html","title":"04生命周期","keywords":"","body":"生命周期 beforeCreate 创造之前 created 创造完毕 beforeMount 安装之前(渲染之前) mounted 渲染完毕 beforeUpdate 更新前 updated 更新后 beforeDestroy销毁之前 destroyed 销毁之后 activated 激活被缓存的组件 deactivated 取消激活 errorCaptured 错误捕捉 [!cogs] %accordion%必记🚀%accordion% new Vue({ beforeCreate() { console.log(\"创造之前\"); }, created() { console.log(\"创造之后\"); }, beforeMount() { console.log(\"安装之前/渲染之前\"); }, mounted() { console.log(\"渲染完毕\"); }, beforeUpdate() { console.log(\"更新前\"); }, updated() { console.log(\"更新后\"); }, beforeDestroy() { console.log(\"销毁之前/死掉之前\"); }, destroyed() { console.log(\"销毁之后/死掉之后\"); }, activated() { console.log(\"激活被缓存的组件\"); }, deactivated() { console.log(\"取消激活\"); }, errorCaptured() { console.log(\"错误捕捉\"); } }) %/accordion% 创造和渲染有什么区别？ 创造是vue实例化的过程，渲染是实例化完之后把数据渲染在页面上的过程。 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:25 "},"05指令.html":{"url":"05指令.html","title":"05指令","keywords":"","body":" v-html 渲染标签 v-bind 绑定属性 v-if 是否渲染标签 v-show是否显示标签 v-for 迭代数组和对象 1、迭代数组 2、迭代对象 3、v-for和v-if的优先级问题 v-on 事件 v-model 双向数据绑定 指令的参数和修饰符 指令 指令就是vue提供给我们的一些快捷操作的代码。 v-html 渲染标签 //渲染标签 new Vue({ el:\"##app\", data:{ msg:\"内容\" } }) new Vue({ el:\"##app\", data:{ msg:` 1 2 ` } }) %accordion% 解说 %accordion% 后台管理系统(B端) 商品的增加、减少、更新 存后端（接口、服务器、数据库、）后端 后台界面 后端/前端 客户端界面（c端）前端 %/accordion% [!cogs] 记得引入哦： %accordion% 练习🚀 %accordion% 1 new Vue({ el: \"#app\", data: { element: \"\", }, }) new Vue({ el: \"#app\", data: { element: ` 1 2 `, }, }) %/accordion% v-bind 绑定属性 //简写 new Vue({ el:\"##app\", data:{ msg:\"a\" } }) new Vue({ el:\"##app\", data:{ bool:true } }) %accordion% 练习💢 %accordion% 3 // // //简写 new Vue({ el: \" #app\", data: { className: \"a\", bool: false, }, }) %/accordion% v-if 是否渲染标签 显示与消失是整个原生显示和销毁。 内容 new Vue({ el:\"##app\", data:{ bool:false } }) 内容1 内容2 new Vue({ el:\"##app\", data:{ bool:false } }) 内容1 内容2 内容3 new Vue({ el:\"##app\", data:{ msg:3 } }) v-show是否显示标签 v-show的切换开销会更小，而v-if会更多 内容1//在标签上添加display:none 内容1//整个标签消失 new Vue({ el:\"##app\", data:{ bool:false } }) %accordion% 解说🚀 %accordion% 重会与回流 样式对元素的设置的计算 计算消耗 v-if更大 v-show更小 反复渲染的情况下，建议用v-show 如果是少量渲染的情况下，建议用v-if 插件： vetur——vue2 volar——Vue3 %/accordion% [success] 必记 v-if:首次渲染开销更小，反复渲染开销大 v-show:首次渲染开销更大，反复渲染开销小 %accordion% v-if与v-show %accordion% 内容 //这种直接在元素中消失界面也消失 内容 //这种元素还在但是界面是看不见了 ✨ new Vue({ el: \" #app\", data: { bool: false, }, }) %/accordion% %accordion% 练习💢 %accordion% 内容1 内容2 内容3 new Vue({ el: \" #app\", data: { num: 3, //内容3 }, }) %/accordion% v-for 迭代数组和对象 1、迭代数组 //item是数组成员，idx是索引值 { {idx} }{ {item} } new Vue({ el:\"##app\", data:{ arr:[\"小明\",\"小红\",\"小黄\"] } }) { {item.cityName} } new Vue({ el: \"##app\", data: { arr: [ { countryName: \"中国\", cities: [ { cityName: \"广州\" }, { cityName: \"北京\" }, { cityName: \"上海\" }, ], }, { countryName: \"美国\", cities: [ { cityName: \"纽约\" }, { cityName: \"华盛顿\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cities: [ { cityName: \"东京\" }, { cityName: \"北海道\" }, { cityName: \"大阪\" }, ], }, ], }, }); 2、迭代对象 { {idx} }{ {key} }{ {val} } new Vue({ el: \"##app\", data: { obj:{ name:\"小明\", age:18, sex:\"男\" } }, }); 3、v-for和v-if的优先级问题 //vue2 v-for的权重高于v-if //vue3 反过来 //所以不能把v-for和v-if写在同一个元素上 { {item.name} } new Vue({ el: \"##app\", data: { arr: [ { bool: true, name: \"小明\" }, { bool: false, name: \"小红\" }, { bool: true, name: \"小黄\" }, ], }, }); [!cogs] %accordion% v-for %accordion% { {idx} }{ {item} } { {idx} }{ {val} }{ {key} } new Vue({ el: \" #app\", data: { arr: [\"张三\", \"李四\", \"老王\"], obj: { name: \"张三\", age: \"李四\", sex: \"男\" }, }, }) %/accordion% %accordion% 练习 %accordion% { { item.cityName } } { { item.countryName } } new Vue({ el: \"#app\", data: { arr: [ { countryName: \"中国\", cities: [ { cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"上海\" }, ], }, { countryName: \"美国\", cities: [ { cityName: \"华盛顿\" }, { cityName: \"纽约\" }, { cityName: \"洛杉矶\" }, ], }, { countryName: \"日本\", cities: [ { cityName: \"东京\" }, { cityName: \"大阪\" }, { cityName: \"北海道\" }, ], }, ] } }) %/accordion% v-on 事件 内容 //简写。事件对象是$event 内容 new Vue({ el: \"##app\", data: { }, methods: {//存放方法的地方 fn(e){ console.log(e.target) } }, }); { {item} } new Vue({ el: \"##app\", data: { arr:[1,2,3,4,5] }, methods: { fn(item,idx){ console.log(idx) } }, }); [!cogs] %accordion% 练习@click %accordion% 按钮 按钮 new Vue({ el: \"#app\", data: {}, methods: { //存放方法 fn(e) { console.log(e); }, }, }) %/accordion% %accordion% 运用@click %accordion% { {item} } new Vue({ el: \"#app\", data: { arr: [\"张三\", \"李四\", \"老王\"], }, methods: { //存放方法 fn(item) { console.log(item); }, }, }) %/accordion% v-model 双向数据绑定 对表单元素进行双向的数据绑定 { {msg} } new Vue({ el: \"##app\", data: { msg:\"123\" } }); v-mode其实是一个语法糖，等价于下面的代码 { {msg} } new Vue({ el: \"##app\", data: { msg:\"\" }, methods: { fn(e){ this.msg = e.target.value } }, }); //单选 男 女 { {sex} } new Vue({ el: \"##app\", data: { sex:\"男\" } }); 钓鱼 吃鱼 杀鱼 { {hobby} } new Vue({ el: \"##app\", data: { hobby:[] } }); 广州 深圳 东莞 { {city} } new Vue({ el: \"##app\", data: { city:\"\" } }); [success] 面试题问 ✨ 双向数据绑定原理，指的是data在标签上面的渲染 ​ 而不是 v-model 他只是个指令而已 { {msg} } new Vue({ el: \"#app\", data: { msg: \"\", }, }) [!cogs] %accordion% 语法糖 %accordion% { {msg} } //语法糖 new Vue({ el: \"#app\", data: { msg: \"\", }, methods: { fn(e) { this.msg = e.target.value } }, }) %/accordion% 指令的参数和修饰符 //:click是参数 //.prevent是修饰符 提交 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:27 "},"06方法-计算属性-监听器.html":{"url":"06方法-计算属性-监听器.html","title":"06方法-计算属性-监听器","keywords":"","body":" 方法 计算属性 监听器 默认监听 深度监听 练习 方法、计算属性、监听器 方法 存放函数的地方 { {msg} } //语法糖 new Vue({ el: \"#app\", data: { msg: \"\", }, methods: { fn1() { console.log(123); }, fn2() { this.fn1(); }, }, created() { this.fn2(); }, }); 计算属性 { {myreverse} } new Vue({ el: \"#app\", data: { msg:\"hello world\" }, computed:{//计算属性 myreverse(){ return this.msg.split(\"\").reverse().join(\"\") } } }); [!cogs] %accordion% 🚀 %accordion% { {reverse} } new Vue({ el: \"#app\", data: { msg: \"hello world\", }, computed: { reverse() { //console.log(this.msg.split(\"\")); //(11) [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"] //console.log(this.msg.split(\"\").reverse(\"\")); //(11) [\"d\", \"l\", \"r\", \"o\", \"w\", \" \", \"o\", \"l\", \"l\", \"e\", \"h\"] return this.msg.split(\"\").reverse(\"\").join(\"\")//dlrow olleh }, }, }) %/accordion% 计算属性get、set写法 姓： 名： 全名： new Vue({ el: \"#app\", data: { firstName:\"\", lastName:\"\", }, computed:{//计算属性 // fullName(){ // return this.firstName + this.lastName // } fullName:{ get(){//获取，跟不写是一样的，这里的作用只是为了引申出set return this.firstName + this.lastName }, set(newVal){//修改 console.log(newVal)//返回新的fullName } } } }); %accordion% 练习🚀%accordion% new Vue({ el: \"#app\", data: { msg: \"hello world\" }, computed: { reverse: { get() { //get属性没有任何意义，只有为了引申出后面的set return this.msg.split(\"\").reverse().join(\"\") }, set(newVal) { console.log(newVal); } } } }) %/accordion% 监听器 当data数据发生变化的时候，返回变化的数据 { {msg} } new Vue({ el: \"#app\", data: { msg:\"\" }, watch:{ msg(newVal,oldVal){ console.log(newVal)//新的值 console.log(oldVal)//旧的值 } } }); 默认监听 { {msg} } new Vue({ el: \"#app\", data: { msg:\"123\" }, watch:{ msg:{ handler(newVal){//句柄，无任何含义，目的只是为了引申出后面的属性 console.log(newVal)//新的值 }, immediate:true//默认监听 } } }); %accordion% 练习🚀 %accordion% new Vue({ el: \"#app\", data: { num: 1, }, watch: { num(newVal) { console.log(newVal); } } }) %/accordion% 深度监听 new Vue({ el: \"#app\", data: { msg:{ name:\"小明\" } }, watch:{ msg:{ handler(newVal){//句柄，无任何含义，目的只是为了引申出后面的属性 console.log(newVal)//新的值 }, immediate:true,//默认监听 deep:true//深度监听（用于监听引用类型数据） } } }); %accordion% 练习🚀 %accordion% new Vue({ el: \"#app\", data: { obj: { name: \"张三\", }, }, watch: { obj: { handler(newVal) { //句柄，没有任何含义，为了引申出后面的属性 console.log(newVal); }, immediate: true, //默认监听 deep: true, //深度监听，可以监听对象类型数据 }, }, }); %/accordion% 练习 1、做一个城市二级联动功能 2、购物车功能 1)购买数量需要大于等于1的正整数 2)小计功能 3)商品总计，勾选的才计算 4)当所有的勾选框都有勾选的时候，最顶部的勾选框要显示勾选 5)全选功能/反选功能 6)商品价钱、数量、小计要做排序功能 Document ==请求选择国家== { {item.countryName} } ==请求选择城市== { {item.cityName} } \"> new Vue({ el: \"#app\", data: { country:\"\", cities:[], arr: [ { countryName: \"中国\", cities: [ { cityName: \"广州\" }, { cityName: \"东莞\" }, { cityName: \"佛山\" }, ], }, { countryName: \"美国\", cities: [ { cityName: \"洛杉矶\" }, { cityName: \"纽约\" }, { cityName: \"华盛顿\" }, ], }, { countryName: \"日本\", cities: [ { cityName: \"东京\" }, { cityName: \"大阪\" }, { cityName: \"北海道\" }, ], }, ], }, watch:{ country(newCountry){ let newCities = [] this.arr.forEach((item)=>{ if(item.countryName === newCountry){ newCities = item.cities } }) this.cities = newCities } } }); Document 商品名称 商品价格 上 下 商品数量 商品小计 { {item.name} } { {item.price} } { {item.price * item.num} } 总计:{ {allTotal} } \"> new Vue({ el: \"#app\", data: { arr: [ { name: \"苹果13\", price: 5000, num: 1, isChecked: true }, { name: \"华为p50\", price: 6000, num: 2, isChecked: true }, { name: \"小米14\", price: 7000, num: 3, isChecked: true }, ], }, methods: { changeNum(num, idx) { //改变数量 let n = Number(num); if (n >= 1 && Number.isInteger(n)) { this.arr[idx].num = n; } else { this.arr[idx].num = 1; } }, priceUp(){//价格由小到大排序 this.arr.sort((a,b)=>{ return a.price - b.price }) }, priceDown(){//价格由大到小排序 this.arr.sort((a,b)=>{ return b.price - a.price }) } }, computed: { allTotal() { //总计 let sum = 0; this.arr.forEach((item) => { if (item.isChecked) { sum += item.price * item.num; } }); return sum; }, allChecked: { //全选 get() { return this.arr.every((item) => { return item.isChecked; }); }, set(newVal) { if(newVal){ this.arr.map((item)=>{ item.isChecked = true }) }else{ this.arr.map((item)=>{ item.isChecked = false }) } }, }, }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:29:18 "},"07class和style绑定.html":{"url":"07class和style绑定.html","title":"07class和style绑定","keywords":"","body":" class绑定 style绑定 练习 class和style绑定 class绑定 new Vue({ el: \"#app\", data: { bool:false, } }); %accordion% 练习🚀 %accordion% 打印：class=\"a\" 打印：为false:a，为true的时候打印：class=\"a b\" new Vue({ el: \"#app\", data: { isClass: true, //true:出现a,b false:出现a } }) %/accordion% style绑定 //vue自动帮我们添加了浏览器前缀，所以不需要写浏览器前缀 内容 new Vue({ el: \"#app\", data: { abc:\"red\" } }); %accordion% 练习💢 %accordion% 这种给文字添加颜色 这种给文字和背景添加颜色 new Vue({ el: \"#app\", data: { abc: \"yellow\", } }); %/accordion% 练习 使用vue做一个选项卡效果 { {item} } { {item} } new Vue({ el: \"#app\", data: { current:0, title:[\"标题一\",\"标题二\",\"标题三\"], content:[\"123\",\"456\",\"789\"] }, methods: { changeTitle(idx){ this.current = idx } } }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:29:53 "},"08条件渲染.html":{"url":"08条件渲染.html","title":"08条件渲染","keywords":"","body":"条件渲染 条件渲染的时候，vue会尽可能的复用元素以降低切换开销。 切换 账号 密码 new Vue({ el: \"#app\", data: { bool:true } }); 但有时候我们可能并不想要vue复用这个元素，这时候我们就可以给原生加上key做为标记，让vue不再复用。 切换 账号 密码 new Vue({ el: \"#app\", data: { bool:true } }); 这里的div会占空间，这时候我们可以换成template标签。 切换 账号 密码 练习 %accordion% 练习🚀 %accordion% 切换按钮 账号 密码 账号 密码 new Vue({ el: \"#app\", data: { bool: true, } }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:34 "},"09列表渲染.html":{"url":"09列表渲染.html","title":"09列表渲染","keywords":"","body":" 数组的更新检测 对象更新检测 列表过滤 1、计算属性过滤器 2、函数过滤器 练习 列表渲染 跟条件渲染一样，列表渲染也会尽可能的复用元素，所以也是使用key来避免复用。 { {item.name} } new Vue({ el: \"#app\", data: { arr:[{id:\"9527\",name:\"小明\"},{id:\"7788\",name:\"小红\"}] } }); %accordion% 练习🚀 %accordion% { {item} } new Vue({ el: \"#app\", data: { // arr: [1, 2, 3], arr: [\"我是div1\", \"我是div2\", \"我是div3\"], } }) %/accordion% 数组的更新检测 因为vue2内部使用了Object.definePrototype方法的原因，直接控制数组的成员来修改，是无法让标签同步渲染的。 按钮 { {item} } new Vue({ el: \"#app\", data: { arr:[1,2,3,4,5] }, methods: { change(){ this.arr[5] = \"x\"//无效 this.arr.push(\"x\")//有效，需要使用数组变异方法。 this.$set(this.arr,5,\"x\")//有效，$set是Vue内部提供的更改数组和对象的方法。 //this.$set(修改哪个数据,修改第几个成员,修改成什么) } }, }); %accordion% 练习🚀 %accordion% 按钮 { {item} } new Vue({ el: \"#app\", data: { // arr: [1, 2, 3], //也给这样哦 arr: [\"我是div1\", \"我是div2\", \"我是div3\"], }, //添加方法 methods: { add() {//点击方法 this.$set(this.arr, 3, \"点击我才能出现哦\") } }, }) %/accordion% 对象更新检测 与数组一样，对象也是无法直接更新同步的。 按钮 { {value} } new Vue({ el: \"#app\", data: { obj:{name:\"小明\",age:18,sex:\"男\"} }, methods: { change(){ this.obj.hobby = \"打游戏\"//无效 this.$set(this.obj,\"hobby\",\"打游戏\")//有效 this.obj = Object.assign({},this.obj,{//可以同时修改多个属性 hobby:\"打游戏\", address:\"黄村\" }) } }, }); 列表过滤 1、计算属性过滤器 { {item} } new Vue({ el: \"#app\", data: { arr:[1,2,3,4,5] }, computed:{ filterArr(){//计算属性的过滤器 return this.arr.filter((item)=>{ return item % 2 === 0 }) } } }); 2、函数过滤器 { {item} } new Vue({ el: \"#app\", data: { arr:[1,2,3,4,5] }, methods: { filterArr(arr){ return arr.filter((item)=>{ return item % 2 === 0 }) } }, }); 练习 数组的每个成员进行增、删、改 按钮 { {item} } new Vue({ el: \"#app\", data: { arr:[{name:\"小明\",age:18},{name:\"小红\",age:19},{name:\"小黄\",age:20}] }, methods: { change(){ this.arr.map((item)=>{//增 this.$set(item,\"sex\",\"男\") }) this.arr.map((item)=>{//改 this.$set(item,\"age\",16) }) this.arr.map((item)=>{//删 this.$delete(item,\"age\") }) } }, }); %accordion% 错误写法🚀 %accordion% 按钮 { {obj} } new Vue({ el: \"#app\", data: { obj: { name: \"张三\", age: 18 } }, //添加方法 methods: { add() {//点击方法 //错误写法 this.obj.ag = 18 console.log(this.obj); }, }, }); %/accordion% %accordion% 修改单个属性😀 %accordion% 按钮 { {obj} } new Vue({ el: \"#app\", data: { obj: { name: \"张三\", age: 18 } }, //添加方法 methods: { add() {//点击方法 //修改单个属性 this.$set(this.obj, \"age\", 666) this.$set(this.obj, \"sex\", \"男\") }, }); %/accordion% %accordion% 修改多个属性😂 %accordion% 按钮 { {obj} } new Vue({ el: \"#app\", data: { obj: { name: \"张三\", age: 18 } }, //添加方法 methods: { add() {//点击方法 //修改多个属性 this.obj = Object.assign({}, this.obj, { age: 666, sex: \"男\", }); }, }, }); %/accordion% %accordion% 删除属性🤣 %accordion% 按钮 { {obj} } new Vue({ el: \"#app\", data: { obj: { name: \"张三\", age: 18 } }, //添加方法 methods: { add() {//点击方法 //删除属性 this.$delete(this.obj, \"age\") }, }, }); 集成 按钮 { {obj} } new Vue({ el: \"#app\", data: { // arr: [1, 2, 3], obj: { name: \"张三\", age: 18 } }, //添加方法 methods: { add() {//点击方法 //错误写法 // this.obj.ag = 18 // console.log(this.obj); //修改单个属性 // this.$set(this.obj, \"age\", 666) // this.$set(this.obj, \"sex\", \"男\") //修改多个属性 this.obj = Object.assign({}, this.obj, { age: 66, sex: \"男\", }); //删除属性 this.$delete(this.obj, \"age\") // this.$set(this.arr, 3, \"点击我才能出现哦\") }, }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 19:42:28 "},"10事件处理.html":{"url":"10事件处理.html","title":"10事件处理","keywords":"","body":" 事件修饰符 按键修饰符 练习 事件处理 事件修饰符 修饰符3个：event，stop，self //stop 阻止事件的传播 内容2 内容1 new Vue({ el: \"#app\", data: { }, methods: { fn(e){ console.log(e.currentTarget) } }, }); //prevent 阻止事件的默认行为 提交 new Vue({ el: \"#app\", data: { }, methods: { submit(){ console.log(123) } }, }); //capture 把冒泡改为捕获 内容2 内容1 new Vue({ el: \"#app\", data: { }, methods: { fn(e){ console.log(e.currentTarget) } }, }); //self 当currentTarget和target都是同一个时候才触发 内容2 内容1 new Vue({ el: \"#app\", data: { }, methods: { fn(e){ console.log(e.currentTarget) console.log(e.target) } }, }); //once 只触发一次 内容 new Vue({ el: \"#app\", data: { }, methods: { fn(e){ console.log(e.currentTarget) } }, }); //passive 主动告诉浏览器不需要阻止事件的默认行为 //移动端 滑动屏幕 会发询问给浏览器 需不需要阻止这个事件 //passive 不需要问我，每次都不阻止。目的是提升浏览器的运行效率 按键修饰符 new Vue({ el: \"#app\", data: { }, methods: { fn(){ console.log(123) } }, }); 练习 %accordion% 仅参考💢 %accordion% 按钮 new Vue({ el: \"#app\", data: {}, methods: { handlerClick(e) { console.log(e); } } }) 提交 new Vue({ el: \"#app\", data: {}, methods: { submit(e) { e.preventDefault();//阻止事件的默认行为 console.log(123); } } }) %/accordion% %accordion% 练习🚀 %accordion% 按钮 --> 按钮 new Vue({ el: \"#app\", data: { }, methods: { submit() { console.log(123); } } }) %/accordion% %accordion% 点击事件练习🔨 %accordion% 添加了.self .a { width: 500px; height: 500px; background: red; } .b { width: 300px; height: 300px; background: #f0f; } new Vue({ el: \"#app\", data: { }, methods: { handler(e) { // console.log(e.currentTarget) //冒泡事件 冒泡上去了就先b然后a console.log(e.target) //触发该元素，添加.self点击谁就是谁 } }, }) 传播事件 .a { width: 500px; height: 500px; background: red; } .b { width: 300px; height: 300px; background: #f0f; } new Vue({ el: \"#app\", data: { }, methods: { handler(e) { // console.log(e.currentTarget) //冒泡事件 冒泡上去了就先b然后a console.log(e.target) //触发该元素，触发b就两个b咯，触发a就a咯 } }, }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:43 "},"11表单输入绑定.html":{"url":"11表单输入绑定.html","title":"11表单输入绑定","keywords":"","body":"表单输入绑定 修饰符 lazy 等失去焦点再获取值，而不是每次改变值都获取 { {msg} } new Vue({ el: \"#app\", data: { msg:\"\" } }); %accordion% 练习🚀 %accordion% 用到表单就多 //添加lazy就可以一起发过去 意思是懒惰 { {msg} } new Vue({ el: \"#app\", data: { msg: \"\", } }) %/accordion% number 把输入的值转成数字 { {msg} } { {typeof msg} } new Vue({ el: \"#app\", data: { msg:\"\" } }); %accordion% 练习🚀 %accordion% { {msg} } { {typeof msg} } new Vue({ el: \"#app\", data: { msg: \"\", }, }) %/accordion% trim 去掉输入框前后的空格 { {msg} } new Vue({ el: \"#app\", data: { msg:\"\" } }); %accordion% 去掉前后的空格符🚀 %accordion% 按钮 new Vue({ el: \"#app\", data: { msg: \"\" }, methods: { handler() { console.log(this.msg) } }, }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:40 "},"12组件.html":{"url":"12组件.html","title":"12组件","keywords":"","body":" 创建组件 1、全局组件 2、局部组件 3、组件里面的data数据只能是函数 父子组件概念 组件 组件是可复用的模块。可复用指的是同一个模块，传不同的数据，显示不同的效果。 创建组件 1、全局组件 只要注册了，在任何地方都能使用。 //注册全局组件 //驼峰式：myComponent Vue.component(\"myComponent\",{ template:\"我的组件\" }) new Vue({ el: \"#app\", data: { msg:\"\" } }); %accordion% 全局组件(全局注册)🚀 %accordion% // 全局组件（全局注册） Vue.component(\"myComponent1\", { template: \"组件1\", }); Vue.component(\"component2\", { template: ` 组件2 `, }); new Vue({ el: \"#app\", data: { msg: \"\", }, }); %/accordion% 2、局部组件 在需要用到的地方进行注册，才能使用。 // 注册局部组件 let myComponent2 = { template:\"我的组件2\" } //根组件 new Vue({ el: \"#app\", data: { msg:\"\" }, components:{ myComponent2 } }); %accordion% 局部组件(区域注册)🚀 %accordion% //局部组件(区域注册) let myComponent1 = { template: \"我是组件1\", }; let myComponent2 = { template: ` 我是组件2 `, //注册区 components: { myComponent1, }, }; new Vue({ el: \"#app\", components: { myComponent2, }, }); %/accordion% 3、组件里面的data数据只能是函数 如果是对象，复用的所有组件都会共用同一个数据 let myComponent1 = { template:\"{ {msg} }\", data(){ return{ msg:\"hi\" } } } //根组件 new Vue({ el: \"#app\", data:{ msg:\"hello\" }, components:{ myComponent1 } }); 父子组件概念 父：被注册的组件 子：注册的组件 //儿子 let myComponent2 = { template:\"组件2\", } //爸爸 let myComponent1 = { template:\"组件1\", components:{ myComponent2 } } //根组件（爷爷） new Vue({ el: \"#app\", data:{ msg:\"hello\" }, components:{ myComponent1 } }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:23:46 "},"13组件之间传递数据方式.html":{"url":"13组件之间传递数据方式.html","title":"13组件之间传递数据方式","keywords":"","body":" 父传子 子传父 单向数据流 v-model的高级用法 .sync修饰符 非父子组件传递数据 1、eventBus(订阅发布模式、总线模式) 2、依赖注入 3、v-bind='$attrs'、v-on='$listeners' 4、vuex 组件之间传递数据方式 [success] vue的组件之间是如何传递数据 父传子：propos 子传父：$emit 非父子：eventBus 、依赖注入 、v-bind=\"$attrs\"和v-on=\"$listeners\"、vuex 、边界访问 父传子 let myComponent1 = { props:[\"childMsg\"],//接收器 template:\"组件1{ {childMsg} }\", } //根组件 new Vue({ el: \"#app\", data:{ fathermsg:\"hello\" }, components:{ myComponent1 } }); %accordion% 参考...💢 %accordion% //局部组件（区域注册）👦子组件 let myComponent1 = { template: \"我的组件{ {msg} }\", data() { return { msg: \"hello\", } } } //👨父组件 new Vue({ el: \"#app\", data: { msg: \"hello\" }, components: { myComponent1, } }) %/accordion% %accordion% 父传子🚀 %accordion% fathermsg是父组件的数据 childmsg 是子组件的接收器 //局部组件（区域注册）👦子组件 let myComponent1 = { props: [\"childmsg\"], //接收器（跟data的数据用法一样） template: \"我的组件1{ {childmsg} }\", } //👨父组件 new Vue({ el: \"#app\", data: { fathermsg: \"父组件的数据\" }, components: { myComponent1, } }) %/accordion% 传多个数据 let myComponent1 = { props:[\"childMsg\"], template:\"组件1{ {childMsg.fathermsg} }{ {childMsg.fathermsg2} }\", } //根组件 new Vue({ el: \"#app\", data:{ fathermsg:\"hello\", fathermsg2:\"hi\" }, components:{ myComponent1 } }); let myComponent1 = { props:[\"childMsg\",\"childMsg2\"], template:\"组件1{ {childMsg} }{ {childMsg2} }\", } //根组件 new Vue({ el: \"#app\", data:{ fathermsg:\"hello\", fathermsg2:\"hi\" }, components:{ myComponent1 } }); 子传父 let myComponent1 = { template:\"组件1按钮\", data(){ return{ childmsg:\"hello\" } }, methods: { change(){ this.$emit(\"childevent\",this.childmsg)//提交一个自定义事件 } }, } //根组件 new Vue({ el: \"#app\", components:{ myComponent1 }, methods: { fatherevent(e){ console.log(e) } }, }); %accordion% 子传父 %accordion% fathermsg 是父组件的数据 childmsg 是子组件的接收器 //局部组件（区域注册）👦子组件 let myComponent1 = { template: \"我的组件1按钮\", //给子组件添加数据 data() { return { msg: \"子组件的数据\", }; }, //传事件 methods: { handler() { this.$emit(\"childevent\", this.msg); //触发一个自定义事件 }, }, }; //👨父组件 new Vue({ el: \"#app\", components: { myComponent1, }, methods: { fatherevent(e) { console.log(e); }, }, }); %/accordion% 子传多个数据给父 let myComponent1 = { data(){ return{ value:\"子组件的数据\", value2:\"子组件的数据2\" } }, template:\"组件1按钮{ {value} }\", methods: { change(){ this.$emit(\"childevent\",[this.value,this.value2]) } }, } //根组件 new Vue({ el: \"#app\", components:{ myComponent1 }, methods: { parentsevent(a){ console.log(a) } }, }); %accordion% 子传父-多线程 %accordion% fathermsg 是父组件的数据 childmsg 是子组件的接收器 //局部组件（区域注册）👦子组件 let myComponent1 = { template: \"我的组件1按钮\", data() { return { msg1: \"子组件的数据\", msg2: \"子组件的数据\" } }, methods: { handler() { this.$emit(\"childevent\", { msg1: this.msg1, msg2: this.msg2 })//触发一个自定义事件 } }, } //👨父组件 new Vue({ el: \"#app\", components: { myComponent1, }, methods: { fatherevent(e) { console.log(e); } } }) %/accordion% 单向数据流 vue规定数据的流向只能是单向的，并且不能直接修改props数据，必须把数据赋给data或者computed let myComponent1 = { props:[\"msg\"], data(){ return{ value:this.msg//不能直接修改props，需要赋值给data或者computed } }, template:\"组件1按钮{ {value} }\", methods: { change(){ this.value = \"子组件的数据\" this.$emit(\"childevent\",this.value) } }, } //根组件 new Vue({ el: \"#app\", components:{ myComponent1 }, data:{ msg:\"父组件的数据\" }, methods: { parentsevent(e){ this.msg = e } }, }); %accordion% 单向数据流父替子🚀 %accordion% //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件,{ {childmsg} }\", props: [\"msg\"], //更改数据 data() { return { childmsg: this.msg } }, created() { this.childmsg = \"我是替换的数据\" }, } //父组件 new Vue({ el: \"#app\", data: { msg: \"👨父组件的数据\" }, components: { myComponent1, } }) %/accordion% %accordion% 单向数据流的注意点🚀 %accordion% 对象 { {obj} } let myComponent1 = { template: \"我的组件1{ {childobj} }\", props: [\"obj\"], data() { return { //: JSON.assign({},this.obj) //这里是浅克隆 childobj: JSON.parse(JSON.stringify(this.obj)) ✨//这里是深克隆 } }, created() { this.childobj.name = \"李四\" }, } new Vue({ el: \"#app\", data: { obj: { name: \"张三\" } }, components: { myComponent1, } }) 数组 let myComponent1 = { template: \"我的组件1{ {childobj[0]} }\", props: [\"obj\"], data() { return { childobj: this.obj } }, created() { this.childobj[0] = \"李四\" // console.log(this.childobj[0]); }, } new Vue({ el: \"#app\", data: { arr: [\"张三\", 'a'] }, components: { myComponent1, } }) %/accordion% v-model的高级用法 let myComponent = { props: { bool:Boolean }, model: {//model属性是新增的属性，用于给非表单标签的自定义组件添加v-model功能 prop:\"bool\",//指定props属性 event:\"change\"//指定触发的事件 }, template: \"弹窗确定\", methods: { change(){ this.$emit(\"change\",false)//触发的事件 } }, }; //根组件 new Vue({ el: \"#app\", components: { myComponent, }, data: { bool: false, }, }); %accordion% v-model的高级用法练习🚀 %accordion% { {num} } //局部组件（区域注册）👦子组件 let myComponent1 = { template: \"我是子组件按钮\", props: [\"num\"], data() { return { childnum: this.num, }; }, model: { prop: \"num\", event: \"childevent\", }, methods: { change() { this.childnum = 2; this.$emit(\"childevent\", this.childnum);//子传父 }, }, }; //👨父组件 new Vue({ el: \"#app\", data: { num: 1, }, components: { myComponent1, }, }); %/accordion% %accordion% 案例🚀 %accordion% .box { width: 200px; height: 200px; border: 1px solid; } 开 //局部组件（区域注册）子组件 let myComponent1 = { template: \"关闭\", props: [\"bool\"], model: { prop: \"bool\", event: \"childevent\", }, data() { return { mybool: this.bool, } }, methods: { close() { this.mybool = false; this.$emit(\"childevent\", this.mybool) } } }; //父组件 new Vue({ el: \"#app\", data: { bool: false, }, components: { myComponent1, }, }); %/accordion% .sync修饰符 与v-model效果一致，以前的写法，不推荐，推荐使用v-model let myComponent = { props: { bool:Boolean }, template: \"弹窗确定\", methods: { change(){ this.$emit(\"update:bool\",false) } }, }; //根组件 new Vue({ el: \"#app\", components: { myComponent, }, data: { bool: false, }, }); 非父子组件传递数据 1、eventBus(订阅发布模式、总线模式) Vue.prototype.$eventBus = new Vue()//实例化vue(总线) //组件1 let myComponent1 = { template: \"组件1发送\", data(){ return{ msg:\"组件1的数据\" } }, methods: { send(){ this.$eventBus.$emit(\"myevent\",this.msg)//发布器 } }, }; //组件2 let myComponent2 = { template: \"组件2\", created() { this.$eventBus.$on(\"myevent\",(e)=>{//订阅器 console.log(e) }) this.$eventBus.$off(\"myevent\")//取消订阅 }, }; //根组件 new Vue({ el: \"#app\", components: { myComponent1, myComponent2 } }); %accordion% 非父子传递方法 两子之间的传递数据👦 %accordion% //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件按钮\", data() { return { msg: \",👦我是子组件1\" } }, methods: { handler() { this.$emit(\"childeventa\", this.msg) } } }; let myComponent2 = { template: \"🧑我是子组件2{ {childevent} }\", props: [\"childevent\"] }; //👨父组件 new Vue({ el: \"#app\", data: { fathermsg: \"\", }, components: { myComponent1, myComponent2, }, methods: { fatherevent(e) { this.fathermsg = e; } } }); %/accordion% %accordion% 非父子传递-订阅发布模式练习🚀 %accordion% Vue.prototype.$eventBus = new Vue(); //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件按钮\", data() { return { msg: \"；👧我是子组件派来的数据\", }; }, methods: { handler() { this.$eventBus.$emit(\"aevent\", this.msg); }, }, }; //孙子组件 let myComponent2 = { template: \"👶我是孙组件{ {msg} }\", data() { return { msg: \"\", }; }, created() { this.$eventBus.$on(\"aevent\", (res) => { this.msg = res; }); }, }; //👨父组件 new Vue({ el: \"#app\", data: { fathermsg: \"\", }, components: { myComponent1, myComponent2, }, }); %/accordion% 2、依赖注入 只要在父组件有数据，所有的直属后代都有数据。 let mycomponent1 = { template:\"a组件{ {msg} }\", inject:[\"msg\"] } let mycomponent2 = { template:\"b组件{ {msg} }\", components:{ mycomponent1 }, inject:[\"msg\"] } //根组件 new Vue({ el: \"#app\", components:{ mycomponent2 }, provide(){ return{ msg:\"根组件数据\" } } }); %accordion% 依赖注册练习🚀 %accordion% //局部组件 （区域注册）孙组件 let myComponent2 = { template: \"👶我是孙组件，{ {msg} }\", inject: [\"msg\"], }; //子组件 let myComponent1 = { template: \"👦我是子组件，{ {msg} }\", components: { myComponent2, }, inject: [\"msg\"] }; //父组件 new Vue({ el: \"#app\", data: { fathermsg: \"👨我是父组件的数据。\", }, components: { myComponent1, }, // 依赖注入 provide() { return { msg: this.fathermsg }; }, }); %/accordion% 3、v-bind='$attrs'、v-on='$listeners' 可用于写高级组件封装。 let mycomponent0 = { props: { msg: { type: String, required: true, }, }, template: \"z组件{ {msg} }\", created() { this.$emit(\"myevent\",123) }, }; let mycomponent1 = { template: \"a组件\", components:{ mycomponent0 } }; let mycomponent2 = { template: \"b组件\", components: { mycomponent1, }, }; //根组件 new Vue({ el: \"#app\", components: { mycomponent2, }, data: { msg: \"根组件的数据\", }, methods: { myevent(e) { console.log(e); }, }, }); %accordion% 🔨隔代遗传 爷爷传也孙子 %accordion% //局部组件（区域注册） let myComponent3 = { template: \"👶我是子组件3{ {msg} }\", props: [\"msg\"], }; let myComponent2 = { template: \"👦我是子组件2\", components: { myComponent3, }, }; let myComponent1 = { template: \"🧑我是子组件1\", components: { myComponent2, }, }; //👨父组件 new Vue({ el: \"#app\", components: { myComponent1, } }); %/accordion% %accordion% 🔨🔨隔代遗传 爷爷传也孙子 %accordion% //局部组件（区域注册） let myComponent3 = { template: \"👶我是子组件3{ {msg1} }{ {msg2} }{ {msg3} }\", props: [\"msg1\", \"msg2\", \"msg3\"], }; let myComponent2 = { template: \"👦我是子组件2\", components: { myComponent3, }, }; let myComponent1 = { template: \"🧑我是子组件1\", components: { myComponent2, }, }; new Vue({ el: \"#app\", components: { myComponent1, }, data: { fathermsg: \"👨我是父组件数据。\", }, }); %/accordion% %accordion% 🔨🔨🔨隔代遗传 爷爷传也孙子 %accordion% //局部组件（区域注册） let myComponent3 = { template: \"👶我是子组件3{ {msg1} }{ {msg2} }{ {msg3} }\", props: [\"msg1\", \"msg2\", \"msg3\"], created() { this.$emit(\"event\", \"这是组件3的数据\"); //自定义数据 // console.log(this.$attrs); }, }; let myComponent2 = { template: \"👦我是子组件2\", components: { myComponent3, }, }; let myComponent1 = { template: \"🧑我是子组件1\", components: { myComponent2, }, methods: { fn(e) { console.log(1, e); //1 \"这是组件3的数据\" }, }, // created() { // console.log(this.$attrs); // } }; //👨父组件 new Vue({ el: \"#app\", components: { myComponent1, }, //获取数据 methods: { fn(e) { console.log(e);//这是组件3的数据 // console.log(this.$attrs); }, }, }); %/accordion% 4、vuex Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 19:42:31 "},"14props验证.html":{"url":"14props验证.html","title":"14props验证","keywords":"","body":"props验证 let myComponent1 = { props:{ msg:{ type:Number,//数据类型 // default:1//默认值 required:true,//必填, validator(val){//自定义校验 return val % 2 === 0 } } }, template:\"组件{ {msg+1} }\", } //根组件 new Vue({ el: \"#app\", components:{ myComponent1 }, data:{ msg:2 } }); %accordion% props校验练习🚀 %accordion% //局部组件（区域注册）子组件 let myComponent1 = { template: \"{ {msg+1} }\", //校验他是什么数据类型 props: { msg: { // type: Number, //校验类型 type: String, default: 1,//默认值 required: true,//必填 validator(val) { //自定校验 // return val>=2; let reg = /hi/; //正侧表达式 return reg.test(val); } } } }; //父组件 new Vue({ el: \"#app\", data: { // msg: 1, msg: \"hi\" }, components: { myComponent1, }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 19:42:34 "},"15插槽.html":{"url":"15插槽.html","title":"15插槽","keywords":"","body":" 创建插槽 具名插槽 默认插槽 作用域插槽 案例插槽完整版 插槽 创建插槽 内容 let mycomponent = { template: \"\", }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, } }); %accordion% 创建插槽练习🚀 %accordion% 我是一个插槽 //局部组件（区域注册）子组件 let myComponent1 = { //slot：插槽 template: \"\", }; //父组件 new Vue({ el: \"#app\", data: { }, components: { myComponent1, }, }); %/accordion% 具名插槽 内容1 内容2 let mycomponent = { template: \"内容x\", }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, } }); %accordion% 具名插槽 ——就给他起名字🚀 %accordion% 我是插槽1 我是插槽2 //局部组件（区域注册）子组件 let myComponent1 = { //slot：插槽 template: \" ==楚河汉界== \", }; //父组件 new Vue({ el: \"#app\", data: { }, components: { myComponent1, }, }); 打印出来的效果 我是插槽1 ==楚河汉界== 我是插槽2 %/accordion% 默认插槽 内容1 内容2 let mycomponent = { template: \"内容x\", }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, } }); 作用域插槽 使用v-slot可以提取出当前插槽的数据 查看 let mycomponent = { props:{ arr:{ type:Array, required:true } }, template: ` 商品名称 商品数量 商品价钱 操作 { {item.name} } { {item.num} } { {item.price} } `, }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, }, data: { arr: [ { name: \"苹果13\", num: 1, price: 1000 }, { name: \"苹果14\", num: 2, price: 2000 }, { name: \"苹果15\", num: 3, price: 3000 }, ], }, methods: { show(row,idx){ console.log(row) console.log(idx) } }, }); %accordion% 作用域插槽练习🚀 %accordion% 🐱‍🐉插槽{ {data} } //局部组件（区域注册）子组件 let myComponent1 = { //slot：插槽 template: \"\", data() { return { msg: \"，👀作用域\" } } }; //父组件 new Vue({ el: \"#app\", data: { }, components: { myComponent1, }, }); 打印出来的效果 🐱‍🐉插槽，👀作用域 %/accordion% 作用域插槽里面使用具名插槽 查看 编辑 let mycomponent = { props:{ arr:{ type:Array, required:true } }, template: ` 商品名称 商品数量 商品价钱 操作 { {item.name} } { {item.num} } { {item.price} } `, }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, }, data: { arr: [ { name: \"苹果13\", num: 1, price: 1000 }, { name: \"苹果14\", num: 2, price: 2000 }, { name: \"苹果15\", num: 3, price: 3000 }, ], }, methods: { show(row,idx){ console.log(row) console.log(idx) } }, }); 案例插槽完整版 //作用域插槽 ——就给他起名字1️⃣ //使用v-slot可以提取出当前插槽的数据 第一个表格 查看 //使用v-slot可以提取出当前插槽的数据 第二个表格 编辑 //局部组件（区域注册）子组件2️⃣ let myComponent1 = { props: { list: { type: Array, required: true, }, }, //slot：插槽 template: ` { {item.name} } { {item.price} } `, }; //父组件3️⃣ new Vue({ el: \"#app\", data: { goodsList: [ { name: \"🍎苹果\", price: 100, }, { name: \"🍍菠萝\", price: 200, }, { name: \"🍌香蕉\", price: 300, }, ], goodsList1: [ { name: \"🍉西瓜\", price: 100, }, { name: \"🍒樱桃\", price: 200, }, { name: \"🥝猕猴桃\", price: 300, }, ], }, components: { myComponent1, }, methods: { show(row, idx) { console.log(idx); }, }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 19:42:37 "},"16动态组件.html":{"url":"16动态组件.html","title":"16动态组件","keywords":"","body":"动态组件 //keep-alive可以缓存组件，让组件不需要每次切换都销毁再重新渲染 //但是会让created组件失效，解决办法是使用activated激活生命周期 按钮 import acom from \"./components/acom.vue\" import bcom from \"./components/bcom.vue\" export default { name: 'App', data(){ return{ com:\"bcom\" } }, components: { acom, bcom }, methods:{ toggle(){ if(this.com === \"acom\"){ this.com = 'bcom' }else{ this.com = 'acom' } } } } %accordion% keep-alive可以缓存组件🚀 %accordion% 切换 //局部组件（区域注册）子组件 let myComponent1 = { template: \"👧我是子组件1\", }; let myComponent2 = { template: \"👦我是子组件2\", }; //👨父组件 new Vue({ el: \"#app\", data: { myComponent: \"myComponent1\" }, components: { myComponent1, myComponent2, }, methods: { toggle() { if (this.myComponent === \"myComponent1\") { this.myComponent = \"myComponent2\" } else { this.myComponent = \"myComponent1\" } } }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 16:14:42 "},"17处理边界情况.html":{"url":"17处理边界情况.html","title":"17处理边界情况","keywords":"","body":" 获取父组件的数据和方法 获取子组件的数据和方法 处理边界情况 获取父组件的数据和方法 let mycomponent = { template: ``, created() { console.log(this.$parent._data.msg)//获取父组件的数据 this.$parent.fn()//执行父组件的方法 }, }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, }, data:{ msg:\"父组件的数据\" }, methods: { fn(){ console.log(\"这是父组件的方法\") } }, }); %accordion% 获取父组件的数据和方法🚀 %accordion% { {msg} } //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件\", created() { this.$parent.change();//执行父组件的方法 }, }; //父组件 new Vue({ el: \"#app\", data: { msg: \"👨我是父组件\" }, components: { myComponent1, }, methods: { change() { this.msg = \"👨父组件的数据进行修改...\" } }, }); %/accordion% 获取子组件的数据和方法 let mycomponent = { template: ``, data(){ return{ msg:\"子组件的数据\" } }, methods: { fn(){ console.log(\"子组件的方法\") } }, }; //根组件 new Vue({ el: \"#app\", components: { mycomponent, }, // created() {//这个时候还没有渲染组件，所以无法获取 // console.log(this.$children) // }, mounted() { console.log(this.$children[0]._data.msg) this.$children[0].fn() console.log(this.$refs.a._data.msg) this.$refs.a.fn() }, }); %accordion% 【mounted】获取子组件的数据和方法🚀 %accordion% //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件1\", //获取数据 data() { return { msg: \"我是子组件的数据\", }; }, }; let myComponent2 = { template: \"👧我是子组件2\", data() { return { msg: \"我是子组件的数据\", }; }, }; //父组件 new Vue({ el: \"#app\", data: {}, components: { myComponent1, myComponent2, }, // created() {//这个时候还没有渲染组件，所以无法获取 // console.log(this.$children) // }, mounted() {//渲染之后就可以获取得到了 console.log(this.$children); }, }); %/accordion% %accordion% 【created】获取子组件的数据和方法🚀 %accordion% //局部组件（区域注册）子组件 let myComponent1 = { template: \"👦我是子组件1\", //获取数据 data() { return { msg: \"我是子组件的数据\", }; }, }; let myComponent2 = { template: \"👧我是子组件2\", data() { return { msg: \"我是子组件的数据\", }; }, }; //父组件 new Vue({ el: \"#app\", data: {}, components: { myComponent1, myComponent2, }, created() {//这个时候还没有渲染组件，所以无法获取 this.$nextTick(() => {//事件轮循机制 console.log(this.$children) }) }, }); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 19:42:39 "},"18脚手架.html":{"url":"18脚手架.html","title":"18脚手架","keywords":"","body":" 准备工作 项目目录 脚手架 准备工作 nodejs npm vue脚手架 0、安装node.js node.js的安装路径不能是中文名 1、全局安装vue脚手架 npm install -g @vue/cli 2、检测脚手架有没有安装成功 vue -V 3、创建vue项目 vue create 项目名 3.1、运行项目 npm run serve 4、进入根目录之后设置package.json。 使用dev命令打开默认浏览器 \"dev\": \"vue-cli-service serve --open\", 5、设置淘宝镜像 npm config set registry 6、检查淘宝镜像是否设置成功 npm config get registry 项目目录 node_modules 依赖包文件（babel、eslint、scss） package.json npm包说明文件(记录了安装什么东西) package-lock.json 版本锁(如果没有版本锁，npm i安装的时候会默认帮你安装最新的版本) public 静态资源文件(图标、html模版) src 核心目录(项目的唯一出口) .gitignore git的筛选文件(控制哪些文件不上传) babel.config.js babel配置文件 readme.md 说明文件 src assets 静态资源文件(图片) components 全局组件 main.js 项目的唯一出口 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 18:18:33 "},"19Vuex.html":{"url":"19Vuex.html","title":"19Vuex","keywords":"","body":" 1、安装&使用 2、state 数据状态 3、getters 计算属性 4、mutations 提交 5、actions 异步提交 6、modules 模块化 Vuex 为vue定制的数据状态管理模式。 1、安装&使用 npm i vuex -S export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 } }) 2、state 数据状态 定义 { {this.$store.state.num} } 调用 { {this.$store.state.num} } 计算属性 { {num} } export default { computed:{ num(){ return this.$store.state.num } } } 辅助函数 { {num} } import {mapState} from \"vuex\" export default { computed:{ ...mapState([\"num\"]) } } 3、getters 计算属性 定义 export default new Vuex.Store({ state:{//数据状态(类似于data数据) msg:\"hello world\", }, getters:{ toReverse(state){//反转 return state.msg.split(\"\").reverse().join(\"\") } } }) 使用 { {this.$store.getters.toReverse} } 以其他getters作为参数 export default new Vuex.Store({ state:{//数据状态(类似于data数据) msg:\"hello world\", }, getters:{ toReverse(state){//反转 return state.msg.split(\"\").reverse().join(\"\") }, toUpperCase(state,getters){//大写 return getters.toReverse.toUpperCase() } } }) 通过方法访问 export default new Vuex.Store({ state:{//数据状态(类似于data数据) arr:[{id:1,name:\"小明\"},{id:2,name:\"小红\"},{id:3,name:\"小黄\"}] }, getters:{ filter(state){ return (id)=>{ return state.arr.filter((item)=>{ return item.id === id }) } } } }) { {this.$store.getters.filter(2)} } 辅助函数 { {toFilter(18)} } import {mapGetters} from \"vuex\" export default { computed:{ ...mapGetters([\"toFilter\"]) } } 4、mutations 提交 vuex的事件，用于更改在state中定义的数据 定义 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交 add(state){ state.num++ } } }) 访问 按钮 { {this.$store.state.num} } export default { name: 'App', methods:{ add(){ this.$store.commit(\"add\") } } } 提交载荷（添加参数） import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 Vue.use(Vuex)//使用插件 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交 add(state,payload){ state.num+=payload } } }) methods:{ add(){ this.$store.commit(\"add\",2) } } 使用常量替代 Mutation 事件类型 import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 import {ADD} from \"./mutations-type.js\" Vue.use(Vuex)//使用插件 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交 [ADD](state,payload){ state.num+=payload } } }) export const ADD = \"ADD\" 辅助函数 添加 import {mapMutations} from \"vuex\" export default { methods: { ...mapMutations([\"ADD\"]) }, }; 5、actions 异步提交 vuex的异步事件，用于异步的更改在state中定义的数据。 定义 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交(只有这里能修改数据) add(state){ state.num++ } }, actions:{//异步提交(只有这里能写异步方法) aysncAdd(context){ context.commit(\"add\") } } }) add(){ this.$store.dispatch(\"aysncAdd\") } 简写 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交(只有这里能修改数据) add(state){ state.num++ } }, actions:{//异步提交(只有这里能写异步方法) aysncAdd({commit}){ commit(\"add\") } } }) dispatch访问其他actions import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 Vue.use(Vuex)//使用插件 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交(只有这里能修改数据) add(state){ state.num++ } }, actions:{//异步提交(只有这里能写异步方法) aysncAdd({commit}){ commit(\"add\") }, asyncAdd2({dispatch}){ dispatch(\"aysncAdd\") } } }) 提交载荷 import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 Vue.use(Vuex)//使用插件 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交(只有这里能修改数据) add(state,payload){ state.num+=payload } }, actions:{//异步提交(只有这里能写异步方法) aysncAdd({commit},payload){ commit(\"add\",payload) }, asyncAdd2({dispatch},payload){ dispatch(\"aysncAdd\",payload) } } }) this.$store.dispatch(\"asyncAdd2\",2)//派发 辅助函数 按钮 { {this.$store.state.num} } import { mapActions } from \"vuex\" export default { name: 'App', methods:{ ...mapActions([\"asyncAdd2\"]) } } 异步案例 promise import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 Vue.use(Vuex)//使用插件 export default new Vuex.Store({ state:{//数据状态(类似于data数据) num:1 }, mutations:{//同步提交(只有这里能修改数据) add(state){ state.num++ }, add2(state){ state.num+=2 } }, actions:{//异步提交(只有这里能写异步方法) asyncAdd({commit}){ return new Promise((resolve)=>{ setTimeout(()=>{ commit(\"add\") resolve() },2000) }) }, asyncAdd2({commit}){ return new Promise((resolve)=>{ commit(\"add2\") resolve() }) } } }) add(){ this.$store.dispatch(\"asyncAdd\").then(()=>{ this.$store.dispatch(\"asyncAdd2\") }) async await async add(){ await this.$store.dispatch(\"asyncAdd\") await this.$store.dispatch(\"asyncAdd2\") } 6、modules 模块化 把store那功能模块分割 定义 store/index.js import Vue from \"vue\" import Vuex from \"vuex\"//vuex插件 import {acom} from \"./modules/acom.js\" import {bcom} from \"./modules/bcom.js\" Vue.use(Vuex)//使用插件 export default new Vuex.Store({ modules:{ acom, bcom } } store/modules/acom.js export const acom = { namespaced:true,//命名空间 state:{ num:1 }, mutations:{ add(state){ state.num++ } } } 访问 //获取state { {this.$store.state.acom.num} } //执行getters { {this.$store.getters[\"acom/add\"]} } //执行mutations this.$store.commit(\"acom/add\") //执行actions this.$store.dispatch(\"acom/asyncAdd\") 辅助函数 组件a { { num } } 按钮 import { createNamespacedHelpers } from \"vuex\"; const { mapState, mapMutations } = createNamespacedHelpers(\"acom\"); export default { computed: { ...mapState([\"num\"]), }, methods: { ...mapMutations([\"add\"]), }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-14 10:39:48 "},"20VueRouter.html":{"url":"20VueRouter.html","title":"20VueRouter","keywords":"","body":" 安装和使用 创建路由文件 在main.js引入 路由视图 渲染的路由组件 别名和重定向 路由跳转 路由对象 路由方法 编程式导航 路由传参 路由传参解耦 命名路由 嵌套路由 路由拦截(路由守卫) 路由懒加载 VueRouter Vue Router 是 Vue.js官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。 安装和使用 npm i vue-router -S 创建路由文件 //router/index.js import Vue from \"vue\" import VueRouter from \"vue-router\" import home from \"@/views/home/home\" Vue.use(VueRouter) export default new VueRouter({ routes:[{ path:\"/home\", component:home }] }) 在main.js引入 //main.js import Vue from 'vue' import App from './App.vue' import store from \"@/Store/index.js\" import router from \"@/router/index.js\" Vue.config.productionTip = false new Vue({ store, router, render: h => h(App), }).$mount('#app') 路由视图 //App.vue export default { name: 'App' } 渲染的路由组件 //views/home/home.vue home页面 export default { } 别名和重定向 别名可以让一个页面同时有两个名字。 重定向是打开a页面，跳到b页面去。 export default new VueRouter({ mode: 'history', routes:[{ path:\"/\", alias:\"/home\", component:home },{ path:\"/list\", redirect:\"xxx\", component:list }] }) 路由跳转 //router-link标签只能跳到路由里面有记载的页面 跳到列表页 //如果要跳到项目外的页面，使用a标签 \"> 路由对象 console.log(this.$router)//整个路由对象所有的信息（所有的路由） console.log(this.$route)//当前路由的信息（只能获取当前路由） 路由方法 this.$router.push()//跳到某个页面 this.$router.foworad() this.$router.back() this.$router.go(1) this.$router.go(-1) 编程式导航 //根router-link一样的效果 this.$router.push(\"/list\") //根a标签一样的效果 location.href = \"\" 路由传参 跳到列表页 this.$router.push({path:'/list',query:{id:1}}) 接收参数 console.log(this.$route.query.id) 路由传参解耦 //router/index.js export default new VueRouter({ mode: 'history', routes:[{ path:\"/\", alias:\"/home\", component:home },{ path:\"/list\", component:list, props:(route)=>{ return { id:route.query.id } } }] }) //list.vue export default { props:{ id:String }, created(){ // console.log(this.$route.query.id) console.log(this.id) } } 命名路由 使用name进行跳转页面 跳到列表页 { path:\"/list\", name:\"list\", component:list, } 命名路由跳转页面的时候会有一个问题，刷新页面后数据会消失。 //解决方法是在path的后面加上:数据 { path:\"/list/:id\", name:\"list\", component:list, } params路由解耦 { path:\"/list/:id\", name:\"list\", component:list, props:(route)=>{ return { id:route.params.id } } } 嵌套路由 在页面里面再添加多一个页面，相当于画中画的效果 export default new VueRouter({ mode: 'history', routes:[{ path:\"/\", alias:\"/home\", component:home, children:[{ path:\"/home/a\", alias:\"/home\", component:acom },{ path:\"/home/b\", component:bcom }] }] }) // home页面 路由拦截(路由守卫) 一般用于做登录拦截。 全局前置守卫 beforeEach 所有的页面进入页面之前进行拦截 全局解析守卫 beforeResolve 所有的页面的异步路由加载完毕后拦截 全局后置钩子 afterEach 所有的页面进入页面后进行拦截 路由独享的守卫 beforeEnter 单独拦截某一个路由页面 组件内的守卫 在组件页面内进行拦截 beforeRouteEnter 进入当前组件进行拦截（无法直接获取this实例，需要在回调函数里面获取） beforeRouteUpdate 更新当前路由进行拦截 beforeRouteLeave 离开当前路由进行拦截 路由懒加载 没有路由懒加载的页面，上线之后进入页面会加载所有的页面，会导致用户体验比较差。正确的做法是用户打开一个页面就加载一个页面。 const router = new VueRouter({ mode: 'history', routes:[{ path:\"/\", alias:\"/home\", component:()=>import(\"@/views/home/home\") },{ path:\"/list\", component:()=>import(\"@/views/list/list\") }] }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-16 11:11:43 "},"21自定义指令.html":{"url":"21自定义指令.html","title":"21自定义指令","keywords":"","body":" 一、创建自定义指令 二、钩子函数 三、钩子函数参数 四、函数传参 五、截流函数 六、页面切换 首先安装路由 自定义指令 一、创建自定义指令 export default { name: 'App', directives:{ focus:{//自定义指令的名称 inserted(el){//生命周期，代表渲染后执行，类似于mounted el.focus()//el是添加了该指令的元素 } } } } 二、钩子函数 bind //父组件未加载时调用 inserted //父组件加载完毕时调用 update //更新组件前调用 componentUpdated //更新组件后调用 unbind //组件销毁时调用 三、钩子函数参数 export default { name: \"App\", directives: { focus: { inserted(el,binding) { el.focus(); el.style.background=\"red\" //背景颜色 console.log(binding);//指令详情 console.log(binding.name);//指令名称（不包含v-） console.log(binding.value);//1+1=2 console.log(binding.expression);//1+1 console.log(binding.arg);//click console.log(binding.modifiers);//self let arg=binding.arg if(arg===\"click\"){ el.onclick=function(){ document.querySelector(\"body\").style.background=\"red\"; //鼠标点击选框，背景为红色 } } }, }, }, }; el //指令所绑定的元素，可以用来直接操作 DOM 。 binding name //指令名，不包括 v- 前缀。 value //指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2 oldValue //指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression //字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\"中，表达式为 \"1 + 1\"。 arg //传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers //一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode //Vue 编译生成的虚拟节点。 oldVnode //上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 动态指令参数 //v-mydirective:argument=[dataproperty] 练习 export default { name: \"App\", directives: { mydirective: { inserted(el, binding) { el[`on${binding.arg}`] = function () { el.style.background = binding.value;//鼠标点击选框，选框内为红色 }; }, }, }, }; 四、函数传参 内容 export default { name: 'App', directives:{ test:{ inserted(el,binding){ console.log(binding.value) } } }, methods:{ fn(num){ return num } } } 练习1 //网页刷新就打印出来123了 //钩子函数参数 export default { name: \"App\", methods: { fn(arg) { return arg; }, }, directives: { mydirective: { inserted(el, binding) { console.log(binding.value); }, }, }, }; 练习2 //鼠标点击的时候就触发效果=2 //钩子函数参数 export default { name: \"App\", methods: { fn(arg) { return arg; }, }, directives: { mydirective: { inserted(el, binding) { el[`on${binding.arg}`] = function () { console.log(binding.value); } }, }, }, }; 练习3 //鼠标点击的时候就触发效果=2 //钩子函数参数 export default { name: \"App\", methods: { fn(arg) { return function () { console.log(1 + arg); }; }, }, directives: { mydirective: { inserted(el, binding) { el[`on${binding.arg}`] = function () { binding.value(); }; }, }, }, }; 五、截流函数 内容 export default { name: \"App\", directives: { throttle: { inserted: (el, binding) => { let eventHanlder = binding.arg; //事件 let eventHandlerFn = binding.value.handlerFn; //执行的函数 let delayTime = binding.value.delayTime; //延迟时间 let self = binding.value.instance._self;//获取当前组件 let handler = self.throttle(eventHandlerFn, delayTime); el.addEventListener(eventHanlder, handler); }, }, }, methods: { throttle(fn, time) {//节流函数 let endTime = 0; return function () { let nowTime = +new Date(); if (nowTime - endTime > time) { fn(); endTime = nowTime; } }; }, fn() { console.log(123); }, }, }; 练习 // src/App.vue // src/directives/mythrottle.js import Vue from \"vue\"; import { throttle } from \"../utils/throttle.js\"; Vue.directive(\"mythrottle\", { inserted(el, binding) { let f = binding.value.fn; //传入的函数 let time = binding.value.time; //传入的时间 let event = binding.arg; //传入的事件类型 let callback = throttle(f, time); el.addEventListener(event, callback); }, }); // src/utils/throttle.js export const throttle = (fn, time) => { let endTime = 0; return function () { let nowTime = Date.now(); if (nowTime - endTime >= time) { fn(); endTime = nowTime; } }; }; // src/main.js import \"@/directives/mythrottle.js\"; //全局指令 六、页面切换 优化练习 首先安装路由 npm i vue-router -S // src/router/index.js import Vue from \"vue\"; import VueRouter from \"vue-router\"; Vue.use(VueRouter); export const router = new VueRouter({ routes: [ { path: \"/\", component: () => import(\"@/views/home.vue\"), }, { path: \"/list\", component: () => import(\"@/views/list.vue\"), }, { path: \"/shop\", component: () => import(\"@/views/shop.vue\"), }, ], }); 温馨提示：创建路由对应的文件——比如：src/views/home.vue // src/views/home.vue 首页 去列表页 返回上一页 // src/views/list.vue 列表 去购物车页 返回上一页 // src/views/home.vue 购物车 去首页页 返回上一页 // src/main.js import { router } from \"@/router/index.js\"; new Vue({ router, render:(h)=>h(App), }).$mount(\"#app\"); // src/App.vue //import home from \"@/views/home.vue\" //components:{ // home, //}, js文件 // src/directives/goBack.js import Vue from \"vue\"; import { router } from \"@/router/index.js\"; Vue.directive(\"goback\", { inserted(el) { el.onclick = function () { router.go(-1); }; }, }); // src/main.js import \"@/directives/goBack.js\"; //返回上一步指令 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-11 10:33:37 "},"22渲染函数.html":{"url":"22渲染函数.html","title":"22渲染函数","keywords":"","body":"渲染函数 export default { render(h) { let self = this return h(\"div\", { class: { abc: true, }, domProps: { innerHTML: \"这是渲染函数创建的标签\", }, on:{ click:function(){ self.fn(1) } } }); }, methods:{ fn(num){ console.log(num) } } }; 练习 首先安装jsx 网站：https://github.com/vuejs/jsx-vue2 npm install @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props //根目录 babel.config.js module.exports = { presets: ['@vue/babel-preset-jsx'], } export default { data() { return { list:[1,2,3,4,5] } }, methods: { fn(item){ console.log(item) } }, render() { // return h(\"div\", \"这是渲染函数\"); // return h( // \"div\", // { // class:{ //给div创建class // abc:true, // }, // // domProps:{ // // innerHTML:\"123\" // // }, // }, // [ // h(\"p\"), // h(\"a\") // ] // ); // 简单jsx写法 // return 这是jsx return ( { this.list.map((item,idx)=>{ return { this.fn(item) }}>{item} }) } ); }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-11 10:36:42 "},"23插件.html":{"url":"23插件.html","title":"23插件","keywords":"","body":" 使用插件逻辑 安装 输出 引入 开发插件 创建插件 输出 引入 调用 插件 官网：使用插件 vant fastclick vuex vue-router axios //不是一个插件 他是一个封装过了js函数库 使用插件逻辑 安装 npm install vue-vuex -S 输出 // 创建文件... 比如我的——src/store/index.js import Vue from \"vue\" //引入vue import Vuex from \"vuex\" //引入vuex Vue.ues(Vuex) //使用插件 export default new Vuex.Store({ //输出vuex插件 //这里写vuex的配置 }) 引入 // src/main/.js import store from \"@/store/index.js\" //引入vuex插件 new Vue({ store, }) 开发插件 使用 Vue.use(MyPlugins,Options); 创建插件 输出 // src/plugins/test.js import Vue from \"vue\"; //引入vue const MyPlugins = {}; //定义插件 MyPlugins.install = function (Vue,options) { // 全局方法 Vue.xxx = function () { console.log(123); }; // 实例方法 Vue.prototype.yyy = function () { console.log(456); }; //全局指令 Vue.directive(\"myfocus\", { inserted(el) { el.focus(); //获取焦点 }, }); }; //使用插件 Vue.use(MyPlugins,options); 引入 // src/main.js import \"@/plugins/test.js\" //自定义插件 调用 测试 //使用指令 import Vue from \"vue\"; export default { Vue.xxx(); // 全局方法 this.yyy();// 实例方法 }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-16 11:00:35 "},"24VueConfig.html":{"url":"24VueConfig.html","title":"24VueConfig","keywords":"","body":" vue配置文件 配置路径别名 环境变量和模式 创建文件 配置 调用 VueConfig vue配置文件 官网：简单的配置方式 官网：webpack 官网：环境变量和模式 配置路径别名 // vue.config.js const path = require(\"path\"); //从webpage外部引入 module.exports = { configureWebpack: { resolve: { alias: { \"@com\": path.resolve(__dirname, \"src/components/\"), }, }, }, }; 创建文件 // src/components/test.vue 我是test.vue测试组件 调用 // src/views/home.vue import test from \"@com/test.vue\"; //引入test.vue //这里路径就自定义啦 export default { components:{ test, }, }; 环境变量和模式 vue脚手架默认情况下是三个模式：开发(development)、测试(test)、上线(production) 创建文件 开发development 根目录下.env.develompent # 基本路径 VUE_APP_BASE_URL=http://vt.ossjk.com #环境变量 测试test 根目录下.env.test # 基本路径 VUE_APP_BASE_URL=http://vt2.ossjk.com #环境变量 配置 # package.json \"scripts\": { \"dev\": \"vue-cli-service serve --open\", # 默认是开发模式 \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\", \"test\": \"vue-cli-service serve --open --mode test\" # 测试模式 --open：打开 --mode：模式 }, 调用 // src/views/home.vue import test from \"@com/test.vue\"; //引入test.vue //这里路径就自定义啦 export default { components:{ test, }, created() { console.log(process.env.VUE_APP_BASE_URL); //获取环境变量,在不同环境下变量值不一样 }, }; 然后就开始你的表演 npm run dev # 开发 npm run test # 测试 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-16 10:56:58 "},"01安装和使用.html":{"url":"01安装和使用.html","title":"01安装和使用","keywords":"","body":" 安装 npm 安装vue最新的脚手架 创建项目 Vite 搭建第一个 Vite 项目 其他 vue2和vue3有什么区别？ 安装和使用 Vue3官网 安装 npm 在用 Vue 构建大型应用时推荐使用 npm 安装[1] 。npm 能很好地和诸如 webpack 或 Rollup 模块打包器配合使用。 # 最新稳定版 $ npm install vue@next 安装vue最新的脚手架 对于 Vue 3，你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli。要升级，你应该需要全局重新安装最新版本的 @vue/cli： yarn global add @vue/cli # 或 npm install -g @vue/cli 查看是否安装成功 vue -V 创建项目 vue create +项目名称 # 跑项目 npm run serve Vite vite是一个插件 Vite官网 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。 通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。 搭建第一个 Vite 项目 兼容性注意 Vite 需要 Node.js 版本 >= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。 使用 NPM: $ npm create vite@latest 使用 Yarn: $ yarn create vite 使用 PNPM: $ pnpm create vite 然后按照提示操作即可！ node_modeules：依赖文件 public：公共文件 src：核心目录 vite.config.js：vite的配置文件 其他 vue2和vue3有什么区别？ vue3：是可以创建多个节点 vue2：只能创建一个节点 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-15 13:08:25 "},"02ref和reactive.html":{"url":"02ref和reactive.html","title":"02ref和reactive","keywords":"","body":" 之前的写法 第一种写法ref 定义数据 获取数据 value 第二种写法reactive 面试题 ref和reactive 安装vscode插件【volar-海贼王图标就是了】 禁用-VSode插件【Vetur】 之前的写法 // src/App.vue export default { data() { return { msg: \"hello world\", }; }, }; 第一种写法ref 官网说：这种是用来存普通类型数据【存：字符串、数字那些】 定义数据 // src/App.vue import { ref } from \"vue\"; export default { setup() { const msg = ref(\"hello world\"); return { msg, }; }, }; 获取数据 value setup() { const msg = ref(\"hello world\"); console.log(msg.value) //获取数据 return { msg, }; 第二种写法reactive 官网说：这种是用来存引用类型数据【存：数组、对象那些】 import { reactive } from \"vue\"; export default { setup() { const result = reactive({ msg2: \"hi world\",//里面是对象哦 }); consle.log(result);//获取数据 //这里就不用value了 return { result, }; }, }; 面试题 vue2的双向数据绑定原理和vue3有什么区别？ vue2： 采用的：Object.definePrototype() 称之为：数据劫持 vue3： 采用的：new Proxy() 称之为：数据代理 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-15 14:38:04 "},"03toRefs的解构.html":{"url":"03toRefs的解构.html","title":"03toRefs的解构","keywords":"","body":"toRefs的解构 import { reactive, toRefs } from \"vue\"; export default { setup() { const result = reactive({ msg1: \"hi world 1\", msg2: \"hi world 2\", msg3: \"hi world 3\", }); return { ...toRefs(result), }; }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-15 15:26:53 "},"04组件之间的传递.html":{"url":"04组件之间的传递.html","title":"04组件之间的传递","keywords":"","body":" 父传子 案例 子传父 子传父校验 组件之间的传递 父传子 父组件 // src/App.vue import { reactive, toRefs } from \"vue\"; import test from \"./components/test.vue\"; export default { components: { test, }, setup() { const result = reactive({ msg: \"我是父组件传给子组件——>\", }); return { ...toRefs(result), }; }, }; 子组件 // src/components/test.vue 我是子组件 import { toRefs } from \"vue\"; export default { props: { msg: String, }, setup(props) { const { msg } = toRefs(props); return { msg, }; }, }; 案例 看官网说明 // toRefs：解构 const { msg } = toRefs(props); //传递过程发生响应-会变 const { msg } = props; //传递过程会不会响应-不会变 父组件 按钮 import { reactive, ref, toRefs } from \"vue\"; import test from \"./components/test.vue\"; export default { components: { test, }, setup() { const result = reactive({ msg: \"我是父组件传给子组件——>\", }); const change = () => { result.msg = \"父组件的数据已经变化的——>\"; console.log(result.msg); }; return { ...toRefs(result), change, }; }, }; 子组件 我是子组件 import { toRefs } from \"vue\"; export default { props: { msg: String, }, setup(props) { const { msg } = toRefs(props); //传递过程发生响应-会变 // const { msg } = props; //传递过程会不会响应-不会变 return { msg, }; }, }; 子传父 父组件 // src/App.vue import { reactive, ref, toRefs } from \"vue\"; import test from \"./components/test.vue\"; export default { components: { test, }, setup() { const fn = (e) => { console.log(e); }; return { fn, }; }, }; 子组件 // src/components/test.vue 我是子组件 按钮 import { reactive } from \"vue\"; export default { props: { msg: String, }, setup(props, ctx) { const result = reactive({ msg: \"子组件的数据传给>——>父组件\", }); const handler = () => { ctx.emit(\"childevent\", result.msg); }; return { result, handler, }; }, }; 子传父校验 父组件跟上面一致 子组件 我是子组件 按钮 import { reactive } from \"vue\"; export default { props: { msg: String, }, // emits: [\"childevent\"], //第一种方法 emits: { childevent: (payload) => {//第二种方法 if (typeof payload === \"string\") { return true; } else { console.log(\"报错\"); return false; } }, }, setup(props, ctx) { const result = reactive({ // msg: \"子组件的数据传给>——>父组件\", //是正确了 msg: 123,//报错了 }); const handler = () => { ctx.emit(\"childevent\", result.msg); }; return { result, handler, }; }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-15 20:12:17 "},"05订阅发布模式.html":{"url":"05订阅发布模式.html","title":"05订阅发布模式","keywords":"","body":" 手动 插件 订阅发布模式 js设计模式-订阅发布模式 eventBus.$emit(\"事件名\",数据) eventBus.$on(\"事件名\",(数据)=>{数据}) 手动 父组件 // src/App.vue import test from \"./components/test.vue\"; import eventBus from \"./utils/eventBus.js\"; export default { components: { test, }, setup() { eventBus.$emit(\"aevent\", \"我是父组件传给子组件的数据——>\"); eventBus.$emit(\"bevent\", \"我是父组件传给子组件的数据——>\"); }, }; 订阅发布写法 // src/utils/eventBus.js class EventBus { constructor() { this.list = []; } $emit(eventName, payload) { setTimeout(() => { this.list.forEach((item) => { if (item.eventName === eventName) { item.callBack(payload); } }); }, 0); } $on(eventName, callBack) { this.list.push({ eventName, callBack, }); $off(eventName) { this.list.forEach((item, idx) => { if (item.eventName === eventName) { // this.list.splice(idx, 1); this.list.splice(idx, item); } }); } } export default new EventBus(); 子组件 // src/components/test.vue 我是子组件 import eventBus from \"../utils/eventBus.js\"; export default { setup() { eventBus.$on(\"aevent\", (res) => { console.log(res); }); eventBus.$on(\"bevent\", (res) => { console.log(res); }); eventBus.$off(\"aevent\"); }, }; 插件 安装 npm npm install tiny-emitter --save 创建文件 // src/utils/event.js import emitter from 'tiny-emitter/instance' export default { $on: (...args) => emitter.on(...args), $once: (...args) => emitter.once(...args), $off: (...args) => emitter.off(...args), $emit: (...args) => emitter.emit(...args), } 父组件 // src/App.vue.vue import { onMounted } from \"vue\"; import test from \"./components/test.vue\"; import Bus from \"./utils/event.js\"; export default { components: { test, }, setup() { onMounted(() => { Bus.$emit(\"aevent\", \"我是父组件传给子组件的数据——>\"); }); }, }; 子组件 // src/components/test.vue 我是子组件 import { onMounted } from \"vue\"; import Bus from \"../utils/event.js\"; export default { setup() { Bus.$on(\"aevent\", (res) => { console.log(res); }); }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-17 20:25:37 "},"06计算属性.html":{"url":"06计算属性.html","title":"06计算属性","keywords":"","body":" 反转 输入框形式 调试 Computed 计算属性 反转 // src/App.vue import { computed, ref } from \"vue\"; export default { setup() { const result = ref(\"hello world\"); const reverseStr = computed(() => { return result.value.split(\"\").reverse().join(\"\").toUpperCase(); }); console.log(reversStr.value); return { reverseStr, }; }, }; 输入框形式 // src/App.vue import { computed, ref } from \"vue\"; export default { setup() { const result = ref(\"hello world\"); const reverseStr = computed({ get: () => { return result.value.split(\"\").reverse().join(\"\").toUpperCase(); }, set: (newVal) => { console.log(newVal); }, }); return { reverseStr, }; }, }; 调试 Computed 调试 Computed【意义上不大】 // src/App.vue import { computed, ref } from \"vue\"; export default { setup() { const result = ref(\"hello world\"); const reverseStr = computed({ get: () => { return result.value.split(\"\").reverse().join(\"\").toUpperCase(); }, set: (newVal) => { console.log(newVal); }, }); //调试用了 onTrack(e) { // 当 count.value 作为依赖被追踪时触发 //debugger console.log(e) }, onTrigger(e) { // 当 count.value 被修改时触发 //debugger console.log(e) } return { reverseStr, }; }, }; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-17 19:53:21 "},"07响应式计算和侦听.html":{"url":"07响应式计算和侦听.html","title":"07响应式计算和侦听","keywords":"","body":" watch和watchEffect watch watchEffect 停止监听 清除副作用 vit.config.配置 响应式计算和侦听 官网 watch和watchEffect watch vue3官方watchEffect // src/App.vue import { ref, watch } from \"vue\"; export default { setup() { const result = ref(\"hello world\"); watch( () => result.value, (newVal, oldVal) => { console.log(newVal); console.log(oldVal); } ); return { result, }; }, }; 监听-你发什么，他就回什么 // src/App.vue import { ref, watch } from \"vue\"; export default { setup() { const result = ref(\"hello world\"); watch( () => result.msg, (newVal, oldVal) => { console.log(newVal); console.log(oldVal); } ); return { result, }; }, }; watchEffect 官网：watchEffect import { reactive, watchEffect } from \"vue\"; export default { setup() { const result = reactive({ msg: \"hello\", msg2: \"world\", }); watchEffect(() => { console.log(result.msg); console.log(result.msg2); }); return { result, stopHandler, }; }, }; 停止监听 官网：停止侦听 停止监听 import { reactive, watchEffect } from \"vue\"; export default { setup() { const result = reactive({ msg: \"hello\", msg2: \"world\", }); const stop = watchEffect(() => { console.log(result.msg); console.log(result.msg2); }); const stopHandler = () => { stop(); }; //stop(); //这种调用，是不用按钮@click return { result, stopHandler, }; }, }; 清除副作用 // src/App.vue import { reactive, watchEffect } from \"vue\"; export default { setup() { const result = reactive({ num: 1, }); setInterval(() => { result.num++; }, 1000); const stop = watchEffect(async (onInvalidate) => { //停止监听，就执行这个 onInvalidate(() => { console.log(\"清除副作用\" + result.num); }); //没停止监听，就执行这个 console.log(\"执行副作用\" + result.num); }); //让他4秒钟停止监听 setTimeout(() => { stop(); }, 4000); return { result, }; }, }; vit.config.配置 官网：resolve.alias 路径配置 // 根目录 vit.config.js import path from \"path\"; export default defineConfig({ resolve: { alias: { \"@\": path.resolve(__dirname, \"src/\"), //路径配置 }, }, }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-17 20:22:58 "},"vue3_shop项目.html":{"url":"vue3_shop项目.html","title":"vue3_shop项目","keywords":"","body":" 1.初始化 1、创建项目 2、路由创建 安装 两个一起安装 配置 配置路径 引入 使用路由 父子组件传递 父传子 子传父 3、插件 UI框架 安装 全局引入组件 按需引入组件（推荐） 1. 安装插件 2. 配置插件 3. 引入组件 简单引入 温馨提示 其他插件 4、自动注册全局组件 5、类请求封装 安装Axios 创建引入使用 HttpRequest index constant 使用post\\get 2.搭建首页 1、Search 搜索 2、Swipe 轮播 3、Grid 宫格_分类 4、广告块 5、Swipe 轮播_推荐 8、Tabbar 标签栏 _底部 3.搭建列表页 1、NavBar 导航栏 2、Sidebar 侧边导航 4.搭建购物车 5.搭建用户页 vue3_shop项目 1.初始化 1、创建项目 搭建Vite 项目 兼容性注意 Vite 需要 Node.js (opens new window)版本 >= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。 使用 NPM: npm create vite@latest 使用 Yarn: yarn create vite 2、路由创建 安装 官网：vueRouter 官网：Vuex 两个一起安装 npm install vue-router@4 vuex@next -S # 或 yarn add vue-router@4 vuex@next -S 配置 //src/router/index.js import { createRenderer, createWebHashHistory } from \"vue\"; import { routes } from \"./commonRouter\"; export const router = createRenderer({ history: createWebHashHistory(), routes, }); export const setupRouter = (app) => { return app.use(router); }; //src/router/commonRoute.js export const router = [ { path: \"/\", alias: \"/home\", component: () => import(\"@/views/home/home.vue\"), }, { path: \"/list\", component: () => import(\"@/views/list/list.vue\"), }, { path: \"/shop\", component: () => import(\"@/views/shop/shop.vue\"), }, { path: \"/user\", component: () => import(\"@/views/user/user.vue\"), }, ]; 配置路径 //根目录vite.config.js import path from \"path\"; export default defineConfig({ plugins: [vue()], resolve: { alias: { \"@\": path.resolve(__dirname, \"src/\"), }, }, }); 引入 //src/main.js import { createApp } from \"vue\"; import App from \"./App.vue\"; import { router, setupRouter } from \"@/router/index.js\"; const app = createApp(App); //注册路由 setupRouter(app); //路由准备就绪后挂载App实例 router.isReady().then(() => app.mount(\"#app\")); 创建四个文件 // srcviews/home/home.vue 首页 // srcviews/list/list.vue // srcviews/shop/shop.vue // srcviews/user/user.vue 使用路由 // src/App.vue 父子组件传递 父传子 父组件 //src/views/home/home.vue 我是父组件数据 import { reactive } from \"vue\"; import test from \"./components/test.vue\"; const result =reactive({ msg:\"我是父组件传给——>子组件数据\" }) 子组件 //src/views/home/conponents/test.vue 我是子组件数据 const props = defineProps({ msg:{ type:String } }); 子传父 父组件 //src/views/home/home.vue 我是父组件数据 import test from \"./components/test.vue\"; const fn = (e) => { console.log(e); }; 子组件 //src/views/home/conponents/test.vue 我是子组件数据 按钮 import { reactive } from \"vue\"; const emit = defineEmits([\"childevent\"]); const result = reactive({ msg: \"我是子组件传给——>父组件数据\", }); const handler = () => { emit(\"childevent\", result.msg); }; 3、插件 UI框架 官网：vant 安装 > 可以通过 npm、 yarn 或 pnpm 进行安装： # Vue 3 项目，安装最新版 Vant npm i vant # 通过 yarn 安装 yarn add vant # 通过 pnpm 安装 pnpm add vant 全局引入组件 //src/main.js import Vant from 'vant'; import 'vant/lib/index.css'; app.use(Vant); 温馨提示：全局引入插件，是不用一个个引入组件了，直接使用 使用组件 //src/home/home.vue 首页 成功按钮 按需引入组件（推荐） 1. 安装插件 # 通过 npm 安装 npm i vite-plugin-style-import@1.4.1 -D # 通过 yarn 安装 yarn add vite-plugin-style-import@1.4.1 -D # 通过 pnpm 安装 pnpm add vite-plugin-style-import@1.4.1 -D 2. 配置插件 安装完成后，在 vite.config.js 文件中配置插件： // 根目录下 vite.config.js import vue from '@vitejs/plugin-vue'; import styleImport, { VantResolve } from 'vite-plugin-style-import'; export default { plugins: [ vue(), styleImport({ resolves: [VantResolve()], }), ], }; 3. 引入组件 复杂点 完成以上两步，就可以直接使用 Vant 组件了： // src/plugins/vant.js import { Button } from 'vant'; export default { Button, } // src/plugins/index.js import { Button } from \"./vant\"; export const setupPlugins = (app) => { return app.use(Button); } 简单引入 // src/plugins/index.js import { Button } from 'vant'; export const setupPlugins = (app) => { return app.use(Button); } 在main.js引入 //src/main.js import {setupPlugins} from \"@/plugins/index.js\" const app = createApp(App); //注册插件 setupPlugins(app); 温馨提示 # 安装 consola npm i consola # 或 yarn add consola 其他插件 在notion里点击链接 4、自动注册全局组件 // src/utils/autoRegisterCom.js import { defineAsyncComponent } from \"vue\"; const components = import.meta.glob(\"/src/components/*.vue\"); // 异步方式 export const $installComponents = (app) => { for (const [key, value] of Object.entries(components)) { const name = key.slice(key.lastIndexOf(\"/\") + 1, key.lastIndexOf(\".\")); //截取字符串 app.component(name, defineAsyncComponent(value)); //拿到就名字异步注册组件 } }; //src/utils/index.js import { $installComponents } from \"./autoRegisterCom.js\"; export const setupUtils = (app) => { return $installComponents(app); }; 使用方法 // src/main.js import { setupUtils } from \"@/utils/index.js\" //注册全局方法 setupUtils(app) 测试 //src/components/test.vue 全局测试组件 //src/views/home/home.vue 首页 5、类请求封装 安装Axios 官网：axios 半墙 npm install axios -S # 或 yarn add axios 创建引入使用 HttpRequest 创建：src/utils/Request/HttpRequest.js // 引入 import axios from \"axios\"; //定义方法 class HttpRequest { constructor(options) { this.http = axios.create(options); this.options = options; } // get请求 get(url, data) { return this.request({ method: \"GET\", url: url, params: { data, }, }); } // post请求 post(url, data) { return this.request({ method: \"POST\", url: url, data: { data, }, }); } // 并发请求 all(requestList) { return axios.all(requestList).then( axios.spread(function (...res) { return res; }) ); } // request请求 request(payload) { const { beforeRequest, beforeResponse, errorCapture } = this.options.extraConfig; const http = beforeRequest(this.http, payload); //请求前处理 return http .request(payload) .then((res) => { return beforeResponse(res); }) .catch((err) => { console.log(\"错误的代码:\" + err); errorCapture(err); }); } } export default HttpRequest; index 创建：src/utils/Request/index.js import HttpRequest from \"./HttpRequest.js\"; import { $constant } from \"@/config/constant.js\"; // 额外的配置信息 const extraConfig = { // 请求前处理 beforeRequest(res, payload) { return res; }, //响应前的处理 beforeResponse(res, payload) { let data; switch (res.status) { case $constant.statusCode.SUCCESS: // 成功的返回 data = res.data.data; break; case $constant.statusCode.REDIRECT: // 重定向 data = res.data.data; break; case $constant.statusCode.ERROR_WEB: // 前端报错 data = res.data.data; break; case $constant.statusCode.ERROR_JAVA: // 后端错误 data = res.data.data; break; default: break; } return data; }, errorCapture(err, payload) { //错误捕捉 return err; }, }; // 基本的配置信息 const baseConfig = { baseURL: $constant.baseURL, timeout: $constant.timeout, headers: { \"Content-Type\": $constant.ContentType.JSON, }, }; export const $http = new HttpRequest({ ...baseConfig, extraConfig: { ...extraConfig }, }); constant 创建：src/config/constant.js export const $constant = { baseURL: \"http://vt.ossjk.com/\", timeout: 60000, ContentType: { JSON: \"application/json\", FORM: \"application/x-www-form-urlencoded\", }, statusCode: { SUCCESS: 200, REDIRECT: 300, ERROR_WEB: 400, ERROR_JAVA: 500, }, }; 使用post\\get //src/home/home.vue 首页 import { onMounted, reactive } from \"vue\"; import { $http } from \"@/utils/Request/index.js\"; onMounted(() => { const getIndexInfo =()=>{ return $http.get(\"goods/getIndexInfo\").then((res)=>{ return res }) } const getCategoryList =()=>{ return $http.get(\"goods/getCategoryList\").then((res)=>{ return res }) } $http.all( [getIndexInfo()], [getCategoryList()] ).then((res)=>{ console.log(res[0]); console.log(res[1]); }) }), 2.搭建首页 官网：Vant 轻量、可靠的移动端 Vue 组件库 1、Search 搜索 引入组件 // src/plugins/vant.js import { Search } from 'vant'; app.use(Search); 使用组件 //src/views/home/components/search.vue export default {} //src/views/home/home.vue import { onMounted, reactive } from \"vue\"; import { $http } from \"@/utils/Request/index.js\"; import search from \"./components/search.vue\" const result = reactive({ data: {}, }); onMounted(async () => { let res = await $http.get(\"goods/getIndexInfo\"); result.data = res; console.log(result.data); }); 2、Swipe 轮播 引入组件 // src/plugins/vant.js import { Swipe, SwipeItem } from 'vant'; app.use(Swipe); app.use(SwipeItem); 使用组件 //src/views/home/components/swipe.vue const props = defineProps({ data: { type: Object, }, }); //图片地址更换 const filterImg = (str) => { return str.replace(\"http://oa.ossjk.cn/\", \"http://imgs.ossjk.cn/\"); }; //src/views/home/home.vue import { onMounted, reactive } from \"vue\"; import { $http } from \"@/utils/Request/index.js\"; import swiper from \"./components/swiper.vue\"; const result = reactive({ data: {}, }); onMounted(async () => { let res = await $http.get(\"goods/getIndexInfo\"); result.data = res; console.log(result.data); }); 3、Grid 宫格_分类 引入组件 // src/plugins/vant.js import { Grid, GridItem } from 'vant'; app.use(Grid); app.use(GridItem); 使用组件 //src/views/home/components/category.vue const props = defineProps({ data: { type: Object, required: true, }, }); const filterImg = (str) => { return str.replace(\"http://oa.ossjk.cn/\", \"http://imgs.ossjk.cn/\"); }; //src/views/home/home.vue import category from \"./components/category.vue\"; }); 4、广告块 //src/views/home/components/ad.vue const props = defineProps({ data: { type: Object, required: true, }, }); const filterImg = (str) => { return str.replace(\"http://oa.ossjk.cn/\", \"http://imgs.ossjk.cn/\"); }; //src/views/home/home.vue import ad from \"./components/ad.vue\"; 5、Swipe 轮播_推荐 刚引入过了，就用了，直接使用 //src/views/home/components/recommend.vue 商品推荐 ￥ ￥ const props = defineProps({ data: { type: Object, required: true, }, }); const filterImg = (str) => { return str.replace(\"http://oa.ossjk.cn/\", \"http://imgs.ossjk.cn/\"); }; /* 去掉轮播图中心点点点 */ :deep(.van-swipe__indicators){ display:none } .goods-content { font-size: 12px; overflow: hidden; text-overflow: ellipsis; /* white-space: nowrap; */ text-align: center; } .h3-cloro { color: rgb(216, 60, 216); } //src/views/home/home.vue import recommend from \"./components/recommend.vue\"; 8、Tabbar 标签栏 _底部 引入组件 // src/plugins/vant.js import { Tabbar, TabbarItem } from 'vant'; app.use(Tabbar); app.use(TabbarItem); 使用组件 //src/components/tabBar.vue 首页 列表页 购物车 会员中心 //src/views/home/home.vue import tabBar from \"../../components/tabBar.vue\" 3.搭建列表页 1、NavBar 导航栏 引入组件 // src/plugins/vant.js import { NavBar } from 'vant'; app.use(NavBar); 使用组件 //src/views/list/components/navbar.vue //src/views/list/list.vue import { onMounted, reactive } from \"vue\"; import { $http } from \"@/utils/Request/index.js\"; import tabBar from \"@/components/tabBar.vue\" import navbar from \"./components/navbar.vue\"; const result = reactive({ data: {}, }); onMounted(async () => { let res = await $http.get(\"goods/getCategoryList\"); result.data = res; console.log(result.data); }); 2、Sidebar 侧边导航 引入组件 // src/plugins/vant.js import { Sidebar, SidebarItem } from 'vant'; app.use(Sidebar); app.use(SidebarItem) 使用组件 //src/views/list/components/sidebar.vue 内容 1 内容 2 内容 3 内容 4 const props = defineProps({ data: { type: Object, required: true, }, }); const filterImg = (str) => { return str.replace(\"http://oa.ossjk.cn/\", \"http://imgs.ossjk.cn/\"); }; //src/views/list/list.vue import sidebar from \"./components/sidebar.vue\"; 4.搭建购物车 5.搭建用户页 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-21 09:51:11 "},"UniApp框架教程.html":{"url":"UniApp框架教程.html","title":"01UniApp框架教程","keywords":"","body":" 1、uView-2版本安装和创建项目 2、tabBar 3、渲染数据 4、tabBar 5、插件 6、uView-UI使用 使用组件 7、uView-1版本安装&使用 底部导航栏 UniApp框架教程 1、uView-2版本安装和创建项目 uni-app官网 下载-HBuilderX 环境安装 全局安装vue-cli npm install -g @vue/cli 创建uni-app 使用正式版（对应HBuilderX最新正式版） vue create -p dcloudio/uni-preset-vue my-project 使用alpha版（对应HBuilderX最新alpha版） vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 使用Vue3/Vite版 创建以 javascript 开发的工程（如命令行创建失败，请直接访问gitee下载模板） npx degit dcloudio/uni-preset-vue#vite my-vue3-project 创建以 typescript 开发的工程（如命令行创建失败，请直接访问gitee下载模板） npx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project 此时，会提示选择项目模板（使用Vue3/Vite版不会提示，目前只支持创建默认模板），初次体验建议选择 hello uni-app 项目模板，如下所示： 自定义模板 选择自定义模板时，需要填写 uni-app 模板地址，这个地址其实就是托管在云端的仓库地址。以 GitHub 为例，地址格式为 userName/repositoryName，如 dcloudio/uni-template-picture 就是下载图片模板。 更多支持的下载方式，请参考这个插件的说明：download-git-repo 2、tabBar \"tabBar\": { \"custom\": false, \"color\": \"#fff\", \"selectedColor\": \"#e3e3e3\", \"backgroundColor\": \"#00b26a\", \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./pages/img/b1.png\", \"selectedIconPath\": \"./pages/img/b1.png\" }, { \"pagePath\": \"pages/test/test\", \"text\": \"测试\", \"iconPath\": \"/pages/img/b2.png\", \"selectedIconPath\": \"/pages/img/b2.png\" } ] }, 3、渲染数据 简单渲染 //pages/index/index.vue export default { data() { return { title: \"Hello\", }; }, }; 数组渲染 //pages/index/index.vue export default { data() { return { arr: [1, 2, 3, 4, 5], }; }, }; 4、tabBar \"tabBar\": { \"custom\": false, \"color\": \"#fff\", \"selectedColor\": \"#e3e3e3\", \"backgroundColor\": \"#00b26a\", \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./pages/img/b1.png\", \"selectedIconPath\": \"./pages/img/b1.png\" }, { \"pagePath\": \"pages/test/test\", \"text\": \"测试\", \"iconPath\": \"/pages/img/b2.png\", \"selectedIconPath\": \"/pages/img/b2.png\" } ] }, 5、插件 luch-request 插件安装路径，都放在这个文件plugins 配置 //utils/request.js import Request from '@/plugins/luch-request/index.js' // 下载的插件 export const http = new Request(); 用法 import {http} from \"@/utils/request.js\" expect default{ onLoad(){ http.request({ url:\"http://vt.ossjk.com/goods/getIndexInfo\" }).then((res)=>{ console.log(res) }) } } 6、uView-UI使用 官网：uView 插件安装路径，都放在这个文件plugins 下载安装 配置步骤 1. 引入uView主JS库 // main.js import uView from '@/plugins/uview-ui' Vue.use(uView) 2. 在引入uView的全局SCSS主题文件 //根目录的uni.scss /* uni.scss */ @import '@/plugins/uview-ui/theme.scss'; 3. 引入uView基础样式 //在根目录App.vue中首行的位置引入 /* 注意要写在第一行，同时给style标签加入lang=\"scss\"属性 */ @import \"@/plugins/uview-ui/index.scss\"; 4. 配置easycom组件模式 // pages.json \"easycom\": { \"^u-(.*)\": \"@/plugins/uview-ui/components/u-$1/u-$1.vue\" }, 使用组件 Button 按钮 7、uView-1版本安装&使用 先安装uniapp-1版本 uView安装地址 首先下载压缩包，然后解压到plugins文件里面 方式配置地址 配置步骤跟以上一样 底部导航栏 封装 //components/tabBar.vue export default { data() { return { list: [{ iconPath: \"home\", selectedIconPath: \"home-fill\", text: '首页', customIcon: false, pagePath:\"/pages/index/index\" }, { iconPath: \"account\", selectedIconPath: \"account-fill\", text: '我的', customIcon: false, pagePath:\"/pages/list/list\" }, ], current: 0 } }, } //根目录下pages.js \"pages\": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages { \"path\": \"pages/index/index\", \"style\": { \"navigationBarTitleText\": \"首页\" } }, { \"path\": \"pages/list/list\", \"style\": { \"navigationBarTitleText\": \"列表\" } } ], \"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" }, { \"pagePath\": \"pages/list/list\", \"text\": \"测试\" } ] }, 使用 //pages/index/index.vue //pages/list/list.vue import tabBar from \"@/components/tabBar.vue\" export default { components:{ tabBar, } } Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-26 17:37:49 "},"微信小程序.html":{"url":"微信小程序.html","title":"02微信小程序","keywords":"","body":" 小程序平台 开发者id 开发者工具 小程序项目目录 全局配置和局部配置 vscode编辑器插件 逻辑层 生命周期 数据渲染 列表渲染 列表渲染别名设置 多层列表渲染 条件渲染 事件绑定 事件对象 路由跳转方式 路由传参 非tab页传参数 tab页传参数 模块化 另外一种模块化 全局属性和全局方法 小程序的promise事件与h5的区别 小程序提供的api能力 本地存储 请求接口 请求报文 接口-回调函数写法 接口-promise写法 接口-async await写法 组件 创建自定义组件 插槽 样式隔离 组件的data属性 组件之间的数据传递 父传子 子传父 非父子 获取子组件实例 组件内数据监听 vant-ui安装步骤 小程序登录、用户和信息相关接口最新修改 微信小程序 微信小程序，小程序的一种，英文名Wechat Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 小程序平台 1、公众平台 开发文档（项目本身是小程序、发微信公众、文档、微信小游戏） 公众平台 2、开放平台 开发文档（项目本身不是小程序，但是需要用到小程序的功能） 开放平台 3、开放社区 社区功能类似百度贴吧（微信发布新的版本会在这里进行通知、提问问题） 开放社区 开发者id appid 项目的唯一id openid unionid 开发者工具 一个微信官方自带的编辑器 稳定版 Stable Build | 微信开放文档 小程序项目目录 pages 项目页面 utils 工具函数 app.js 项目的唯一出口，也是全局js文件 app.json app全局配置文件 app.wxss app全局样式 project.config.json 项目配置文件 sitemap.json 项目描述文件，无意义 微信页面里面的4种文件 .js 当前页的js文件 .json 当前页面的配置文件 .wxml 当前页面的html文件 .wxss 当前页面的样式文件 全局配置和局部配置 全局配置是整个小程序的配置，里面的属性会作用于整个小程序 局部配置(页面配置)是当前页面的小程序配置，里面的属性只会作用于当前页面 vscode编辑器插件 //直接搜索对应名称下载插件 minapp 微信小程序标签、属性的智能补全 wechat-snippet 微信小程序代码片段补全 wxml 微信小程序wxml格式化以及高亮组件(高度自定义) 逻辑层 // app.js 小程序关闭后并不是真正的关闭，而是进入后台，目的是方便重新打开时候的速度。进入后台大概是十几分钟后 才是真正的关闭。 App({ onLaunch (options) { //第一次进入小程序，或者杀掉后台之后重新进入小程序，就会执行这里的代码 }, onShow (options) { // 小程序没被杀掉之前，重新进入小程序就会执行这里的代码 }, onHide () { // 关闭小程序执行的代码 }, onError (msg) { //小程序报错会执行这里的代码 }, globalData: 'I am global data'//全局数据 }) 生命周期 全局生命周期 onLaunch 第一次全局执行 onShow 第一次执行，或者关闭后重新打开后执行 onHide 关闭小程序，但是没完全关闭，切换到后台 onError 小程序报错 页面生命周期 onLoad 当前页面第一次加载的时候 onShow 第一次执行当前页面，或者关闭后重新打开后执行 onReady 当渲染页（视图层-wxml）加载完毕执行 onHide 关闭当前页面，但是没完全关闭，切换到后台 onUnload 销毁当前页 onPullDownRefresh 下拉刷新 onReachBottom 页面触底时执行，一般用于做上拉加载 onShareAppMessage 分享页面执行 onPageScroll 当前页面滚动执行 onResize 放大缩小页面的时候执行 onTabItemTap 点击底部导航栏触发 组件生命周期 created 创建组件时执行 attached 被插入到父组件节点时执行 ready 渲染完后执行 moved 移动组件节点 detached 从父组件节点移除时执行 error 组件方法抛出错误时执行 数据渲染 // index.js // 获取应用实例 const app = getApp() Page({ data: {//这里写的所有数据都会直接在wxml页面渲染 msg:{ name:\"小明\" }, message:\"hello 微信小程序\" } }) 列表渲染 // index.js // 获取应用实例 const app = getApp() Page({ data: { arr:[\"小明\",\"小红\",\"小丽\"] } }) //arr是渲染的数组，item是数组里面的每一个成员,index是数组的成员的索引值 列表渲染别名设置 多层列表渲染 // index.js // 获取应用实例 const app = getApp() Page({ data: { arr3: [ { countryName: \"中国\", cities: [{ cityName: \"广州\" }, { cityName: \"深圳\" }, { cityName: \"上海\" }] }, { countryName: \"美国\", cities: [{ cityName: \"华盛顿\" }, { cityName: \"纽约\" }, { cityName: \"洛杉矶\" }] }, { countryName: \"日本\", cities: [{ cityName: \"东京\" }, { cityName: \"北海道\" }, { cityName: \"名古屋\" }] } ] } }) 条件渲染 // index.js // 获取应用实例 const app = getApp() Page({ data: { bool:false }, fn(){ this.setData({ bool:!this.data.bool }) } }) 首页 内容 按钮 事件绑定 // index.js // 获取应用实例 const app = getApp() Page({ data: { }, fn(){ console.log(123) } }) 内容 事件对象 currentTarget 绑定该事件的元素 target 触发事件的元素 //案例中 currentTarget是container。target是test。 //案例中 currentTarget是test。target是test。 路由跳转方式 1、wx.navigateTo 打开新页面(不能打开tab页) 跳转到测试页 2、wx.switchTab Tab 切换(只能打开tab页) 跳转到日志页 3、wx.redirectTo 页面重定向(没有历史记录,不能执行返回上一页这种操作) 4、wx.navigateBack 返回上一页 // pages/test/test.js Page({ goBack(){ wx.navigateBack() } }) 路由传参 非tab页传参数 // index.js // 获取应用实例 const app = getApp() Page({ go(){ let id = 2 wx.navigateTo({ url: `/pages/index2/index2?id=${id}`, success: (result)=>{ } }); } }) // pages/index2/index2.js Page({ onLoad: function (options) { console.log(options) } }) tab页传参数 1、使用全局变量传数据 // index.js // 获取应用实例 const app = getApp() Page({ go(){ let id = 1 app.globalData.id = id wx.switchTab({ url: '/pages/index3/index3' }); } }) // pages/index3/index3.js const app = getApp() Page({ onLoad: function () { console.log(app.globalData.id) } }) 2、使用storage存数据 // index.js // 获取应用实例 const app = getApp() Page({ go(){ wx.setStorageSync(\"id\", 1); wx.switchTab({ url: '/pages/index3/index3?id', }); } }) // pages/index3/index3.js const app = getApp() Page({ onLoad: function () { console.log(wx.getStorageSync(\"id\")) } }) 模块化 最新版的小程序可以使用es6语法 微信小程序采用的是node.js的语法(commonjs规范) 补充知识点：js的模块化有4个(commonjs\\es6\\amd\\cmd) // index.js // 获取应用实例 const app = getApp() const test = require(\"../../utils/test.js\") Page({ data: { }, fn(e){ }, onShow(){ test.fn() test.fn2() } }) //test.js let fn = function(){ console.log(\"测试\") } let fn2 = function(){ console.log(\"测试2\") } // module.exports.fn = fn // module.exports.fn2 = fn2 // 上面的代码等价于下面这段代码 // { // fn:function(){}, // fn2:function(){} // } // 简写 module.exports = { fn, fn2 } 另外一种模块化 // index.js // 获取应用实例 const app = getApp() const test = require(\"../../utils/test.js\") // 上面代码的test等价于 // {fn:function(){},fn2:function(){}} // 所以可以使用es6的结构赋值 const {fn,fn2} = require(\"../../utils/test.js\") Page({ data: { }, fn(e){ }, onShow(){ fn() fn2() } }) //test.js exports.fn = function(){ console.log(\"测试\") } exports.fn2 = function(){ console.log(\"测试2\") } 全局属性和全局方法 // app.js App({ globalData: { message:\"hello world\",//全局属性 fn:function(){//全局方法 console.log(\"hi\") } } }) // index.js // 获取应用实例 const app = getApp() Page({ onShow(){ console.log(app.globalData.message) app.globalData.fn() console.log(app)//小程序实例 console.log(this)//打印的是当前页面对象，不是小程序实例 } }) 注意：在页面打印的this不是小程序实例，所以不要使用跟vue一样的this.xxx获取全局属性和方法。 小程序的promise事件与h5的区别 //事件轮询机制（事件循环机制） new Promise() 宏事件 .then() 微事件 function fn(){ return new Promise((resolve,reject)=>{ resolve() }) } fn().then(()=>{ }) //在小程序里面，.then()属于宏事件 //async await一样 小程序提供的api能力 所有的小程序api都是调用wx.xxx的形式进行调用 本地存储 // 同步 wx.setStorageSync(\"msg\", \"hello\"); console.log(wx.getStorageSync(\"msg\")); // 异步 wx.setStorage({ key: 'msg2', data: \"hi\", success: (result)=>{ console.log(1) }, fail: ()=>{}, complete: ()=>{ console.log(2) } }); wx.getStorage({ key: 'msg2', success: (result)=>{ console.log(result.data) }, fail: ()=>{}, complete: ()=>{ console.log(123) } }); 请求接口 wx.request({ url: '', header: {'content-type':'application/json'}, method: 'GET', success: (result)=>{ console.log(result) }, fail: ()=>{}, complete: ()=>{} }); 请求报文 请求报文 请求行 general：Request URL 请求地址、Request Method 请求类型、Status Code状态码 1xx 请求中 2xx 发送成功 3xx 重定向 4xx 请求错误（前端错误） 404 地址错 5xx 服务端错误(也有可能是前端发送的数据错) 请求头 content-type 发送的请求文本类型 application/json JSON类型数据 application/x-www-form-urlencoded 表单类型数据 token 令牌-识别登录用户的状态 请求体 发送的数据，如果是post会在这里直接显示，如果是get会在地址栏显示。 响应报文 响应行 响应头 响应体 返回给前端的数据 http的缺陷，无法识别状态 接口-回调函数写法 wx.request({ url: '', header: { 'content-type': 'application/json' }, data: { goodsId: result.data.data.slides[0].goodsId }, method: 'POST', success: (result) => { console.log(result) }, fail: () => { }, complete: () => { } }) 接口-promise写法 接口-async await写法 组件 可以复用的功能模块。 原生组件，小程序自带的组件。 cover-image | 微信开放文档 第三方组件库ui，elment\\ant-dsign\\vant 自定义组件 创建自定义组件 创建一个button目录，在里面再创建一个component组件 //button.wxml 测试按钮 在使用的页面的json文件引入 //index.json { \"usingComponents\": { \"mybutton\":\"../../components/button/button\" } } 插槽 哈哈 呵呵 嘿嘿 多个插槽 李大爷 李大妈 //button.wxml 内容 // components/button/button.js Component({ options: { multipleSlots: true // 在组件定义时的选项中启用多slot支持 }, }) 样式隔离 默认情况下，父组件的样式无法更改子组件的样式，除非设置styleIsolation属性。 Component({ options: { styleIsolation: 'isolated' } }) isolated默认属性，父组件无法影响到子组件 apply-shared 父组件可以影响到子组件 shared父子组件可以互相影响 组件的data属性 组件的data属性和page的data属性一模一样,但是新版的微信小程序的方法建议写在methods里面 // components/button/button.js Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { msg:\"hello 组件\" }, /** * 组件的方法列表 */ methods: { fn(){ this.setData({ msg:\"hi 组件\" }) } } }) 组件之间的数据传递 父传子 // components/button/button.js Component({ /** * 组件的属性列表 */ properties: { a:String,//props校验-检查props类型 b:String }, /** * 组件的初始数据 */ data: { msg:\"hello 组件\" }, /** * 组件的方法列表 */ methods: { fn(){ console.log(this.data.msg) console.log(this.properties.a)//等价于下面 console.log(this.data.a) } } }) 子传父 流程: 1、子组件button点击，触发fn函数 2、子组件fn函数触发triggerEvent 3、triggerEvent添加了一个childevent事件，并且带上参数，通过事件冒泡传给父组件index 4、父组件绑定childevent事件，触发自己的fathterfn函数。bind:childevent=\"fathterfn\" 5、父组件的fathterfn获取到e.detail数据 button组件 //button.wxml 按钮 // components/button/button.js Component({ data: { msg:\"子组件的数据\" }, methods: { childfn(){ //通过triggerEvent提交一个childevent事件，让父组件可以直接使用childevent事件 this.triggerEvent(\"childevent\",this.data.msg) } } }) index页面 //index.wxml //父组件通过子组件提交上来的childevent事件触发自己的方法，以此接收子组件提交的数据 // index.js // 获取应用实例 const app = getApp() Page({ fathterfn(e){ console.log(e.detail) } }) 非父子 eventBus js订阅发布模式 //utils/eventBus.js class EventBus { constructor() {//构造器 this.list = []//存书的地方 } $on(eventName, fn) {//订阅器-给订阅者（小明）记录他需要订阅的书籍以及他本人的信息 if(eventName){ this.list.push({ \"eventName\": eventName, eventHandler: fn }) } } $emit(eventName, data) {//发布器-给订阅者(小明)发布他所订阅的书籍 if(eventName){ this.list.forEach((item)=>{ if(item.eventName === eventName){ item.eventHandler(data) } }) } } $off(eventName){//取消发布 if(this.list.length){ this.list.forEach((item,idx)=>{ if(item.eventName === eventName){ this.list.splice(idx,1) } }) } } } module.exports = new EventBus() // components/acom/acom.js const eventBus = require(\"../../utils/eventBus.js\") Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { msg: \"a组件的数据\", }, /** * 组件的方法列表 */ methods: { fn() { eventBus.$emit(\"aevent\",this.data.msg)//发布b组件订阅的数据 } } }) // components/bcom/bcom.js const eventBus = require(\"../../utils/eventBus.js\") Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { }, /** * 组件的方法列表 */ methods: { }, lifetimes:{ attached(){ eventBus.$on(\"aevent\",(res)=>{//b组件订阅aevent事件 console.log(res) }) eventBus.$off(\"aevent\")//取消订阅 } } }) 获取子组件实例 // index.js // 获取应用实例 const app = getApp() Page({ data: { }, fn(){ let acom = this.selectComponent(\".acom\")//通过选择器获取子组件的实例 acom.fn() } }) 组件内数据监听 // components/acom/acom.js Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { num:1, num2:2, num3:3 }, /** * 组件的方法列表 */ methods: { fn() { this.setData({ num:2 }) } }, observers:{ 'num':function(val){ console.log(val) } } }) vant-ui安装步骤 1、通过npm安装vant npm i @vant/weapp -S --production 2、修改 app.json 将 app.json 中的\"style\": \"v2\"去除，小程序的新版基础组件强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。 3、修改 project.config.json { ... \"setting\": { ... \"packNpmManually\": true, \"packNpmRelationList\": [ { \"packageJsonPath\": \"./package.json\", \"miniprogramNpmDistDir\": \"./\" } ] } } 4、构建npm包 打开微信开发者工具，点击 工具 ->构建 npm，并勾选 使用 npm模块 选项，构建完成后，即可引入组件。 5、使用 // 通过 npm 安装 // app.json \"usingComponents\": { \"van-button\": \"@vant/weapp/button/index\" } 在任意地方使用组件 按钮 小程序登录、用户和信息相关接口最新修改 小程序登录、用户信息相关接口调整说明 | 微信开放社区 1、(修改了获取unionId方式) 如果已经在微信开放平台进行绑定， 可以直接通过wx.login获取的登录凭证， 拿到unionID 旧版： wx.login获取code 后端接口获取openid和sessionKey 微信接口获取敏感信息 调用后端获取敏感信息（unionID） 新版： wx.login获取code 传code给后端接口，返回openid、sessionKey、unionID 2、wx.getUserInfo和 获取的是匿名数据 3、高版本7.0.9新增getUserProfile接口， 可获取用户头像、昵称、性别及地区信息， 每次用这个接口都需要用户确认， 老版本还是可以使用getUserInfo 4、wx.getUserProfile()接口可以直接获取用户信息， 每次用户授权，不需要再自己写授权 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:44:54 "},"小程序教程.html":{"url":"小程序教程.html","title":"03小程序教程","keywords":"","body":" 小程序平台 底部菜单栏 路由和配置app.js 渲染数据 数据列表 数组列表 事件传参 修改数据 增删改查 小程序页面传参数 第一种 第二种 第三种 组件数据传输 1、使用组件和自定义组件 2、插槽 3、父传子 4、子传父 5、非父子eventBus* 6、非父子globalData* 7、请求 8、数据缓存 9、微信登陆 小程序教程 小程序平台 1、公众平台 开发文档（项目本身是小程序、发微信公众、文档、微信小游戏） 公众平台 2、开放平台 开发文档（项目本身不是小程序，但是需要用到小程序的功能） 开放平台 3、开放社区 社区功能类似百度贴吧（微信发布新的版本会在这里进行通知、提问问题） 开放社区 底部菜单栏 { \"tabBar\": { \"custom\": false, \"color\": \"#fff\", \"selectedColor\": \"#e3e3e3\", \"backgroundColor\": \"#00b26a\", \"list\": [ { \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./pages/img/b1.png\", \"selectedIconPath\": \"./pages/img/b1.png\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\", \"iconPath\": \"./pages/img/b2.png\", \"selectedIconPath\": \"./pages/img/b2.png\" } ] } } 路由和配置app.js //app.js { \"pages\": [ \"pages/index/index\", \"pages/logs/logs\", \"pages/test/test\" ], \"tabBar\": { \"custom\": false, \"color\": \"#fff\", \"selectedColor\": \"#e3e3e3\", \"backgroundColor\": \"#00b26a\", \"list\": [ { \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"./pages/img/b1.png\", \"selectedIconPath\": \"./pages/img/b1.png\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\", \"iconPath\": \"./pages/img/b2.png\", \"selectedIconPath\": \"./pages/img/b2.png\" } ] }, \"usingComponents\": {}, \"window\": { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#009056\", \"navigationBarTitleText\": \"微信测试\", \"navigationBarTextStyle\": \"white\" }, \"style\": \"v2\", \"sitemapLocation\": \"sitemap.json\" } 渲染数据 数据列表 //pages/index/index.js Page({ data: { msg: \"hello 小程序\", }, }); 数组列表 //pages/index/index.js Page({ data: { arr: [\"张三\", \"李四\", \"老王\"], }, }); 事件传参 案例1 点击 //pages/index/index.js Page({ data: {}, handler() { console.log(123); }, }); 案例2 点击 //pages/index/index.js Page({ data: {}, handler(event) { // console.log(event); console.log(event.target.dataset.value); }, }); 修改数据 案例1 添加数据 //pages/index/index.js Page({ data: { num: 1, }, add() { this.setData({ num: this.data.num + 1, }); }, }); 案例2 多行添加数据 //pages/index/index.js Page({ data: { num: 1, arr: [{ num: 1 }, { num: 1 }, { num: 1 }], }, add() { this.data.arr.forEach((item, idx) => { this.setData({ [`arr[${idx}].num`]: item.num + 1, }); }); }, }); 增删改查 增 添加按钮 Page({ data: { num: 1, arr: [{ num: 1 }, { num: 1 }, { num: 1 }], }, add() { this.data.arr.forEach((item, idx) => { this.setData({ [`arr[${idx}].num`]: item.num + 1, }); }); }, }); 删 删除 Page({ data: { num: 1, arr: [{ num: \"张三\" }, { num: \"李四\" }, { num: \"老王\" }], }, remove(event) { let idx = event.target.dataset.idx; let newArr = this.data.arr; newArr.splice(idx, 1); this.setData({ arr: newArr, }); }, }); 改 修改 Page({ data: { num: 1, arr: [{ num: \"张三\" }, { num: \"李四\" }, { num: \"老王\" }], }, update(event) { let idx = event.target.dataset.idx; this.setData({ [`arr[${idx}]`]: { name: \"修改\" }, }); }, }); 小程序页面传参数 第一种 在地址栏【父组件】 跳转测试页 js文件【子组件】 //pages/test/test.js Page({ onLoad(options) { console.log(options); }, }); 第二种 父组件 跳到测试页 //pages/index/index.js Page({ toTest() { wx.navigateTo({ url: \"/pages/test/test?name=张三&age=18\", }); }, }); 子组件 //pages/test/test.js Page({ onLoad(options) { console.log(options); }, }); 第三种 父组件 跳到测试页 //pages/index/index.js Page({ toTest() { wx.navigateTo({ url: \"/pages/test/test\", events: { xxx: function (data) { console.log(data); }, }, success(res) { res.eventChannel.emit(\"xxx\", { data: \"test\" }); }, }); }, }); 子组件 //pages/test/test.js Page({ onLoad() { const eventChannel = this.getOpenerEventChannel(); eventChannel.on(\"xxx\", function (data) { console.log(data); }); }, }); 组件数据传输 自动轮播 1、使用组件和自定义组件 //1、设置组件为true //components/acom.json { \"component\": true, \"usingComponents\": {} } //2、在使用的地方配置路径 //pages/index/index.js { \"usingComponents\": { \"acom\": \"/components/acom\" } } //3、在你用在使用即可 //pages/index/index.wxml //然后在components/acom.wxml 测试组件 2、插槽 作用域插槽没有 //components/acom.wxml 我是自定义组件 //components/acom.js Component({ options: { multipleSlots: true, // 在组件定义时的选项中启用多slot支持 }, }) //pages/index/index.wxml 组件的自定义a 组件的自定义b 3、父传子 父 //pages/index/index.wxml //pages/index/index.js Page({ data: { msg: \"我是父组件传给——>\", }, }); 子 //components/acom.wxml 我是子组件 //components/acom.js Component({ properties: { msg: { type: String, }, }, }) 4、子传父 父 //pages/index/index.wxml //pages/index/index.js Page({ fn(event) { console.log(event.detail); }, }); 子 //components/acom.wxml 我是子组件 按钮 //components/acom.js Component({ methods: { handler() { this.triggerEvent(\"childevent\", \"这是子传父\"); }, }) 5、非父子eventBus* //pages/index/index.json { \"usingComponents\": { \"acom\": \"/components/acom/acom\", \"bcom\": \"/components/bcom/bcom\" } } //pages/index/index.wxml //utils/eventBus.js class EventBus { constructor() { this.list = []; } //发布 $emit(eventName, options) { setTimeout(() => { this.list.forEach((item) => { if (item.eventName === eventName) { item.callBack(options); } }); }, 0); } //订阅 $on(eventName, callBack) { this.list.push({ eventName, callBack }); console.log(this.list); } } export default new EventBus(); 6、非父子globalData* //app.js App({ globalData: \"hello world\", }) //pages/test/test.wxml //componentns/acom/acom.wxml 去测试页 //componentns/acom/acom.js const ctx = getApp(); Component({ methods: { totest() { wx.switchTab({ url: \"/pages/test/test\", success() { ctx.globalData = \"hi world\"; }, }); }, }, }); //componentns/bcom/bcom.js Component({ lifetimes: { attached() { $eventBus.$on(\"myevent\", (res) => { console.log(res); }); }, }, }); 7、请求 //components/acom/acom.js Component({ lifetimes: { attached() { wx.request({ url: \"http://vt.oosjk.com/goods/getIndexInfo\", success: (res) => { console.log(res); }, }); }, }, }) 8、数据缓存 同步 //components/acom/acom.js Component({ lifetimes: { attached() { wx.setStorageSync(\"name\", 123); }, }, }) 异步 //components/acom/acom.js Component({ lifetimes: { attached() { wx.setStorage({ // key: \"msg\", // data: \"hello world\", key: \"arr\", data: [{ name: \"张三\", age: 18 }], }); }, }, }) 9、微信登陆 Page({ onShow() { // 登入 wx.login({ success(res) { // 后端给的接口 wx.request({ url: \"http://xxx接口\", data: { param: { code: res.code, } }, // 然后就可以 success(res) { console.log(res) } }) } }) } }) Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-26 17:34:17 "},"phase04.html":{"url":"phase04.html","title":"Phase IV","keywords":"","body":"正在修复中，请稍待... Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"testing.html":{"url":"testing.html","title":"Testing","keywords":"","body":"Welcome to my world Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"weekly.html":{"url":"weekly.html","title":"Weekly","keywords":"","body":" Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试01.html":{"url":"每周测试01.html","title":"每周测试01","keywords":"","body":" 1、meta标签用来做什么的 2、使用弹性布局进行水平和垂直居中 3、行内元素、块级元素、行内块级元素有什么区别？ 4、讲述下相对定位，绝对定位，固定定位的区别 5、写出浏览器的内核有哪些 6、说明CSS选择器的权重，以及其显示优先顺序 7、使用内行块级实现元素的水平和垂直居中 8、使用定位进行水平和垂直居中 9、什么时候会出现浮动塌陷？如何解决浮动塌陷？ 10、什么时候会出现边距塌陷？如何解决边距塌陷？ 每周小测试01 1、meta标签用来做什么的 meta标签是HTML语言head区域的一个辅助性标签,常用于定义页面的说明,关键字,最后修改的日期和其他的元数据。 2、使用弹性布局进行水平和垂直居中 display:flex; justify-content; align-items:center; 3、行内元素、块级元素、行内块级元素有什么区别？ 1） 块标签：独自占领一行、可以进行宽高的数值的设定； 2） 行标签：在一行内显示、不可以进行宽高的数值设定； 3） 行内块标签：能和其他元素待在一行，能设置宽高； 4、讲述下相对定位，绝对定位，固定定位的区别 相对定位 position: relative; 相对于自己定位。 绝对定位 position: absolute; 相对于有相对定位的父级元素进行定位，没有的时候就相对于body。 固定定位 position: fixed; 相对于浏览器定位。 5、写出浏览器的内核有哪些 浏览器内核 谷歌的chrome浏览器：旧 webkit 新 blink 苹果的safari浏览器：webkit 火狐的firefox浏览器：moz 欧朋浏览器： o 微软的ie浏览器： ms 微软的edge浏览器 Chromium 6、说明CSS选择器的权重，以及其显示优先顺序 css优先级（权重） 作用范围越小，权重越高。 同样的作用范围，后面的样式覆盖前面的样式。 7、使用内行块级实现元素的水平和垂直居中 text-align: center; //文本的水平居中 vertical-align: middle;//垂直居中 8、使用定位进行水平和垂直居中 div{ position:relative; } p{ position:absolute; width:100px; height:100px; left:50%; top:50%; margin-left:-50px; //这两行代码也可以替换成 margin-top:-50px; //transform:translate(-50%,-50%); } 9、什么时候会出现浮动塌陷？如何解决浮动塌陷？ .clearFix::after{ content: \"\";/*内容为空*/ visibility: hidden;/*隐藏*/ height: 0;/*高度为0*/ display: block;/*转位块级元素*/ clear: both;/*清除浮动*/ } 10、什么时候会出现边距塌陷？如何解决边距塌陷？ 在父级元素添加 overflow:hidden; Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:35:26 "},"每周测试02.html":{"url":"每周测试02.html","title":"每周测试02","keywords":"","body":" 函数闭包特性 数组里的变异方法 数组的操作交并补差 js里的数据类型 css样式 HTML里的元素区别 css样式 字符串 日期对象 字符串-数组 每周小测试 函数闭包特性 1、什么是闭包？用代码实现一个闭包 //当一个函数可以访问另外一个函数的作用域的时候，这个函数就被称为闭包 function fn(){ var a = 1 return function(){ console.log(a) } } var f = fn() f() 数组里的变异方法 2、写出数组的变异方法有哪些 删除最后一个 pop 添加最后一个 push 删除第一个 shift 添加第一个 unshift 所有都可以使用 splice 数组的操作交并补差 3、计算出以下数组的并集。let arr = [1,2,3,4,5] arr2 = [2,4,6,8] let arr = [1, 2, 3, 4, 5]; let arr2 = [2, 4, 6, 8]; var arr3 = arr.concat(arr2) console.log([...new Set(arr3)]); js里的数据类型 4、请写出js的数据类型有哪几种 数字 number; 字符串 string; 布尔值 boolean; 空值 null; 未定义 undefined; 唯一值 symbol; 对象 object; css样式 5、使用弹性布局进行水平和垂直居中 display: flex; align-items: center; justify-content: center; HTML里的元素区别 6、行内元素、块级元素、行内块级元素有什么区别？ 行内元素：不会自动换行，不可以设置宽高 块级元素：会自动换行，可以设置宽高 行内块级元素：不会自动换行，可以设置宽高 css样式 7、相对定位，绝对定位，固定定位有什么区别 相对定位是相对于自己定位 绝对定位是相对于有相对定位的父级元素进行定位，没有时就相对于body 固定定位是相对于浏览器进行定位 字符串 8、如何把字符串转换成数组？ var arr = \"hello world\" consloe.log(arr.split(\"\")) 日期对象 9、格式化当前日期，yyyy-mm-dd var str = \"2021-12-17\"; function fn(str,sign = \"-\") { var arr = str.split(\"-\"); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year,month,date)); } fn(str) 字符串-数组 10、把字符串hello world转化成反序写法(dlrow olleh) var str = \"hello world\" console.log(str.split(\"\").reverse().join(\"\")); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试03.html":{"url":"每周测试03.html","title":"每周测试03","keywords":"","body":" 1、使用正则匹配HH: mm(24小时制) 2、使用正则匹配yyyy - mm - dd 3、下列字符串中，出现次数最多的字母是哪个？ 4、什么是事件委托？有什么作用？ 5、计算出以下数组的差集。 6、计算出 7、事件传播有哪几个阶段？ 8、json字符串和json对象如何转换？ 9、格式化当前日期，yyyy - mm - dd 10、currentTarget和target有什么区别？ 11、请写出web浏览器缓存机制有哪几种？分别有什么区别 12、计算出以下数组的补集。 13、使用setTimeout实现10至1的打印，每次减1，到1的时候停止打印 14、边距塌陷如何解决 15、如何阻止事件的默认行为 每周测试 1、使用正则匹配HH: mm(24小时制) var str =\"22:00\"; var reg =/^[0-1][0-9]|[2][0-3]:[0-5][0-9]$/ console.log(reg.test(str));//true 2、使用正则匹配yyyy - mm - dd var reg = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/; console.log(reg.test(\"2021-12-22\"));//true 3、下列字符串中，出现次数最多的字母是哪个？ 以及出现次数。var str = \"sjdklfjslwersdlfjsklf\" var str = \"sjdklfjslwersdlfjsklf\"; var obj = {}; var arr = str.split(\"\"); arr.forEach((item) => { if (obj[item]) { obj[item]++; } else { obj[item] = 1; } }); console.log(obj); var arr2 = []; for (key in obj) { arr2.push(obj[key]); } var max = Math.max(...arr2); for (key in obj) { if (obj[key] === max) { console.log(\"出现最多的字母是\" + key + \"出现次数是\" + obj[key]); } } //出现最多的字母是s出现次数是4 和 出现最多的字母是l出现次数是4 4、什么是事件委托？有什么作用？ //减少代码执行优化资源,在目标集合元素的父级元素添加事件， //点击目标集合元素时，因为事件冒泡的作用实现事件委托 5、计算出以下数组的差集。 let arr = [1, 2, 3, 4, 5] arr2 = [2, 4, 6, 8] var arr = [1, 2, 3, 4, 5] var arr2 = [2, 4, 6, 8] var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }) console.log(newArr);//[1, 3, 5] 6、计算出 1 + 2 + 3 + 4 +....+100=5050 var sum=0; for(var i=1; i 7、事件传播有哪几个阶段？ 1、事件冒泡 触发的元素往父级元素传播 2、事件派发发阶段 传递过程 3、事件捕获 父级元素传播到触发的子级元素上（低版本ie） 8、json字符串和json对象如何转换？ var json = { name: \"小白\", age: 18 }; var str = JSON.stringify(json);//json转字符串 var j =JSON.parse(str)//字符串转json console.log(j); 9、格式化当前日期，yyyy - mm - dd var str = \"2021-12-24\"; function fn(str, sign = \"-\") { var arr = str.split(\"-\"); var year = arr[0]; var month = arr[1] - 1; var date = arr[2]; console.log(new Date(year, month, date)); } fn(str) 10、currentTarget和target有什么区别？ currentTarget：放定该事件的元素 target：触发了事件的元素 11、请写出web浏览器缓存机制有哪几种？分别有什么区别 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage; 本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage; 本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 12、计算出以下数组的补集。 let arr = [1,2,3,4,5] arr2 = [2,4,6,8] var arr = [1, 2, 3, 4, 5]; var arr2 = [2, 4, 6, 8]; var newArr = arr.filter(function (item) { return arr2.indexOf(item) === -1; }); var newArr2 = arr2.filter(function (item) { return arr.indexOf(item) === -1; }); console.log(newArr.concat(newArr2)); //[1, 3, 5, 6, 8] 13、使用setTimeout实现10至1的打印，每次减1，到1的时候停止打印 var i = 10; function fn() { setTimeout(() => { console.log(i--); if (i > 0) { fn(); } }, 1000); } fn(); 14、边距塌陷如何解决 在父级元素添加 overflow: hidden; 15、如何阻止事件的默认行为 e.preventDefault(); Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-03 23:18:27 "},"每周测试04.html":{"url":"每周测试04.html","title":"每周测试04","keywords":"","body":" 1、js中call、 apply、 bind有什么区别? 2、解释浅克隆与深克隆的区别，并列举出实现方法 3、请写出http请求报文的请求行、请求头、请求体分别有什么作用 4、使用axios实现以下接口的并发请求 5、js中的堆和栈是什么？有什么区别？ 6、面向对象的特点有什么？ 7、请写出ajax的流程以及相应的代码 8、请说出防抖函数与节流函数的区别，并分别用代码表示 节流： 防抖： 9、实现一个自定义filter方法 10、请写出以下代码的答案，并描述为什么 每周测试04 1、js中call、 apply、 bind有什么区别? [success] call、 apply、 bind call和apply是返回值，bind是返回函数 call和bind是选项式参数、apply是数组参数 2、解释浅克隆与深克隆的区别，并列举出实现方法 [success] 浅与深 浅克隆：只克隆对象的第一层属性 深克隆：克隆对象的所有层级的属性 //浅拷贝： Object.assign({}, {name: '小明'}) //深拷贝： function deepClone(obj) { var x = {} for (key in obj) { if (typeof obj[key] === 'object') { x[key] = deepClone(obj[key]) }else { // x[key] = obj[key] x = Object.assign(x, obj) } } return x } 3、请写出http请求报文的请求行、请求头、请求体分别有什么作用 [success] 请求 请求行：请求地址、请求类型、状态代码 请求头：请求文本类型、token密钥 请求体：发送的参数 4、使用axios实现以下接口的并发请求 http://vt.ossjk.com/goods/getIndexInfo（get、无参数） http://vt.ossjk.com/goods/getCategoryList（get、无参数） function getIndexInfo (){ return axios.get('http://vt.ossjk.com/goods/getIndexInfo') } function getCategoryList (){ return axios.get('http://vt.ossjk.com/goods/getCategoryList') } axios.all(([getIndexInfo(), getCategoryList()])) .then(axios.spread(function(res1, res2){ console.log(res1.data); console.log(res2.data); })) 5、js中的堆和栈是什么？有什么区别？ [success] 堆和栈 栈是直接赋值数据：速度快 堆是赋值引用地址：速度慢 6、面向对象的特点有什么？ [success] 特点 1、封装 2、继承 3、多态 7、请写出ajax的流程以及相应的代码 var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest() } else { xhr = new ActiveXObject('Microsoft.XMLHTTP') } xhr.open('GET','http://192.168.1.217:8080/getList') xhr.send() xhr.onreadystatechange = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.response); } } var xhr if (window.XMLHttpRequest) { xhr = new XMLHttpRequest() } else { xhr = new ActiveXObject('Microsoft.XMLHTTP') } xhr.open('POST','http://192.168.1.217:8080/getCountry') xhr.setRequestHeader('content-type', 'application/json') var data = { \"id\": '001' } xhr.send(JSON.stringify(data)) xhr.onreadystatechange = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(JSON.parse(xhr.response)); } } 8、请说出防抖函数与节流函数的区别，并分别用代码表示 [success] 防抖与节流 节流：在某段时间内，不管触发了多少次回调，只认第一次触发，无视后面次数产生的触发，并在计时结束时给予响应。 防抖： 在某段时间内，每次触发都会重新计时，直到最后一次触发超过了限定的时间 节流： var div = document.querySelector(\"div\"); function throttle(fn, time) { //节流函数 var last = 0; return function () { var now = new Date().getTime(); if (now - last >= time) { last = now; fn.apply(this, arguments); } }; } var clickHandler = throttle(function () { //具体逻辑 console.log(\"触发了\"); }, 3000); div.onclick = clickHandler; 防抖： 按钮 var btn = document.querySelector(\".btn\") function deBounce(fn, delayTime) { var timer var endTime = 0 return function () { var nowTime = +new Date() if (nowTime - endTime 9、实现一个自定义filter方法 Array.prototype.myFilter = function (fn) { var arr = this var newArr = [] for (var i = 0; i 10、请写出以下代码的答案，并描述为什么 var name = \"小明\" var obj = { name:\"小红\", obj2:{ name:\"小绿\", fn:function(){ var a = function(){ console.log(this.name) } a.call(this) } } } obj.obj2.fn() 小绿，输出语句所在的函数本来是window上的函数，直接执行a()会输出小明， 使用a.call(this)后，改变了函数this指向，现在this指向obj2，即输出obj2.name，小绿 [success] 答案 小绿 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:35:47 "},"每周测试05.html":{"url":"每周测试05.html","title":"每周测试05","keywords":"","body":" 1、vue的生命周期有哪些？ 2、请说出vue框架和传统jq的区别，以及优劣势 3、请写出js的数据类型有哪几种 4、解释浅克隆与深克隆的区别，并列举出实现方法 5、事件传播有哪几个阶段？ 6、请列举出箭头函数和普通的function有什么区别 7、写出本地离线缓存有哪儿种，以及他们的区别。 8、解释一下什么是原型链 9、把数组let arr = [[1,2],[3,4]]变为一维数组 10、v-if和v-show有什么区别？ 每周测试05 1、vue的生命周期有哪些？ beforeCreate ——创造之前 created ——创造完毕 beforeMount ——安装渲染之前 mounted ——渲染完毕 beforeUpdate ——更新之前 updated ——更新之后 beforeDestroy ——销毁之前 destroyed ——销毁之后 activated ——激活被缓存的组件 deactivated ——取消激活 errorCaptured ——错误捕捉 2、请说出vue框架和传统jq的区别，以及优劣势 vue是mvvm模式的前端框架，jq是js函数库，本质上不一样。 vue在项目维护性以及渲染速度方面要高于传统的jq。 vue是单页面应用，所以seo方面不如传统jq页面。 3、请写出js的数据类型有哪几种 数字 number; 字符串 string; 布尔值 boolean; 空值 null; 未定义 undefined; 唯一值 symbol; 对象 object; 4、解释浅克隆与深克隆的区别，并列举出实现方法 [success] 浅与深 浅克隆：只克隆对象的第一层属性 深克隆：克隆对象的所有层级的属性 //浅克隆 Object.assign({}, {name: \"张三\"}) //深克隆 function deeClone(obj){ var h = {}; for(i in obj){ if(typeof(obj) === \"object\"){ x[i] = deeClone(obj[i]) } else { x = Object.assign({},obj) } } return x } JSON.parse(JSON.stringify()) $extend(true,{},obj) 5、事件传播有哪几个阶段？ 事件派发 事件冒泡 事件捕获 6、请列举出箭头函数和普通的function有什么区别 箭头函数和普通的function最关键在于this指针的区别， 箭头函数无法修改指针，this不指向函数指向上一层， 普通函数可以修改指针，this指向函数 箭头函数无法当成构造函数使用，箭头函数没有arguments 7、写出本地离线缓存有哪儿种，以及他们的区别。 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage; 本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage; 本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 8、解释一下什么是原型链 [success] 原型链 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype 当访问一个对象的某个属性时，会先在这个对象本身属性上查找， 如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype， 如果还没有找到就会再在构造函数的prototype的__proto__中查找， 这样一层一层向上查找就会形成一个链式结构，我们称为原型链。 9、把数组let arr = [[1,2],[3,4]]变为一维数组 let arr = [[1, 2], [3, 4]] // console.log(arr.flat(Infinity)) console.log(arr.flat(1)) 10、v-if和v-show有什么区别？ v-if：如果是少量渲染的情况 v-show：反复渲染的情况 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 23:35:56 "},"每周测试06.html":{"url":"每周测试06.html","title":"每周测试06","keywords":"","body":" 1、使用vue代码写出作用域插槽的案例 2、vue中如何更新数组或者对象的渲染 3、请用vue代码写出eventBus订阅发布模式案例 4、vue如何获取父子组件的属性和方法 5、请用vue代码写出子组件传数据给父组件案例 6、使用vue代码实现v-model的高级用法（在组件上使用v-model传递数据） 7、请用代码写出，vue中子组件如何传数据给父组件 8、请用vue代码写出父组件传数据给子组件案例 9、请用vue代码写出依赖注入案例 10、在vue2里面v-if和v-for哪个优先级更高？ 每周测试06 1、使用vue代码写出作用域插槽的案例 let myComponent1 = { template: ``, data() { return { msg: '子组件数据' } } } new Vue({ el: '#app', data: {}, components: { myComponent1, },}) 2、vue中如何更新数组或者对象的渲染 this.$set(this.arr,5,\"x\") 3、请用vue代码写出eventBus订阅发布模式案例 Vue.prototype.$eventBus = new Vue() let myComponent1 = { template: `子组件a发送`, data() { return { msg: '子组件的数据' } }, methods: { send() { this.$eventBus.$emit('childeven', this.msg) } }, } new Vue({ el: '#app', data: { fathermsg: '' }, components: { myComponent1, }, created() { this.$eventBus.$on('childeven', e => { this.fathermsg = e }) }, }) 4、vue如何获取父子组件的属性和方法 this.$parent.msg this.$parent.fn() this.$children[0].msg this.$children[0].fn() 5、请用vue代码写出子组件传数据给父组件案例 Vue.prototype.$eventBus = new Vue() let myComponent1 = { template: `子组件a发送`, data() { return { msg: '子组件的数据' } }, methods: { send() { this.$emit('childeven', this.msg) } }, } new Vue({ el: '#app', data: { fathermsg: '' }, components: { myComponent1, }, methods: { fn(e) { this.fathermsg = e } }, }) 6、使用vue代码实现v-model的高级用法（在组件上使用v-model传递数据） Vue.prototype.$eventBus = new Vue() let myComponent1 = { template: `子组件a发送`, data() { return { childnum: this.num } }, props: ['num'], model: { prop: 'num', event: 'childeven' }, methods: { change() { this.childnum++ this.$emit('childeven', this.childnum) } }, } new Vue({ el: '#app', data: { num: 1 }, components: { myComponent1, }, methods: {}, }) 7、请用代码写出，vue中子组件如何传数据给父组件 let myComponent = { template: \"子组件按钮\", data() { return { msg1: \"我是子组件1\", msg2: \"我是子组件2\", } }, methods: { handler() { this.$emit(\"childevent\", { msg1: this.msg1, msg2: this.msg2 }) } }, } new Vue({ el: \"#app\", components: { myComponent, }, methods: { fatherevent(e) { console.log(e); } } }) 8、请用vue代码写出父组件传数据给子组件案例 let myComponent1 = { template: `子组件a`, props: ['childmsg'] } new Vue({ el: '#app', data: { fathermsg: '父组件的数据' }, components: { myComponent1, } }) 9、请用vue代码写出依赖注入案例 let myComponent1 = { template: `子组件a`, inject: ['msg'] } let myComponent2 = { template: `子组件b`, inject: ['msg'], components: { myComponent1 } } new Vue({ el: '#app', provide() { return { msg: '父组件的数据' } }, data: {}, components: { myComponent2, } }) 10、在vue2里面v-if和v-for哪个优先级更高？ v-for比v-if优先级高 Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-01-20 23:51:44 "},"每周测试07.html":{"url":"每周测试07.html","title":"每周测试07","keywords":"","body":" 1、组件之间怎么传递数据？ 2、vue的生命周期有哪些？ 3、js中call、 apply、 bind有什么区别? 4、使用自定义指令实现节流函数 5、解释浅克隆与深克隆的区别，并列举出实现方法 6、请用vue代码写出eventBus订阅发布模式案例 7、解释一下什么是原型链 8、请写出vuex的核心内容有哪几个？分别有什么功能？ 9、请写出web浏览器缓存机制有哪几种？分别有什么区别 10、写出git的下列操作指令 每周测试07 1、组件之间怎么传递数据？ 父传子：propos 子传父：__$emit__ 非父子：__eventBus__、依赖注入、__v-bind=\"$attrs\"和v-on=\"$listeners\"、vuex 2、vue的生命周期有哪些？ beforeCreate 创造之前 created 创造完毕 beforeMount 安装渲染之前 mounted 渲染完毕 beforeUpdate 更新之前 updated 更新之后 beforeDestroy销毁之前 destroyed 销毁之后 activated 激活被缓存的组件 deactivated 取消激活 errorCaptured 错误捕捉 3、js中call、 apply、 bind有什么区别? call和apply是返回值，bind是返回函数 call和bind是选项式参数、apply是数组参数 4、使用自定义指令实现节流函数 节流 directives: { mythrottle: { inserted(el, binding) { let f = binding.value.handlerFn; let delayTime = binding.value.delayTime; let event = binding.arg; function throttle(fn, time) { let endTime = 0; return function () { let nowTime = Date.now(); if (nowTime - endTime >= time) { fn(); endTime = nowTime; } }; } let callback = throttle(f, delayTime); el.addEventListener(event, callback); }, }, }, methods: { fn() { console.log(123); }, }, 5、解释浅克隆与深克隆的区别，并列举出实现方法 浅克隆：只克隆对象的第一层属性 深克隆：克隆对象的所有层级的属性 //浅克隆 Object.assign({}, {name: \"张三\"}) //深克隆 JSON.parse(JSON.stringify()) 6、请用vue代码写出eventBus订阅发布模式案例 Vue.prototype.$eventBus = new Vue() let myComponent1 = { template: \"组件1发送\", data() { return { msg: '组件1的数据' } }, methods: { send() { this.$eventBus.$emit('myevent', this.msg) } }, } let myComponent2 = { template: '组件2', data() { return { msg: '' } }, created() { this.$eventBus.$on(\"myevent\", e => { this.msg = e }) }, } new Vue({ el: '#app', data: {}, components: { myComponent1, myComponent2 } }) 7、解释一下什么是原型链 当访问一个对象的某个属性时，会先在这个对象本身属性上查找， 如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的__prototype__ 8、请写出vuex的核心内容有哪几个？分别有什么功能？ state, getters, mutations, actions, modules // state 存放数据状态 // getter 计算属性 // mutation同步提交方法，用于更改在state中定义的数据 // actions 异步提交方法，用于异步更改在state中定义的数据 // Module 模块化 9、请写出web浏览器缓存机制有哪几种？分别有什么区别 cookie; 1、最早，兼容性最好 2、不能直接在谷歌浏览器下操作，只能使用其他浏览器或者在服务器环境操控 3、存储数据大小（4kb，谷歌浏览器） 4、存储条数（20条，谷歌浏览器） 5、操作繁琐（相对于另外两个） 6、默认关闭浏览器就会消失，如果想要保存需要设置过期时间 localStorage; 本地持久级存储 1、h5新特性，不能兼容低版本浏览器 2、默认情况下，永久存储 3、存储的数据会变成字符串 4、存储数据大小（5mb，谷歌浏览器） 5、存储条数（存储条数不限制） 6、操作相对简单（相对于cookie） sessionStorage; 本地会话级存储 1、所有特性都与localStorage一样，只有存储时间不同，sessionStorage默认关闭浏览器就消失 10、写出git的下列操作指令 写出git的下列操作指令，克隆、拉取、添加到暂存区、添加到本地git仓库、推送到远程git仓库 克隆：git clone 拉取：git pull 添加到暂存区：git add . 添加到本地仓库：git commit -m \"提交信息\" 推送到远程仓库：git push Ashun © aiavnf@gmail.com 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-11 22:09:55 "}}